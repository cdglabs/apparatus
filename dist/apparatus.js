(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    // We want a single cursor position.
    if (this.listSelections().length > 1 || this.somethingSelected()) return;

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = this.buildOptions(options);
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor();
    this.startLen = this.cm.getLine(this.startPos.line).length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return;
      if (this.data) CodeMirror.signal(this.data, "update");
      if (!this.options.hint.async) {
        this.finishUpdate(this.options.hint(this.cm, this.options), first);
      } else {
        var myTick = ++this.tick, self = this;
        this.options.hint(this.cm, function(data) {
          if (self.tick == myTick) self.finishUpdate(data, first);
        }, this.options);
      }
    },

    finishUpdate: function(data, first) {
      this.data = data;

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    },

    buildOptions: function(options) {
      var editor = this.cm.options.hintOptions;
      var out = {};
      for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
      if (editor) for (var prop in editor)
        if (editor[prop] !== undefined) out[prop] = editor[prop];
      if (options) for (var prop in options)
        if (options[prop] !== undefined) out[prop] = options[prop];
      return out;
    }
  };

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;

    var hints = this.hints = document.createElement("ul");
    hints.className = "CodeMirror-hints";
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    var startScroll = cm.getScrollInfo();
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[0], hints.firstChild);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  CodeMirror.registerHelper("hint", "auto", function(cm, options) {
    var helpers = cm.getHelpers(cm.getCursor(), "hint"), words;
    if (helpers.length) {
      for (var i = 0; i < helpers.length; i++) {
        var cur = helpers[i](cm, options);
        if (cur && cur.list.length) return cur;
      }
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      if (words) return CodeMirror.hint.fromList(cm, {words: words});
    } else if (CodeMirror.hint.anyword) {
      return CodeMirror.hint.anyword(cm, options);
    }
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, token.string.length) == token.string)
        found.push(word);
    }

    if (found.length) return {
      list: found,
      from: CodeMirror.Pos(cur.line, token.start),
            to: CodeMirror.Pos(cur.line, token.end)
    };
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: false,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});

},{"../../lib/codemirror":2}],2:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedOverlay = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedOverlay && measure.clientHeight > 0) {
        if (sWidth == 0) this.overlayHack();
        this.checkedOverlay = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
    },
    overlayHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.minHeight = this.vert.style.minWidth = w;
      var self = this;
      var barMouseDown = function(e) {
        if (e_target(e) != self.vert && e_target(e) != self.horiz)
          operation(self.cm, onMouseDown)(e);
      };
      on(this.vert, "mousedown", barMouseDown);
      on(this.horiz, "mousedown", barMouseDown);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    var total = measure.docHeight + cm.display.barHeight;
    cm.display.heightForcer.style.top = total + "px";
    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                             "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = splitLines(inserted), multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted)
        multiPaste = sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
      else if (textLines.length == sel.ranges.length)
        multiPaste = map(textLines, function(l) { return [l]; });
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !paste) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
    if (pasted) {
      e.preventDefault();
      runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) return;
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          indented = indentLine(cm, range.head.line, "smart");
      }
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function(e) {
        if (handlePaste(e, cm)) return true;

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput) ||
          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
        return false;

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) prevInput = "\u200b";
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, self.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;

        if (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText;
      input.wrapper.style.position = "absolute";
      te.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.position = "relative";
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      div.contentEditable = "true";
      disableBrowserMagic(div);

      on(div, "paste", function(e) { handlePaste(e, cm); })

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (!input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        sel.removeAllRanges();
        sel.addRange(rng);
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.lineDiv.lastChild;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.setAttribute("contenteditable", "false");
    },

    onKeyPress: function(e) {
      e.preventDefault();
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false;
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join("\n");
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += "\n";
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i]();
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
    if (op.focus && op.focus == activeElt()) ensureFocus(op.cm);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      simple: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
      start: function(e){onDragStart(cm, e);},
      drop: operation(cm, onDrop)
    };

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != CodeMirror.Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.simple);
      toggle(cm.display.scroller, "dragover", funcs.simple);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else cm.curOp.focus = activeElt();

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
        (cmp(contained.to(), start) > 0 || start.xRel < 0))
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display, startTime = +new Date;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date - 200 < startTime)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) cm.display.input.reset();
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2)
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.4.0";

  return CodeMirror;
});

},{}],3:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function maybedefault(_, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function typedef(type) {
    if (type == "variable") {cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype, maybedefault);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "extends") return cont(expression, classNameAfter);
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      if (value == "static") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
      return cont(functiondef, classBody);
    }
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
  }
  function classGetterSetter(type) {
    if (type != "variable") return pass();
    cx.marked = "property";
    return cont();
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

},{"../../lib/codemirror":2}],4:[function(require,module,exports){
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
  var k,
    _handlers = {},
    _mods = { 16: false, 18: false, 17: false, 91: false },
    _scope = 'all',
    // modifier keys
    _MODIFIERS = {
      '': 16, shift: 16,
      '': 18, alt: 18, option: 18,
      '': 17, ctrl: 17, control: 17,
      '': 91, command: 91
    },
    // special keys
    _MAP = {
      backspace: 8, tab: 9, clear: 12,
      enter: 13, 'return': 13,
      esc: 27, escape: 27, space: 32,
      left: 37, up: 38,
      right: 39, down: 40,
      del: 46, 'delete': 46,
      home: 36, end: 35,
      pageup: 33, pagedown: 34,
      ',': 188, '.': 190, '/': 191,
      '`': 192, '-': 189, '=': 187,
      ';': 186, '\'': 222,
      '[': 219, ']': 221, '\\': 220
    },
    code = function(x){
      return _MAP[x] || x.toUpperCase().charCodeAt(0);
    },
    _downKeys = [];

  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

  // IE doesn't support Array#indexOf, so have a simple replacement
  function index(array, item){
    var i = array.length;
    while(i--) if(array[i]===item) return i;
    return -1;
  }

  // for comparing mods before unassignment
  function compareArray(a1, a2) {
    if (a1.length != a2.length) return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  var modifierMap = {
      16:'shiftKey',
      18:'altKey',
      17:'ctrlKey',
      91:'metaKey'
  };
  function updateModifierKey(event) {
      for(k in _mods) _mods[k] = event[modifierMap[k]];
  };

  // handle keydown event
  function dispatch(event) {
    var key, handler, k, i, modifiersMatch, scope;
    key = event.keyCode;

    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }

    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
    if(key in _mods) {
      _mods[key] = true;
      // 'assignKey' from inside this closure is exported to window.key
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
      return;
    }
    updateModifierKey(event);

    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if(!assignKey.filter.call(this, event)) return;

    // abort if no potentially matching shortcuts found
    if (!(key in _handlers)) return;

    scope = getScope();

    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
      handler = _handlers[key][i];

      // see if it's in the current scope
      if(handler.scope == scope || handler.scope == 'all'){
        // check if modifiers match if any
        modifiersMatch = handler.mods.length > 0;
        for(k in _mods)
          if((!_mods[k] && index(handler.mods, +k) > -1) ||
            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
        // call the handler and stop the event if neccessary
        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
          if(handler.method(event, handler)===false){
            if(event.preventDefault) event.preventDefault();
              else event.returnValue = false;
            if(event.stopPropagation) event.stopPropagation();
            if(event.cancelBubble) event.cancelBubble = true;
          }
        }
      }
    }
  };

  // unset modifier keys on keyup
  function clearModifier(event){
    var key = event.keyCode, k,
        i = index(_downKeys, key);

    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }

    if(key == 93 || key == 224) key = 91;
    if(key in _mods) {
      _mods[key] = false;
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
    }
  };

  function resetModifiers() {
    for(k in _mods) _mods[k] = false;
    for(k in _MODIFIERS) assignKey[k] = false;
  };

  // parse and assign shortcut
  function assignKey(key, scope, method){
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
      method = scope;
      scope = 'all';
    }

    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
      // set modifier keys if any
      mods = [];
      key = keys[i].split('+');
      if (key.length > 1){
        mods = getMods(key);
        key = [key[key.length-1]];
      }
      // convert to keycode and...
      key = key[0]
      key = code(key);
      // ...store handler
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
    }
  };

  // unbind all handlers for given key in current scope
  function unbindKey(key, scope) {
    var multipleKeys, keys,
      mods = [],
      i, j, obj;

    multipleKeys = getKeys(key);

    for (j = 0; j < multipleKeys.length; j++) {
      keys = multipleKeys[j].split('+');

      if (keys.length > 1) {
        mods = getMods(keys);
        key = keys[keys.length - 1];
      }

      key = code(key);

      if (scope === undefined) {
        scope = getScope();
      }
      if (!_handlers[key]) {
        return;
      }
      for (i = 0; i < _handlers[key].length; i++) {
        obj = _handlers[key][i];
        // only clear handlers if correct scope and mods match
        if (obj.scope === scope && compareArray(obj.mods, mods)) {
          _handlers[key][i] = {};
        }
      }
    }
  };

  // Returns true if the key with code 'keyCode' is currently down
  // Converts strings into key codes.
  function isPressed(keyCode) {
      if (typeof(keyCode)=='string') {
        keyCode = code(keyCode);
      }
      return index(_downKeys, keyCode) != -1;
  }

  function getPressedKeyCodes() {
      return _downKeys.slice(0);
  }

  function filter(event){
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
  }

  // initialize key.<modifier> to false
  for(k in _MODIFIERS) assignKey[k] = false;

  // set current scope (default 'all')
  function setScope(scope){ _scope = scope || 'all' };
  function getScope(){ return _scope || 'all' };

  // delete all handlers for a given scope
  function deleteScope(scope){
    var key, handlers, i;

    for (key in _handlers) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);
        else i++;
      }
    }
  };

  // abstract key logic for assign and unassign
  function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if ((keys[keys.length - 1]) == '') {
      keys[keys.length - 2] += ',';
    }
    return keys;
  }

  // abstract mods logic for assign and unassign
  function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
    mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
  }

  // cross-browser events
  function addEvent(object, event, method) {
    if (object.addEventListener)
      object.addEventListener(event, method, false);
    else if(object.attachEvent)
      object.attachEvent('on'+event, function(){ method(window.event) });
  };

  // set the handlers globally on document
  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
  addEvent(document, 'keyup', clearModifier);

  // reset modifiers to false whenever the window is (re)focused.
  addEvent(window, 'focus', resetModifiers);

  // store previously defined key
  var previousKey = global.key;

  // restore previously defined key and return reference to our key object
  function noConflict() {
    var k = global.key;
    global.key = previousKey;
    return k;
  }

  // set window.key and window.key.set/get/deleteScope, and the default filter
  global.key = assignKey;
  global.key.setScope = setScope;
  global.key.getScope = getScope;
  global.key.deleteScope = deleteScope;
  global.key.filter = filter;
  global.key.isPressed = isPressed;
  global.key.getPressedKeyCodes = getPressedKeyCodes;
  global.key.noConflict = noConflict;
  global.key.unbind = unbindKey;

  if(typeof module !== 'undefined') module.exports = assignKey;

})(this);

},{}],5:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		var key = parts[0];
		var val = parts[1];

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (Array.isArray(val)) {
			return val.sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"strict-uri-encode":7}],7:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16);
	});
};

},{}],8:[function(require,module,exports){

/*

A ComputationManager is used to memoize functions within a computation. Use
ComputationManager.run(callback) to start a new computation and then any
memoized functions will be memoized within that computation.

TODO: Write tests
 */
var ComputationManager;

module.exports = ComputationManager = (function() {
  function ComputationManager() {
    this.isRunning = false;
    this.counter = 0;
  }

  ComputationManager.prototype.run = function(callback) {
    this.isRunning = true;
    this.counter++;
    try {
      return callback();
    } finally {
      this.isRunning = false;
    }
  };

  ComputationManager.prototype.memoize = function(fn) {
    var cachedValue, lastEvaluated;
    cachedValue = null;
    lastEvaluated = -1;
    return (function(_this) {
      return function() {
        if (lastEvaluated !== _this.counter) {
          cachedValue = fn();
          lastEvaluated = _this.counter;
        }
        return cachedValue;
      };
    })(this);
  };

  return ComputationManager;

})();


},{}],9:[function(require,module,exports){
var ComputationManager, Dataflow, DynamicScope, Spread, SpreadEnv, UnresolvedSpreadError, _, cell, computationManager, dynamicScope;

_ = require("underscore");

ComputationManager = require("./ComputationManager");

DynamicScope = require("./DynamicScope");

Spread = require("./Spread");

SpreadEnv = require("./SpreadEnv");

computationManager = new ComputationManager();

dynamicScope = new DynamicScope({
  spreadEnv: SpreadEnv.empty,
  shouldThrow: false
});

UnresolvedSpreadError = (function() {
  function UnresolvedSpreadError(spread1) {
    this.spread = spread1;
  }

  return UnresolvedSpreadError;

})();

cell = function(fn) {
  var asSpread, cellFn, distributeAcrossSpread, evaluateFull, resolve, runFn;
  runFn = function() {
    var error;
    try {
      if (dynamicScope.context.shouldThrow) {
        return fn();
      }
      return dynamicScope["with"]({
        shouldThrow: true
      }, fn);
    } catch (_error) {
      error = _error;
      if (error instanceof UnresolvedSpreadError) {
        return distributeAcrossSpread(error.spread);
      } else {
        throw error;
      }
    }
  };
  distributeAcrossSpread = function(spread) {
    var currentSpreadEnv, items;
    currentSpreadEnv = dynamicScope.context.spreadEnv;
    items = _.map(spread.items, function(item, index) {
      var spreadEnv;
      spreadEnv = currentSpreadEnv.assign(spread, index);
      return dynamicScope["with"]({
        spreadEnv: spreadEnv
      }, runFn);
    });
    return new Spread(items, spread.origin);
  };
  evaluateFull = function() {
    return dynamicScope["with"]({
      spreadEnv: SpreadEnv.empty
    }, runFn);
  };
  evaluateFull = computationManager.memoize(evaluateFull);
  resolve = function(value) {
    var currentSpreadEnv;
    currentSpreadEnv = dynamicScope.context.spreadEnv;
    return currentSpreadEnv.resolve(value);
  };
  asSpread = function() {
    var value;
    if (!computationManager.isRunning) {
      return computationManager.run(asSpread);
    }
    value = evaluateFull();
    value = resolve(value);
    return value;
  };
  cellFn = function() {
    var value;
    if (!computationManager.isRunning) {
      return computationManager.run(cellFn);
    }
    value = asSpread();
    if (dynamicScope.context.shouldThrow && value instanceof Spread) {
      throw new UnresolvedSpreadError(value);
    }
    return value;
  };
  cellFn.asSpread = asSpread;
  return cellFn;
};

module.exports = Dataflow = {
  run: function(callback) {
    return computationManager.run(callback);
  },
  currentSpreadEnv: function() {
    return dynamicScope.context.spreadEnv;
  },
  memoize: function(fn) {
    return computationManager.memoize(fn);
  },
  cell: cell,
  Spread: Spread,
  SpreadEnv: SpreadEnv,
  UnresolvedSpreadError: UnresolvedSpreadError
};


},{"./ComputationManager":8,"./DynamicScope":10,"./Spread":11,"./SpreadEnv":12,"underscore":"underscore"}],10:[function(require,module,exports){
var DynamicScope, _,
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

module.exports = DynamicScope = (function() {
  function DynamicScope(context) {
    this.context = context != null ? context : {};
  }

  DynamicScope.prototype["with"] = function(newContext, fn) {
    var previousContext, result;
    previousContext = this.context;
    this._updateContext(previousContext, newContext);
    try {
      result = fn();
    } finally {
      this.context = previousContext;
    }
    return result;
  };

  DynamicScope.prototype._updateContext = function(previousContext, newContext) {
    var key, results, value;
    this.context = newContext;
    results = [];
    for (key in previousContext) {
      if (!hasProp.call(previousContext, key)) continue;
      value = previousContext[key];
      if (!this.context.hasOwnProperty(key)) {
        results.push(this.context[key] = value);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return DynamicScope;

})();


},{"underscore":"underscore"}],11:[function(require,module,exports){
var Spread, _;

_ = require("underscore");

module.exports = Spread = (function() {
  function Spread(items, origin) {
    this.items = items;
    this.origin = origin;
  }

  Spread.prototype.toArray = function() {
    return _.map(this.items, function(item) {
      if (item instanceof Spread) {
        return item.toArray();
      } else {
        return item;
      }
    });
  };

  Spread.prototype.flattenToArray = function() {
    return _.flatten(this.toArray());
  };

  return Spread;

})();


},{"underscore":"underscore"}],12:[function(require,module,exports){
var Spread, SpreadEnv;

Spread = require("./Spread");

module.exports = SpreadEnv = (function() {
  function SpreadEnv(parent, origin, index1) {
    this.parent = parent;
    this.origin = origin;
    this.index = index1;
  }

  SpreadEnv.prototype.lookup = function(spread) {
    var ref;
    if (spread.origin === this.origin) {
      return this.index;
    }
    return (ref = this.parent) != null ? ref.lookup(spread) : void 0;
  };

  SpreadEnv.prototype.resolve = function(value) {
    var index;
    if (value instanceof Spread) {
      index = this.lookup(value);
      if (index != null) {
        value = value.items[index];
        return this.resolve(value);
      }
    }
    return value;
  };

  SpreadEnv.prototype.resolveWithDefault = function(value) {
    var index, ref;
    if (value instanceof Spread) {
      index = (ref = this.lookup(value)) != null ? ref : 0;
      value = value.items[index];
      return this.resolveWithDefault(value);
    }
    return value;
  };

  SpreadEnv.prototype.assign = function(spread, index) {
    return new SpreadEnv(this, spread.origin, index);
  };

  SpreadEnv.prototype.isEqualTo = function(spreadEnv) {
    if (spreadEnv == null) {
      return false;
    }
    if (!(this.origin === spreadEnv.origin && this.index === spreadEnv.index)) {
      return false;
    }
    if (!this.parent && !spreadEnv.parent) {
      return true;
    }
    return this.parent.isEqualTo(spreadEnv.parent);
  };

  SpreadEnv.prototype.contains = function(spreadEnv) {
    if (spreadEnv == null) {
      return false;
    }
    if (this.isEqualTo(spreadEnv)) {
      return true;
    }
    return this.contains(spreadEnv.parent);
  };

  return SpreadEnv;

})();

SpreadEnv.empty = new SpreadEnv();


},{"./Spread":11}],13:[function(require,module,exports){
module.exports = {
  evaluate: require("./evaluate")
};


},{"./evaluate":14}],14:[function(require,module,exports){
var E, LN10, LN2, LOG10E, LOG2E, PI, SQRT1_2, SQRT2, TAU, abs, acos, asin, atan, atan2, ceil, cos, evaluate, exp, floor, log, max, min, pow, random, rgba, round, sin, spread, sqrt, tan;

module.exports = evaluate = function(jsString) {
  return eval(jsString);
};

E = Math.E;

LN2 = Math.LN2;

LN10 = Math.LN10;

LOG2E = Math.LOG2E;

LOG10E = Math.LOG10E;

PI = Math.PI;

SQRT1_2 = Math.SQRT1_2;

SQRT2 = Math.SQRT2;

TAU = Math.PI * 2;

abs = Math.abs;

acos = Math.acos;

asin = Math.asin;

atan = Math.atan;

atan2 = Math.atan2;

ceil = Math.ceil;

cos = Math.cos;

exp = Math.exp;

floor = Math.floor;

log = Math.log;

max = Math.max;

min = Math.min;

pow = Math.pow;

random = Math.random;

round = Math.round;

sin = Math.sin;

sqrt = Math.sqrt;

tan = Math.tan;

rgba = function(r, g, b, a) {
  r = Math.round(r * 255);
  g = Math.round(g * 255);
  b = Math.round(b * 255);
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
};

spread = require("./spread");


},{"./spread":15}],15:[function(require,module,exports){
var Dataflow, _, spread;

_ = require("underscore");

Dataflow = require("../Dataflow/Dataflow");

module.exports = spread = function(start, end, increment) {
  var array, i, n;
  if (increment == null) {
    increment = 1;
  }
  if (_.isArray(start)) {
    return new Dataflow.Spread(start);
  }
  if ((start == null) || (end == null)) {
    throw "Spread needs arguments: spread(start, end) or spread(start, end, increment) or spread(array)";
  }
  if (increment === 0) {
    throw "Spread increment cannot be 0";
  }
  if (!_.isFinite(increment)) {
    throw "Spread increment must be finite";
  }
  n = (end - start) / increment;
  array = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(start + increment * i);
    }
    return results;
  })();
  return new Dataflow.Spread(array);
};


},{"../Dataflow/Dataflow":9,"underscore":"underscore"}],16:[function(require,module,exports){
var Graphic, _, dummyCanvasCtx, getDummyCanvasCtx,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

module.exports = Graphic = {};

Graphic.Element = (function() {
  function Element() {}


  /*
  
  Each Graphic.Element must have these properties:
  
  particularElement: The ParticularElement that generated the graphic. This is
  used for "back tracing" what part of the model generated this graphic, e.g.
  to implement selection when you click a shape on the canvas.
  
  matrix: a Util.Matrix that is the graphic's *accumulated* transformation.
  
  components: a list of Graphic.Component's representing the paint operations
  to perform.
  
  childGraphics: a list of Graphic.Element's.
   */

  Element.prototype.render = function(opts) {

    /*
    Opts:
    
    ctx: Canvas 2D context to render into.
    
    viewMatrix:
    
    highlight(graphic): A function that takes in a graphic and returns either
    a color or null.
     */
    throw "Not implemented";
  };

  Element.prototype.hitDetect = function(opts) {

    /*
    
    Given (x,y), returns null if there is nothing under (x,y), that is (x,y)
    is a background pixel. Otherwise returns a list of ParticularElements which are
    under (x,y). The list goes in order of deepest to shallowest. So assuming
    there's a hit: the first ParticularElement is the deepest one that is under (x,y)
    and the last ParticularElement is (necessarily) this.particularElement.
    
    Opts:
    
    x, y: Position to hit detect.
    
    viewMatrix:
    
    shouldDetectAnchor(anchor): A function that takes in an anchor graphic and
    returns true or false whether to hit detect that anchor.
     */
    throw "Not implemented";
  };

  Element.prototype.componentOfType = function(type) {
    return _.find(this.components, function(component) {
      return component instanceof type;
    });
  };

  Element.prototype.componentsOfType = function(type) {
    return _.filter(this.components, function(component) {
      return component instanceof type;
    });
  };

  return Element;

})();

Graphic.Group = (function(superClass) {
  extend(Group, superClass);

  function Group() {
    return Group.__super__.constructor.apply(this, arguments);
  }

  Group.prototype.render = function(opts) {
    var childGraphic, i, len, ref, results;
    ref = this.childGraphics;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      childGraphic = ref[i];
      results.push(childGraphic.render(opts));
    }
    return results;
  };

  Group.prototype.hitDetect = function(opts) {
    var childGraphic, i, latestHit, len, ref, ref1;
    latestHit = null;
    ref = this.childGraphics;
    for (i = 0, len = ref.length; i < len; i++) {
      childGraphic = ref[i];
      latestHit = (ref1 = childGraphic.hitDetect(opts)) != null ? ref1 : latestHit;
    }
    if (latestHit) {
      return latestHit.concat(this.particularElement);
    } else {
      return null;
    }
  };

  return Group;

})(Graphic.Element);

Graphic.Anchor = (function(superClass) {
  extend(Anchor, superClass);

  function Anchor() {
    return Anchor.__super__.constructor.apply(this, arguments);
  }

  return Anchor;

})(Graphic.Element);

Graphic.Path = (function(superClass) {
  extend(Path, superClass);

  function Path() {
    return Path.__super__.constructor.apply(this, arguments);
  }

  Path.prototype.render = function(opts) {
    this.buildPath(opts);
    this.performPaintOps(opts);
    return this.highlightIfNecessary(opts);
  };

  Path.prototype.hitDetect = function(opts) {
    var ctx, x, y;
    opts.ctx = getDummyCanvasCtx();
    ctx = opts.ctx, x = opts.x, y = opts.y;
    this.buildPath(opts);
    if (ctx.isPointInPath(x, y)) {
      return [this.particularElement];
    } else {
      return null;
    }
  };

  Path.prototype.performPaintOps = function(arg) {
    var component, ctx, i, len, ref, results;
    ctx = arg.ctx;
    ref = this.componentsOfType(Graphic.PaintOp);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      results.push(component.paint(ctx));
    }
    return results;
  };

  Path.prototype.highlightIfNecessary = function(arg) {
    var ctx, highlight, highlightSpec;
    highlight = arg.highlight, ctx = arg.ctx;
    if (!highlight) {
      return;
    }
    highlightSpec = highlight(this);
    if (highlightSpec) {
      ctx.save();
      ctx.strokeStyle = highlightSpec.color;
      ctx.lineWidth = highlightSpec.lineWidth;
      ctx.stroke();
      return ctx.restore();
    }
  };

  Path.prototype.buildPath = function(arg) {
    var anchor, anchors, ctx, i, len, ref, viewMatrix, x, y;
    ctx = arg.ctx, viewMatrix = arg.viewMatrix;
    ctx.beginPath();
    anchors = this.collectAnchors();
    for (i = 0, len = anchors.length; i < len; i++) {
      anchor = anchors[i];
      ref = viewMatrix.compose(anchor.matrix).origin(), x = ref[0], y = ref[1];
      ctx.lineTo(x, y);
    }
    if (this.isClosed()) {
      return ctx.closePath();
    }
  };

  Path.prototype.collectAnchors = function() {
    var anchors, collect, collectChildrenOf;
    anchors = [];
    collect = function(graphic) {
      if (graphic instanceof Graphic.Anchor) {
        return anchors.push(graphic);
      } else if (graphic instanceof Graphic.Group) {
        return collectChildrenOf(graphic);
      }
    };
    collectChildrenOf = function(graphic) {
      var childGraphic, i, len, ref, results;
      ref = graphic.childGraphics;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        childGraphic = ref[i];
        results.push(collect(childGraphic));
      }
      return results;
    };
    collectChildrenOf(this);
    return anchors;
  };

  Path.prototype.isClosed = function() {
    var pathComponent;
    pathComponent = this.componentOfType(Graphic.PathComponent);
    return pathComponent.closed;
  };

  return Path;

})(Graphic.Element);

Graphic.Circle = (function(superClass) {
  extend(Circle, superClass);

  function Circle() {
    return Circle.__super__.constructor.apply(this, arguments);
  }

  Circle.prototype.buildPath = function(arg) {
    var ctx, matrix, viewMatrix;
    ctx = arg.ctx, viewMatrix = arg.viewMatrix;
    ctx.beginPath();
    ctx.save();
    matrix = viewMatrix.compose(this.matrix);
    matrix.canvasTransform(ctx);
    ctx.arc(0, 0, 1, 0, 2 * Math.PI, false);
    return ctx.restore();
  };

  return Circle;

})(Graphic.Path);

Graphic.Text = (function(superClass) {
  extend(Text, superClass);

  function Text() {
    return Text.__super__.constructor.apply(this, arguments);
  }

  Text.prototype.render = function(opts) {
    var ctx;
    ctx = opts.ctx;
    ctx.save();
    this.setupText(opts);
    this.renderText(opts);
    ctx.restore();
    if (opts.highlight) {
      this.buildPath(opts);
      return this.highlightIfNecessary(opts);
    }
  };

  Text.prototype.textComponent = function() {
    return this.componentOfType(Graphic.TextComponent);
  };

  Text.prototype.renderText = function(arg) {
    var ctx, text;
    ctx = arg.ctx;
    text = this.textComponent().text;
    return ctx.fillText(text, 0, 0);
  };

  Text.prototype.textMultiplier = 100;

  Text.prototype.setupText = function(arg) {
    var color, ctx, fontFamily, matrix, ref, text, textAlign, textBaseline, viewMatrix;
    ctx = arg.ctx, viewMatrix = arg.viewMatrix;
    ref = this.textComponent(), text = ref.text, fontFamily = ref.fontFamily, textAlign = ref.textAlign, textBaseline = ref.textBaseline, color = ref.color;
    matrix = viewMatrix.compose(this.matrix);
    matrix = matrix.scale(1 / this.textMultiplier, -1 / this.textMultiplier);
    matrix.canvasTransform(ctx);
    ctx.font = this.textMultiplier + "px " + fontFamily;
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    return ctx.fillStyle = color;
  };

  Text.prototype.buildPath = function(opts) {
    var baseline, color, ctx, fontFamily, height, matrix, maxX, maxY, minX, minY, ref, text, textAlign, textBaseline, viewMatrix, width;
    ctx = opts.ctx, viewMatrix = opts.viewMatrix;
    ctx.save();
    this.setupText(opts);
    ref = this.textComponent(), text = ref.text, fontFamily = ref.fontFamily, textAlign = ref.textAlign, textBaseline = ref.textBaseline, color = ref.color;
    width = ctx.measureText(text).width / this.textMultiplier;
    height = 1;
    ctx.restore();
    if (textAlign === "left" || textAlign === "start") {
      minX = 0;
      maxX = width;
    } else if (textAlign === "right" || textAlign === "end") {
      minX = -width;
      maxX = 0;
    } else if (textAlign === "center") {
      minX = -width / 2;
      maxX = width / 2;
    }
    baseline = 0.25;
    if (textBaseline === "top") {
      minY = -height - baseline;
      maxY = -baseline;
    } else if (textBaseline === "middle") {
      minY = (-height - baseline) / 2;
      maxY = (height + baseline) / 2;
    } else if (textBaseline === "alphabetic") {
      minY = -baseline;
      maxY = height - baseline;
    } else if (textBaseline === "bottom") {
      minY = 0;
      maxY = height;
    }
    ctx.save();
    matrix = viewMatrix.compose(this.matrix);
    matrix.canvasTransform(ctx);
    ctx.beginPath();
    ctx.moveTo(minX, minY);
    ctx.lineTo(minX, maxY);
    ctx.lineTo(maxX, maxY);
    ctx.lineTo(maxX, minY);
    ctx.closePath();
    return ctx.restore();
  };

  return Text;

})(Graphic.Path);

Graphic.Component = (function() {
  function Component() {}

  return Component;

})();

Graphic.PaintOp = (function(superClass) {
  extend(PaintOp, superClass);

  function PaintOp() {
    return PaintOp.__super__.constructor.apply(this, arguments);
  }

  return PaintOp;

})(Graphic.Component);

Graphic.Fill = (function(superClass) {
  extend(Fill, superClass);

  function Fill() {
    return Fill.__super__.constructor.apply(this, arguments);
  }

  Fill.prototype.paint = function(ctx) {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.fill();
    return ctx.restore();
  };

  return Fill;

})(Graphic.PaintOp);

Graphic.Stroke = (function(superClass) {
  extend(Stroke, superClass);

  function Stroke() {
    return Stroke.__super__.constructor.apply(this, arguments);
  }

  Stroke.prototype.paint = function(ctx) {
    if (this.lineWidth <= 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.lineWidth;
    ctx.stroke();
    return ctx.restore();
  };

  return Stroke;

})(Graphic.PaintOp);

Graphic.PathComponent = (function(superClass) {
  extend(PathComponent, superClass);

  function PathComponent() {
    return PathComponent.__super__.constructor.apply(this, arguments);
  }

  return PathComponent;

})(Graphic.Component);

Graphic.TextComponent = (function(superClass) {
  extend(TextComponent, superClass);

  function TextComponent() {
    return TextComponent.__super__.constructor.apply(this, arguments);
  }

  return TextComponent;

})(Graphic.Component);

dummyCanvasCtx = null;

getDummyCanvasCtx = function() {
  var dummyCanvas;
  if (dummyCanvasCtx) {
    return dummyCanvasCtx;
  }
  dummyCanvas = document.createElement("canvas");
  return dummyCanvasCtx = dummyCanvas.getContext("2d");
};


},{"underscore":"underscore"}],17:[function(require,module,exports){
var Attribute, CompiledExpression, Dataflow, Evaluator, Link, Model, Node, Util, _,
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

Util = require("../Util/Util");

Dataflow = require("../Dataflow/Dataflow");

Evaluator = require("../Evaluator/Evaluator");

Node = require("./Node");

Link = require("./Link");

Model = require("./Model");

module.exports = Attribute = Node.createVariant({
  constructor: function() {
    Node.constructor.apply(this, arguments);
    return this.value = Dataflow.cell(this._value.bind(this));
  },
  _value: function() {
    var error, referenceValues;
    if (this.isNumber()) {
      return parseFloat(this.exprString);
    }
    if (this._isDirty()) {
      this._updateCompiledExpression();
    }
    referenceValues = _.mapObject(this.references(), function(referenceAttribute) {
      return referenceAttribute.value();
    });
    try {
      return this.__compiledExpression.evaluate(referenceValues);
    } catch (_error) {
      error = _error;
      if (error instanceof Dataflow.UnresolvedSpreadError) {
        throw error;
      } else {
        return error;
      }
    }
  },
  _isDirty: function() {
    if (!this.hasOwnProperty("__compiledExpression")) {
      return true;
    }
    if (this.__compiledExpression.exprString !== this.exprString) {
      return true;
    }
    return false;
  },
  _updateCompiledExpression: function() {
    var compiledExpression, ref, ref1;
    compiledExpression = new CompiledExpression(this);
    if (compiledExpression.isSyntaxError) {
      compiledExpression.fn = (ref = (ref1 = this.__compiledExpression) != null ? ref1.fn : void 0) != null ? ref : function() {
        return new Error("Syntax error");
      };
    }
    return this.__compiledExpression = compiledExpression;
  },
  setExpression: function(exprString, references) {
    var attribute, i, key, len, ref, referenceLink, results;
    if (references == null) {
      references = {};
    }
    this.exprString = String(exprString);
    ref = this.childrenOfType(Model.ReferenceLink);
    for (i = 0, len = ref.length; i < len; i++) {
      referenceLink = ref[i];
      this.removeChild(referenceLink);
    }
    results = [];
    for (key in references) {
      if (!hasProp.call(references, key)) continue;
      attribute = references[key];
      referenceLink = Model.ReferenceLink.createVariant();
      referenceLink.key = key;
      referenceLink.setTarget(attribute);
      results.push(this.addChild(referenceLink));
    }
    return results;
  },
  references: function() {
    var attribute, i, key, len, ref, referenceLink, references;
    references = {};
    ref = this.childrenOfType(Model.ReferenceLink);
    for (i = 0, len = ref.length; i < len; i++) {
      referenceLink = ref[i];
      key = referenceLink.key;
      attribute = referenceLink.target();
      references[key] = attribute;
    }
    return references;
  },
  hasReferences: function() {
    return _.any(this.references(), function() {
      return true;
    });
  },
  isNumber: function() {
    return Util.isNumberString(this.exprString);
  },
  isTrivial: function() {
    return this.isNumber();
  },
  isNovel: function() {
    return this.hasOwnProperty("exprString");
  },
  dependencies: function() {
    var dependencies, recurse;
    dependencies = [];
    recurse = function(attribute) {
      var i, len, ref, referenceAttribute, results;
      ref = _.values(attribute.references());
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        referenceAttribute = ref[i];
        dependencies.push(referenceAttribute);
        results.push(recurse(referenceAttribute));
      }
      return results;
    };
    recurse(this);
    dependencies = _.unique(dependencies);
    return dependencies;
  },
  parentElement: function() {
    var result;
    result = this.parent();
    while (!result.isVariantOf(Model.Element)) {
      result = result.parent();
    }
    return result;
  }
});

CompiledExpression = (function() {
  function CompiledExpression(attribute1) {
    var compiled, error, value, wrapped;
    this.attribute = attribute1;
    this.exprString = this.attribute.exprString;
    this.referenceKeys = _.keys(this.attribute.references());
    if (this.exprString === "") {
      this._setSyntaxError();
      return;
    }
    if (Util.isNumberString(this.exprString)) {
      value = parseFloat(this.exprString);
      this._setConstant(value);
      return;
    }
    wrapped = this._wrapped();
    try {
      compiled = Evaluator.evaluate(wrapped);
    } catch (_error) {
      error = _error;
      this._setSyntaxError();
      return;
    }
    compiled = this._wrapFunctionInSpreadCheck(compiled);
    if (this.referenceKeys.length === 0) {
      try {
        value = compiled();
      } catch (_error) {
        error = _error;
        this._setConstant(error);
        return;
      }
      this._setConstant(value);
      return;
    }
    this._setFn(compiled);
  }

  CompiledExpression.prototype._setSyntaxError = function() {
    return this.isSyntaxError = true;
  };

  CompiledExpression.prototype._setConstant = function(value) {
    this.isConstant = true;
    return this.fn = function() {
      return value;
    };
  };

  CompiledExpression.prototype._setFn = function(fn) {
    return this.fn = fn;
  };

  CompiledExpression.prototype.evaluate = function(referenceValues) {
    return this.fn(referenceValues);
  };

  CompiledExpression.prototype._wrapped = function() {
    var i, len, ref, referenceKey, result;
    result = "'use strict';\n";
    result += "(function ($$$referenceValues) {\n";
    ref = this.referenceKeys;
    for (i = 0, len = ref.length; i < len; i++) {
      referenceKey = ref[i];
      result += "  var " + referenceKey + " = $$$referenceValues." + referenceKey + ";\n";
    }
    if (this.exprString.indexOf("return") === -1) {
      result += "  return " + this.exprString + ";\n";
    } else {
      result += "\n\n" + this.exprString + "\n\n";
    }
    result += "});";
    return result;
  };

  CompiledExpression.prototype._wrapFunctionInSpreadCheck = function(fn) {
    return (function(_this) {
      return function() {
        var result;
        result = fn.apply(null, arguments);
        if (result instanceof Dataflow.Spread) {
          result.origin = _this.attribute;
        }
        return result;
      };
    })(this);
  };

  return CompiledExpression;

})();


},{"../Dataflow/Dataflow":9,"../Evaluator/Evaluator":13,"../Util/Util":28,"./Link":20,"./Model":21,"./Node":22,"underscore":"underscore"}],18:[function(require,module,exports){
var Dataflow, Editor, Model, Storage, Util, _, queryString,
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

queryString = require("query-string");

Dataflow = require("../Dataflow/Dataflow");

Model = require("./Model");

Util = require("../Util/Util");

Storage = require("../Storage/Storage");

module.exports = Editor = (function() {
  function Editor() {
    this._setupSerializer();
    this._setupProject();
    this._setupRevision();
    this._parseQueryString();
  }

  Editor.prototype._setupProject = function() {
    this.loadFromLocalStorage();
    if (!this.project) {
      return this.createNewProject();
    }
  };

  Editor.prototype._setupSerializer = function() {
    var builtInObjects, name, object, ref;
    builtInObjects = [];
    ref = this._builtIn();
    for (name in ref) {
      if (!hasProp.call(ref, name)) continue;
      object = ref[name];
      if (_.isFunction(object)) {
        object = object.prototype;
      }
      Util.assignId(object, name);
      builtInObjects.push(object);
    }
    return this.serializer = new Storage.Serializer(builtInObjects);
  };

  Editor.prototype._parseQueryString = function() {
    var parsed;
    parsed = queryString.parse(location.search);
    if (parsed.load) {
      return this.loadFromURL(parsed.load);
    }
  };

  Editor.prototype._builtIn = function() {
    var builtIn;
    builtIn = _.clone(Model);
    builtIn["SpreadEnv"] = Dataflow.SpreadEnv;
    builtIn["Matrix"] = Util.Matrix;
    return builtIn;
  };

  Editor.prototype.version = "0.4.0";

  Editor.prototype.load = function(jsonString) {
    var json;
    json = JSON.parse(jsonString);
    if (json.type === "Apparatus" && json.version === this.version) {
      return this.project = this.serializer.dejsonify(json);
    }
  };

  Editor.prototype.save = function() {
    var json, jsonString;
    json = this.serializer.jsonify(this.project);
    json.type = "Apparatus";
    json.version = this.version;
    jsonString = JSON.stringify(json);
    return jsonString;
  };

  Editor.prototype.createNewProject = function() {
    return this.project = new Model.Project();
  };

  Editor.prototype.localStorageName = "apparatus";

  Editor.prototype.saveToLocalStorage = function() {
    var jsonString;
    jsonString = this.save();
    window.localStorage[this.localStorageName] = jsonString;
    return jsonString;
  };

  Editor.prototype.loadFromLocalStorage = function() {
    var jsonString;
    jsonString = window.localStorage[this.localStorageName];
    if (jsonString) {
      return this.load(jsonString);
    }
  };

  Editor.prototype.resetLocalStorage = function() {
    return delete window.localStorage[this.localStorageName];
  };

  Editor.prototype.saveToFile = function() {
    var fileName, jsonString;
    jsonString = this.save();
    fileName = this.project.editingElement.label + ".json";
    return Storage.saveFile(jsonString, fileName, "application/json;charset=utf-8");
  };

  Editor.prototype.loadFromFile = function() {
    return Storage.loadFile((function(_this) {
      return function(jsonString) {
        return _this.load(jsonString);
      };
    })(this));
  };

  Editor.prototype.loadFromURL = function(url) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.onreadystatechange = (function(_this) {
      return function() {
        var jsonString;
        if (xhr.readyState !== 4) {
          return;
        }
        if (xhr.status !== 200) {
          return;
        }
        jsonString = xhr.responseText;
        _this.load(jsonString);
        _this.checkpoint();
        return Apparatus.refresh();
      };
    })(this);
    xhr.open("GET", url, true);
    return xhr.send();
  };

  Editor.prototype._setupRevision = function() {
    this.current = this.save();
    this.undoStack = [];
    this.redoStack = [];
    return this.maxUndoStackSize = 100;
  };

  Editor.prototype.checkpoint = function() {
    var jsonString;
    jsonString = this.saveToLocalStorage();
    if (this.current === jsonString) {
      return;
    }
    this.undoStack.push(this.current);
    if (this.undoStack.length > this.maxUndoStackSize) {
      this.undoStack.shift();
    }
    this.redoStack = [];
    return this.current = jsonString;
  };

  Editor.prototype.undo = function() {
    if (!this.isUndoable()) {
      return;
    }
    this.redoStack.push(this.current);
    this.current = this.undoStack.pop();
    this.load(this.current);
    return this.saveToLocalStorage();
  };

  Editor.prototype.redo = function() {
    if (!this.isRedoable()) {
      return;
    }
    this.undoStack.push(this.current);
    this.current = this.redoStack.pop();
    this.load(this.current);
    return this.saveToLocalStorage();
  };

  Editor.prototype.isUndoable = function() {
    return this.undoStack.length > 0;
  };

  Editor.prototype.isRedoable = function() {
    return this.redoStack.length > 0;
  };

  return Editor;

})();


},{"../Dataflow/Dataflow":9,"../Storage/Storage":26,"../Util/Util":28,"./Model":21,"query-string":6,"underscore":"underscore"}],19:[function(require,module,exports){
var Dataflow, Element, Link, Model, Node, Util, _;

_ = require("underscore");

Node = require("./Node");

Link = require("./Link");

Model = require("./Model");

Dataflow = require("../Dataflow/Dataflow");

Util = require("../Util/Util");

module.exports = Element = Node.createVariant({
  constructor: function() {
    var i, len, prop, propsToCellify, results;
    Node.constructor.apply(this, arguments);
    this.expanded = false;
    propsToCellify = ["graphic", "contextMatrix", "accumulatedMatrix"];
    results = [];
    for (i = 0, len = propsToCellify.length; i < len; i++) {
      prop = propsToCellify[i];
      results.push(this[prop] = Dataflow.cell(this["_" + prop].bind(this)));
    }
    return results;
  },
  viewMatrix: new Util.Matrix(100, 0, 0, 100, 0, 0),
  childElements: function() {
    return this.childrenOfType(Element);
  },
  variables: function() {
    return this.childrenOfType(Model.Variable);
  },
  components: function() {
    return this.childrenOfType(Model.Component);
  },
  attributes: function() {
    var attribute, component, i, j, k, len, len1, len2, ref, ref1, ref2, result, variable;
    result = [];
    ref = this.variables();
    for (i = 0, len = ref.length; i < len; i++) {
      variable = ref[i];
      result.push(variable);
    }
    ref1 = this.components();
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      component = ref1[j];
      ref2 = component.attributes();
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        attribute = ref2[k];
        result.push(attribute);
      }
    }
    return result;
  },
  addVariable: function() {
    var variable;
    variable = Model.Variable.createVariant();
    variable.setExpression("0.00");
    this.addChild(variable);
    return variable;
  },
  controlledAttributes: function() {
    var attribute, controlledAttributeLink, controlledAttributes, i, len, ref;
    controlledAttributes = [];
    ref = this.childrenOfType(Model.ControlledAttributeLink);
    for (i = 0, len = ref.length; i < len; i++) {
      controlledAttributeLink = ref[i];
      attribute = controlledAttributeLink.target();
      controlledAttributes.push(attribute);
    }
    return controlledAttributes;
  },
  addControlledAttribute: function(attributeToAdd) {
    var controlledAttributeLink;
    controlledAttributeLink = Model.ControlledAttributeLink.createVariant();
    controlledAttributeLink.setTarget(attributeToAdd);
    return this.addChild(controlledAttributeLink);
  },
  removeControlledAttribute: function(attributeToRemove) {
    var attribute, controlledAttributeLink, i, len, ref, results;
    ref = this.childrenOfType(Model.ControlledAttributeLink);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      controlledAttributeLink = ref[i];
      attribute = controlledAttributeLink.target();
      if (attribute === attributeToRemove) {
        results.push(this.removeChild(controlledAttributeLink));
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  isController: function() {
    return this.controlledAttributes().length > 0;
  },
  implicitlyControlledAttributes: function() {
    return this.allDependencies(this.controlledAttributes());
  },
  controllableAttributes: function() {
    return _.unique(this._controllableAttributes());
  },
  _controllableAttributes: function() {
    var attribute, component, i, j, len, len1, ref, ref1, result;
    result = [];
    ref = this.components();
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      if (component.controllableAttributes == null) {
        continue;
      }
      ref1 = component.controllableAttributes();
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        attribute = ref1[j];
        result.push(attribute);
        result.push.apply(result, attribute.dependencies());
      }
    }
    if (this.parent()) {
      result.push.apply(result, this.parent()._controllableAttributes());
    }
    return result;
  },
  attributesToChange: function() {
    var attributesToChange;
    attributesToChange = this.implicitlyControlledAttributes();
    if (attributesToChange.length === 0) {
      attributesToChange = this.defaultAttributesToChange();
    }
    attributesToChange = this.onlyNumbers(attributesToChange);
    return attributesToChange;
  },
  defaultAttributesToChange: function() {
    var component, i, len, ref, result;
    result = [];
    ref = this.components();
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      if (component.defaultAttributesToChange == null) {
        continue;
      }
      result.push.apply(result, component.defaultAttributesToChange());
    }
    return result;
  },
  controlPoints: function() {
    var attributesToChange, component, controlPoint, controlPoints, i, j, len, len1, ref, result;
    result = [];
    ref = this.components();
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      if (component.controlPoints == null) {
        continue;
      }
      controlPoints = component.controlPoints();
      for (j = 0, len1 = controlPoints.length; j < len1; j++) {
        controlPoint = controlPoints[j];
        attributesToChange = controlPoint.attributesToChange;
        attributesToChange = this.allDependencies(attributesToChange);
        attributesToChange = this.onlyNumbers(attributesToChange);
        controlPoint.attributesToChange = attributesToChange;
      }
      result.push.apply(result, controlPoints);
    }
    return result;
  },
  allDependencies: function(attributes) {
    var attribute, i, len, result;
    result = [];
    for (i = 0, len = attributes.length; i < len; i++) {
      attribute = attributes[i];
      result.push(attribute);
      result.push.apply(result, attribute.dependencies());
    }
    return _.unique(result);
  },
  onlyNumbers: function(attributes) {
    return _.filter(attributes, function(attribute) {
      return attribute.isNumber();
    });
  },
  matrix: function() {
    var i, len, matrix, ref, transform;
    matrix = new Util.Matrix();
    ref = this.childrenOfType(Model.Transform);
    for (i = 0, len = ref.length; i < len; i++) {
      transform = ref[i];
      matrix = matrix.compose(transform.matrix());
    }
    return matrix;
  },
  _contextMatrix: function() {
    var parent;
    parent = this.parent();
    if (parent && parent.isVariantOf(Element)) {
      return parent.accumulatedMatrix();
    } else {
      return new Util.Matrix();
    }
  },
  _accumulatedMatrix: function() {
    return this.contextMatrix().compose(this.matrix());
  },
  _graphic: function() {
    var graphic, spreadEnv;
    graphic = new this.graphicClass();
    spreadEnv = Dataflow.currentSpreadEnv();
    graphic.particularElement = new Model.ParticularElement(this, spreadEnv);
    graphic.matrix = this.accumulatedMatrix();
    graphic.components = _.map(this.components(), function(component) {
      return component.graphic();
    });
    graphic.childGraphics = _.flatten(_.map(this.childElements(), function(element) {
      return element.allGraphics();
    }));
    return graphic;
  },
  allGraphics: function() {
    var result;
    if (this._isBeyondMaxDepth()) {
      return [];
    }
    result = this.graphic.asSpread();
    if (result instanceof Dataflow.Spread) {
      return result.flattenToArray();
    } else {
      return [result];
    }
  },
  _isBeyondMaxDepth: function() {
    return this.depth() > 20;
  }
});


},{"../Dataflow/Dataflow":9,"../Util/Util":28,"./Link":20,"./Model":21,"./Node":22,"underscore":"underscore"}],20:[function(require,module,exports){
var Link, Node;

Node = require("./Node");

module.exports = Link = Node.createVariant({
  setTarget: function(_target) {
    this._target = _target;
  },
  target: function() {
    var cursor, head, headStack, i, len, nextCursor;
    headStack = [];
    cursor = this;
    while (!cursor.hasOwnProperty("_target")) {
      headStack.unshift(cursor.head());
      cursor = cursor.master();
    }
    cursor = this._target;
    for (i = 0, len = headStack.length; i < len; i++) {
      head = headStack[i];
      nextCursor = cursor.findVariantWithHead(head);
      if (nextCursor == null) {
        break;
      }
      cursor = nextCursor;
    }
    return cursor;
  }
});


},{"./Node":22}],21:[function(require,module,exports){
var Dataflow, Graphic, Model, Util, _, createAnchor, createAttribute;

_ = require("underscore");

Dataflow = require("../Dataflow/Dataflow");

Graphic = require("../Graphic/Graphic");

Util = require("../Util/Util");

module.exports = Model = {};

Model.Project = require("./Project");

Model.ParticularElement = require("./ParticularElement");

Model.Node = require("./Node");

Model.Link = require("./Link");

Model.Attribute = require("./Attribute");

Model.Element = require("./Element");

Model.Editor = require("./Editor");

Model.Variable = Model.Attribute.createVariant();

Model.ControlledAttributeLink = Model.Link.createVariant();

Model.ReferenceLink = Model.Link.createVariant();

createAttribute = function(label, name, exprString) {
  var attribute;
  attribute = Model.Attribute.createVariant({
    label: label,
    name: name
  });
  attribute.setExpression(exprString);
  return attribute;
};

Model.Component = Model.Node.createVariant({
  attributes: function() {
    return this.childrenOfType(Model.Attribute);
  },
  getAttributesByName: function() {
    return _.indexBy(this.attributes(), "name");
  },
  getAttributesValuesByName: function() {
    var attribute, i, len, name, ref, result, value;
    result = {};
    ref = this.attributes();
    for (i = 0, len = ref.length; i < len; i++) {
      attribute = ref[i];
      name = attribute.name;
      value = attribute.value();
      result[name] = value;
    }
    return result;
  },
  graphicClass: Graphic.Component,
  graphic: function() {
    var graphic;
    graphic = new this.graphicClass();
    _.extend(graphic, this.getAttributesValuesByName());
    return graphic;
  }
});

Model.Transform = Model.Component.createVariant({
  label: "Transform",
  matrix: function() {
    var ref, rotate, sx, sy, x, y;
    ref = this.getAttributesValuesByName(), x = ref.x, y = ref.y, sx = ref.sx, sy = ref.sy, rotate = ref.rotate;
    return Util.Matrix.naturalConstruct(x, y, sx, sy, rotate);
  },
  defaultAttributesToChange: function() {
    var ref, x, y;
    ref = this.getAttributesByName(), x = ref.x, y = ref.y;
    return [x, y];
  },
  controllableAttributes: function() {
    var ref, rotate, sx, sy, x, y;
    ref = this.getAttributesByName(), x = ref.x, y = ref.y, sx = ref.sx, sy = ref.sy, rotate = ref.rotate;
    return [x, y, sx, sy, rotate];
  },
  controlPoints: function() {
    var ref, sx, sy, x, y;
    ref = this.getAttributesByName(), x = ref.x, y = ref.y, sx = ref.sx, sy = ref.sy;
    return [
      {
        point: [0, 0],
        attributesToChange: [x, y],
        filled: true
      }, {
        point: [1, 0],
        attributesToChange: [sx],
        filled: false
      }, {
        point: [0, 1],
        attributesToChange: [sy],
        filled: false
      }
    ];
  }
});

Model.Transform.addChildren([createAttribute("X", "x", "0.00"), createAttribute("Y", "y", "0.00"), createAttribute("Scale X", "sx", "1.00"), createAttribute("Scale Y", "sy", "1.00"), createAttribute("Rotate", "rotate", "0.00")]);

Model.Fill = Model.Component.createVariant({
  label: "Fill",
  graphicClass: Graphic.Fill
});

Model.Fill.addChildren([createAttribute("Fill Color", "color", "rgba(0.93, 0.93, 0.93, 1.00)")]);

Model.Stroke = Model.Component.createVariant({
  label: "Stroke",
  graphicClass: Graphic.Stroke
});

Model.Stroke.addChildren([createAttribute("Stroke Color", "color", "rgba(0.60, 0.60, 0.60, 1.00)"), createAttribute("Line Width", "lineWidth", "1")]);

Model.Shape = Model.Element.createVariant();

Model.Shape.addChildren([Model.Transform.createVariant()]);

Model.Group = Model.Shape.createVariant({
  label: "Group",
  graphicClass: Graphic.Group
});

Model.Anchor = Model.Shape.createVariant({
  label: "Anchor",
  graphicClass: Graphic.Anchor
});

createAnchor = function(x, y) {
  var anchor, attributes, transform;
  anchor = Model.Anchor.createVariant();
  transform = anchor.childOfType(Model.Transform);
  attributes = transform.getAttributesByName();
  attributes.x.setExpression(x);
  attributes.y.setExpression(y);
  return anchor;
};

Model.PathComponent = Model.Component.createVariant({
  label: "Path",
  graphicClass: Graphic.PathComponent
});

Model.PathComponent.addChildren([createAttribute("Close Path", "closed", "true")]);

Model.Path = Model.Shape.createVariant({
  label: "Path",
  graphicClass: Graphic.Path
});

Model.Path.addChildren([Model.PathComponent.createVariant(), Model.Fill.createVariant(), Model.Stroke.createVariant()]);

Model.Circle = Model.Path.createVariant({
  label: "Circle",
  graphicClass: Graphic.Circle
});

Model.Rectangle = Model.Path.createVariant({
  label: "Rectangle"
});

Model.Rectangle.addChildren([createAnchor("0.00", "0.00"), createAnchor("0.00", "1.00"), createAnchor("1.00", "1.00"), createAnchor("1.00", "0.00")]);

Model.TextComponent = Model.Component.createVariant({
  label: "Text",
  graphicClass: Graphic.TextComponent
});

Model.TextComponent.addChildren([createAttribute("Text", "text", '"Text"'), createAttribute("Font", "fontFamily", '"Lucida Grande"'), createAttribute("Color", "color", "rgba(0.20, 0.20, 0.20, 1.00)"), createAttribute("Align", "textAlign", '"start"'), createAttribute("Baseline", "textBaseline", '"alphabetic"')]);

Model.Text = Model.Shape.createVariant({
  label: "Text",
  graphicClass: Graphic.Text
});

Model.Text.addChildren([Model.TextComponent.createVariant()]);


},{"../Dataflow/Dataflow":9,"../Graphic/Graphic":16,"../Util/Util":28,"./Attribute":17,"./Editor":18,"./Element":19,"./Link":20,"./Node":22,"./ParticularElement":23,"./Project":24,"underscore":"underscore"}],22:[function(require,module,exports){

/*

 * Introduction

The *node* is the *foundational abstraction* for managing the *scene graph* of
diagrams as well as the *inheritance hierarchy*.

The scene graph is managed through parent and children relationships. This is
very much like the DOM: every node can have 0 or 1 parent and the `addChild`
and `removeChild` methods ensure that all the parent/children pointers point
at the right thing.

Nodes can have properties in addition to children. These are managed simply as
javascript properties on the node objects.

Inheritance is handled a little differently. To reduce confusion, we use a
different nomenclature than class-instance or prototype-??. We call a node a
*master* and say that it can have *variants*. You can create a new variant
simply by calling the `createVariant` method.

The master-variant relationship is similar to the prototype relationship.
Indeed we use javascript's built-in prototype tree, so if A is the master of
B, then B.__proto__ == A. Thus properties inherit as in prototypal inheritance.

Children, however, inherit a little differently. Specifically, the entire
scene graph *structure* is also inherited.

So when you create a variant of a node, you also implicitly create
corresponding variants of each of the node's children and so on recursively.
That is, you create a deep clone of the node in such a way that every created
node has as its master the analogous node in the original tree. So if I have a
node A with children B and C and I create a variant of A called A', then A'
will automatically have as its children B' and C' which are variants of B and
C respectively.

Additionally, every variant node also has a pointer to its *head*. The head is
the root of the cloned tree. So if I have Node A with child Node B and I
create a variant of A to make A' with child B', then both A' and B' will have
as their head A'. We keep track of this in order to find *analogous* nodes
from one tree to another.


 * Overriding

In addition to a variant overriding properties of its master, as in normal
prototypal inheritance, a variant can also override the children structure of
its master. That is, you can add and remove children from the variant. These
changes *will not* propagate back up to the master. However, changes made to a
master (adding and removing children) *will* propagate down to its variants.


 * Lazy Implementation

We use a lazy implementation in order to support infinite recursion. An
example of recursion would be Node A has as a child Node A' which is a clone
of A. You can follow the children down as far as you want to go (by calling
Node.children() recursively), but the system won't crash by trying to create
an infinite data structure.

We achieve this with a "thunk" strategy. When Nodes are initially created they
are "eggs". It is only when they are asked about their children that they
"hatch" and instantiate their children. (And their children are instantiated
as eggs, of course.)

We want consumers of this API to never know that the implementation is lazy.
It should appear that you can just access Node.children(), etc. and always get
back the correct Node(s), as if we had infinite memory. Thus we need to hatch
the appropriate Node(s) when certain calls are made--basically whenever we go
"down" the tree.
 */
var Node, _;

_ = require("underscore");

module.exports = Node = {
  constructor: function() {
    this._master = null;
    this._variants = [];
    this._parent = null;
    this._children = [];
    this._head = null;
    return this._isHatched = false;
  },
  master: function() {
    return this._master;
  },
  variants: function() {
    var i, len, parent, parentVariant, parentVariants;
    if (parent = this.parent()) {
      parentVariants = parent.variants();
      for (i = 0, len = parentVariants.length; i < len; i++) {
        parentVariant = parentVariants[i];
        parentVariant._hatch();
      }
    }
    return this._variants;
  },
  parent: function() {
    return this._parent;
  },
  children: function() {
    this._hatch();
    return this._children;
  },
  head: function() {
    return this._head;
  },
  _hatch: function() {
    var i, len, masterChild, myChild, ref, ref1, results;
    if (this._isHatched) {
      return;
    }
    if ((ref = this._master) != null) {
      ref._hatch();
    }
    this._isHatched = true;
    if (this._master != null) {
      ref1 = this._master.children();
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        masterChild = ref1[i];
        myChild = masterChild._createVariantWithHead(this._head);
        results.push(this.addChild(myChild));
      }
      return results;
    }
  },
  addChild: function(childToAdd, insertionIndex) {
    var correspondingChild, existingParent, head, i, len, ref, results, variant;
    if (insertionIndex == null) {
      insertionIndex = Infinity;
    }
    this._hatch();
    existingParent = childToAdd.parent();
    if (existingParent) {
      existingParent.removeChild(childToAdd);
    }
    this._children.splice(insertionIndex, 0, childToAdd);
    childToAdd._parent = this;
    ref = this._variants;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      variant = ref[i];
      if (!variant._isHatched) {
        continue;
      }
      head = variant.head();
      correspondingChild = childToAdd.findVariantWithHead(head);
      if (!correspondingChild) {
        correspondingChild = childToAdd._createVariantWithHead(head);
      }
      results.push(variant.addChild(correspondingChild, insertionIndex));
    }
    return results;
  },
  removeChild: function(childToRemove) {
    var correspondingChild, head, i, insertionIndex, len, ref, results, variant;
    this._hatch();
    insertionIndex = this._children.indexOf(childToRemove);
    if (insertionIndex === -1) {
      throw "Cannot remove a child that doesn't exist";
    }
    this._children.splice(insertionIndex, 1);
    childToRemove._parent = null;
    ref = this._variants;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      variant = ref[i];
      if (!variant._isHatched) {
        continue;
      }
      head = variant.head();
      correspondingChild = childToRemove.findVariantWithHead(head);
      if ((correspondingChild != null ? correspondingChild.parent() : void 0) === variant) {
        results.push(variant.removeChild(correspondingChild));
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  _createVariantWithHead: function(head, spec) {
    var variant;
    if (head == null) {
      head = null;
    }
    variant = Object.create(this);
    if (spec != null) {
      _.extend(variant, spec);
    }
    variant.constructor();
    if (head == null) {
      head = variant;
    }
    variant._head = head;
    variant._master = this;
    this._variants.push(variant);
    return variant;
  },
  createVariant: function(spec) {
    return this._createVariantWithHead(null, spec);
  },
  findVariantWithHead: function(head) {
    return _.find(this.variants(), function(variant) {
      return variant.head() === head;
    });
  },
  isVariantOf: function(grandMaster) {
    return grandMaster === this || grandMaster.isPrototypeOf(this);
  },
  isAncestorOf: function(grandChild) {
    var parent;
    if (this === grandChild) {
      return true;
    }
    if (parent = grandChild.parent()) {
      return this.isAncestorOf(parent);
    }
    return false;
  },
  addChildren: function(children) {
    var child, i, len, results;
    results = [];
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      results.push(this.addChild(child));
    }
    return results;
  },
  childrenOfType: function(type) {
    return _.filter(this.children(), function(child) {
      return child.isVariantOf(type);
    });
  },
  childOfType: function(type) {
    return _.find(this.children(), function(child) {
      return child.isVariantOf(type);
    });
  },
  depth: function() {
    if (!this.parent()) {
      return 0;
    }
    return 1 + this.parent().depth();
  },
  replaceChildWith: function(childToReplace, replacementNode) {
    var index;
    index = this.children().indexOf(childToReplace);
    this.removeChild(childToReplace);
    return this.addChild(replacementNode, index);
  }
};

Node.constructor();


},{"underscore":"underscore"}],23:[function(require,module,exports){
var Dataflow, ParticularElement;

Dataflow = require("../Dataflow/Dataflow");

module.exports = ParticularElement = (function() {
  function ParticularElement(element, spreadEnv) {
    this.element = element;
    this.spreadEnv = spreadEnv;
    if (this.spreadEnv == null) {
      this.spreadEnv = Dataflow.SpreadEnv.empty;
    }
  }

  ParticularElement.prototype.isEqualTo = function(particularElement) {
    return this.element === particularElement.element && this.spreadEnv.isEqualTo(particularElement.spreadEnv);
  };

  ParticularElement.prototype.isAncestorOf = function(particularElement) {
    return this.element.isAncestorOf(particularElement.element) && this.spreadEnv.contains(particularElement.spreadEnv);
  };

  ParticularElement.prototype.accumulatedMatrix = function() {
    var accumulatedMatrix;
    accumulatedMatrix = this.element.accumulatedMatrix.asSpread();
    accumulatedMatrix = this.spreadEnv.resolveWithDefault(accumulatedMatrix);
    return accumulatedMatrix;
  };

  ParticularElement.prototype.contextMatrix = function() {
    var contextMatrix;
    contextMatrix = this.element.contextMatrix.asSpread();
    contextMatrix = this.spreadEnv.resolveWithDefault(contextMatrix);
    return contextMatrix;
  };

  return ParticularElement;

})();


},{"../Dataflow/Dataflow":9}],24:[function(require,module,exports){
var Dataflow, Model, Project, _;

_ = require("underscore");

Model = require("./Model");

Dataflow = require("../Dataflow/Dataflow");

module.exports = Project = (function() {
  function Project() {
    var i, initialElement, len, prop, propsToMemoize;
    initialElement = this.createNewElement();
    this.editingElement = initialElement;
    this.selectedParticularElement = null;
    this.createPanelElements = [Model.Rectangle, Model.Circle, Model.Text, initialElement];
    propsToMemoize = ["controlledAttributes", "implicitlyControlledAttributes", "controllableAttributes"];
    for (i = 0, len = propsToMemoize.length; i < len; i++) {
      prop = propsToMemoize[i];
      this[prop] = Dataflow.memoize(this[prop].bind(this));
    }
  }

  Project.prototype.setEditing = function(element) {
    this.editingElement = element;
    return this.selectedParticularElement = null;
  };

  Project.prototype.select = function(particularElement) {
    if (!particularElement) {
      this.selectedParticularElement = null;
      return;
    }
    this.selectedParticularElement = particularElement;
    return this._expandToElement(particularElement.element);
  };

  Project.prototype._expandToElement = function(element) {
    var results;
    results = [];
    while (element = element.parent()) {
      results.push(element.expanded = true);
    }
    return results;
  };

  Project.prototype.createNewElement = function() {
    var element;
    element = Model.Group.createVariant();
    element.expanded = true;
    return element;
  };

  Project.prototype.removeSelectedElement = function() {
    var parent, selectedElement;
    if (!this.selectedParticularElement) {
      return;
    }
    selectedElement = this.selectedParticularElement.element;
    parent = selectedElement.parent();
    if (!parent) {
      return;
    }
    parent.removeChild(selectedElement);
    return this.select(null);
  };

  Project.prototype.groupSelectedElement = function() {
    var group, parent, selectedElement;
    if (!this.selectedParticularElement) {
      return;
    }
    selectedElement = this.selectedParticularElement.element;
    parent = selectedElement.parent();
    if (!parent) {
      return;
    }
    group = Model.Group.createVariant();
    group.expanded = true;
    parent.replaceChildWith(selectedElement, group);
    group.addChild(selectedElement);
    return this.select(new Model.ParticularElement(group));
  };

  Project.prototype.duplicateSelectedElement = function() {
    var firstClone, index, parent, secondClone, selectedElement;
    if (!this.selectedParticularElement) {
      return;
    }
    selectedElement = this.selectedParticularElement.element;
    parent = selectedElement.parent();
    if (!parent) {
      return;
    }
    firstClone = selectedElement.createVariant();
    secondClone = selectedElement.createVariant();
    parent.replaceChildWith(selectedElement, firstClone);
    index = parent.children().indexOf(firstClone);
    parent.addChild(secondClone, index + 1);
    return this.select(new Model.ParticularElement(secondClone));
  };

  Project.prototype.createSymbolFromSelectedElement = function() {
    var index, master, parent, selectedElement, variant;
    if (!this.selectedParticularElement) {
      return;
    }
    selectedElement = this.selectedParticularElement.element;
    parent = selectedElement.parent();
    if (!parent) {
      return;
    }
    master = selectedElement;
    variant = selectedElement.createVariant();
    parent.replaceChildWith(selectedElement, variant);
    this.select(new Model.ParticularElement(variant));
    index = this.createPanelElements.indexOf(this.editingElement);
    return this.createPanelElements.splice(index, 0, master);
  };

  Project.prototype.controlledAttributes = function() {
    var ref, ref1;
    return (ref = (ref1 = this.selectedParticularElement) != null ? ref1.element.controlledAttributes() : void 0) != null ? ref : [];
  };

  Project.prototype.implicitlyControlledAttributes = function() {
    var ref, ref1;
    return (ref = (ref1 = this.selectedParticularElement) != null ? ref1.element.implicitlyControlledAttributes() : void 0) != null ? ref : [];
  };

  Project.prototype.controllableAttributes = function() {
    var ref, ref1;
    return (ref = (ref1 = this.selectedParticularElement) != null ? ref1.element.controllableAttributes() : void 0) != null ? ref : [];
  };

  return Project;

})();


},{"../Dataflow/Dataflow":9,"./Model":21,"underscore":"underscore"}],25:[function(require,module,exports){
var Serializer, Util, _,
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

Util = require("../Util/Util");

module.exports = Serializer = (function() {
  function Serializer(builtInObjects) {
    var i, id, len, object;
    this.builtIn = {};
    for (i = 0, len = builtInObjects.length; i < len; i++) {
      object = builtInObjects[i];
      id = Util.getId(object);
      this.builtIn[id] = object;
    }
  }

  Serializer.prototype.shouldSerializeProperty = function(key, value) {
    if (_.isFunction(value)) {
      return false;
    }
    if (key.slice(0, 2) === "__") {
      return false;
    }
    return true;
  };

  Serializer.prototype.jsonify = function(rootValue) {
    var jsonifyArray, jsonifyObject, jsonifyValue, objects, referenceTo, root;
    objects = {};
    jsonifyValue = (function(_this) {
      return function(value) {
        if (_.isArray(value)) {
          return jsonifyArray(value);
        } else if (_.isObject(value)) {
          return referenceTo(value);
        } else {
          return value;
        }
      };
    })(this);
    jsonifyArray = (function(_this) {
      return function(array) {
        var childValue;
        return (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = array.length; i < len; i++) {
            childValue = array[i];
            results.push(jsonifyValue(childValue));
          }
          return results;
        })();
      };
    })(this);
    referenceTo = (function(_this) {
      return function(object) {
        var id;
        id = Util.getId(object);
        if (!_this.builtIn[id] && !objects[id]) {
          objects[id] = "PROCESSING";
          objects[id] = jsonifyObject(object);
        }
        return {
          __ref: id
        };
      };
    })(this);
    jsonifyObject = (function(_this) {
      return function(object) {
        var key, proto, result, value;
        result = {};
        for (key in object) {
          if (!hasProp.call(object, key)) continue;
          value = object[key];
          if (_this.shouldSerializeProperty(key, value)) {
            result[key] = jsonifyValue(value);
          }
        }
        proto = Object.getPrototypeOf(object);
        if (proto !== Object.prototype) {
          result.__proto = jsonifyValue(proto);
        }
        return result;
      };
    })(this);
    root = jsonifyValue(rootValue);
    return {
      objects: objects,
      root: root
    };
  };

  Serializer.prototype.dejsonify = function(arg) {
    var assignKeyValues, constructObject, constructedObjects, deref, id, object, objects, root;
    objects = arg.objects, root = arg.root;
    constructedObjects = {};
    constructObject = (function(_this) {
      return function(id) {
        var constructedObject, objectJson, proto, protoRef;
        if (constructedObjects[id] != null) {
          return constructedObjects[id];
        }
        if (_this.builtIn[id] != null) {
          return _this.builtIn[id];
        }
        objectJson = objects[id];
        protoRef = objectJson.__proto;
        if (protoRef) {
          proto = constructObject(protoRef.__ref);
          constructedObject = Object.create(proto);
          if (typeof constructedObject.constructor === "function") {
            constructedObject.constructor();
          }
        } else {
          constructedObject = {};
        }
        return constructedObjects[id] = constructedObject;
      };
    })(this);
    for (id in objects) {
      if (!hasProp.call(objects, id)) continue;
      object = objects[id];
      constructObject(id);
    }
    assignKeyValues = (function(_this) {
      return function(id, spec) {
        var constructedObject, key, results, value;
        constructedObject = constructedObjects[id];
        results = [];
        for (key in spec) {
          if (!hasProp.call(spec, key)) continue;
          value = spec[key];
          if (key === "__proto") {
            continue;
          }
          results.push(constructedObject[key] = deref(value));
        }
        return results;
      };
    })(this);
    deref = (function(_this) {
      return function(value) {
        var ref;
        if (_.isArray(value)) {
          return _.map(value, deref);
        }
        if (_.isObject(value)) {
          if (value.__ref != null) {
            id = value.__ref;
            return (ref = _this.builtIn[id]) != null ? ref : constructedObjects[id];
          } else {
            return _.mapObject(value, deref);
          }
        } else {
          return value;
        }
      };
    })(this);
    for (id in objects) {
      if (!hasProp.call(objects, id)) continue;
      object = objects[id];
      assignKeyValues(id, object);
    }
    return deref(root);
  };

  return Serializer;

})();


},{"../Util/Util":28,"underscore":"underscore"}],26:[function(require,module,exports){
var Storage;

module.exports = Storage = {};

Storage.Serializer = require("./Serializer");

Storage.saveFile = function(text, name, type) {
  var dummyLink, file;
  dummyLink = document.createElement("a");
  file = new Blob([text], {
    type: type
  });
  dummyLink.href = URL.createObjectURL(file);
  dummyLink.download = name;
  return dummyLink.click();
};

Storage.loadFile = function(callback) {
  var dummyInput;
  dummyInput = document.createElement("input");
  dummyInput.setAttribute("type", "file");
  dummyInput.addEventListener("change", function(changeEvent) {
    var file, files, reader;
    files = dummyInput.files;
    file = files[0];
    if (!file) {
      return;
    }
    reader = new FileReader();
    reader.onload = function() {
      return callback(reader.result);
    };
    return reader.readAsText(file);
  });
  return dummyInput.click();
};


},{"./Serializer":25}],27:[function(require,module,exports){
var Matrix;

module.exports = Matrix = (function() {
  function Matrix(a1, b1, c1, d1, e1, f1) {
    this.a = a1 != null ? a1 : 1;
    this.b = b1 != null ? b1 : 0;
    this.c = c1 != null ? c1 : 0;
    this.d = d1 != null ? d1 : 1;
    this.e = e1 != null ? e1 : 0;
    this.f = f1 != null ? f1 : 0;
  }

  Matrix.prototype.translate = function(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  };

  Matrix.prototype.scale = function(x, y) {
    return this.transform(x, 0, 0, y, 0, 0);
  };

  Matrix.prototype.rotate = function(angle) {
    var c, s;
    c = Math.cos(angle);
    s = Math.sin(angle);
    return this.transform(c, s, -s, c, 0, 0);
  };

  Matrix.prototype.transform = function(a, b, c, d, e, f) {
    return new Matrix(this.a * a + this.c * b, this.b * a + this.d * b, this.a * c + this.c * d, this.b * c + this.d * d, this.a * e + this.c * f + this.e, this.b * e + this.d * f + this.f);
  };

  Matrix.prototype.compose = function(m) {
    return this.transform(m.a, m.b, m.c, m.d, m.e, m.f);
  };

  Matrix.prototype.inverse = function() {
    var ad_minus_bc, bc_minus_ad;
    if (this._inverse != null) {
      return this._inverse;
    }
    ad_minus_bc = this.a * this.d - this.b * this.c;
    bc_minus_ad = this.b * this.c - this.a * this.d;
    return this._inverse = new Matrix(this.d / ad_minus_bc, this.b / bc_minus_ad, this.c / bc_minus_ad, this.a / ad_minus_bc, (this.d * this.e - this.c * this.f) / bc_minus_ad, (this.b * this.e - this.a * this.f) / ad_minus_bc);
  };

  Matrix.prototype.fromLocal = function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return [this.a * x + this.c * y + this.e, this.b * x + this.d * y + this.f];
  };

  Matrix.prototype.toLocal = function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return this.inverse().fromLocal([x, y]);
  };

  Matrix.prototype.origin = function() {
    return [this.e, this.f];
  };

  Matrix.prototype.toSVG = function() {
    return "matrix(" + (this.m.join(" ")) + ")";
  };

  Matrix.prototype.canvasSetTransform = function(ctx) {
    return ctx.setTransform(this.a, this.b, this.c, this.d, this.e, this.f);
  };

  Matrix.prototype.canvasTransform = function(ctx) {
    return ctx.transform(this.a, this.b, this.c, this.d, this.e, this.f);
  };

  return Matrix;

})();

Matrix.naturalConstruct = function(x, y, sx, sy, rotate) {
  var c, s;
  c = Math.cos(rotate);
  s = Math.sin(rotate);
  return new Matrix(c * sx, s * sx, -s * sy, c * sy, x, y);
};


},{}],28:[function(require,module,exports){
var Util, _, counter, numeric;

_ = require("underscore");

numeric = require("numeric");

module.exports = Util = {};

Util.Matrix = require("./Matrix");

Util.matches = function(el, selector) {
  var matchesSelector, ref, ref1;
  matchesSelector = (ref = (ref1 = Element.prototype.webkitMatchesSelector) != null ? ref1 : Element.prototype.mozMatchesSelector) != null ? ref : Element.prototype.oMatchesSelector;
  return matchesSelector.call(el, selector);
};

Util.closest = function(el, selector) {
  var fn, parent;
  if (!((el != null) && el.nodeType === Node.ELEMENT_NODE)) {
    return void 0;
  }
  if (_.isString(selector)) {
    fn = function(el) {
      return Util.matches(el, selector);
    };
  } else {
    fn = selector;
  }
  if (fn(el)) {
    return el;
  } else {
    parent = el.parentNode;
    return Util.closest(parent, fn);
  }
};

Util.mouseDownPreventDefault = function(e) {
  var el, i, len, ref, results;
  e.preventDefault();
  document.activeElement.blur();
  window.getSelection().removeAllRanges();
  document.body.focus();
  ref = document.querySelectorAll(".CodeMirror-focused");
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    el = ref[i];
    results.push(el.CodeMirror.getInputField().blur());
  }
  return results;
};

Util.textFocus = function() {
  var el, ref;
  if (el = document.querySelector(".CodeMirror-focused")) {
    return el.CodeMirror;
  }
  if ((ref = document.activeElement) != null ? ref.isContentEditable : void 0) {
    return document.activeElement;
  }
  return null;
};

Util.clearTextFocus = function() {
  var el, i, len, ref, results;
  document.activeElement.blur();
  window.getSelection().removeAllRanges();
  document.body.focus();
  ref = document.querySelectorAll(".CodeMirror-focused");
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    el = ref[i];
    results.push(el.CodeMirror.getInputField().blur());
  }
  return results;
};

Util.getId = function(object) {
  if (object.hasOwnProperty("id")) {
    return object.id;
  }
  return Util.assignId(object, Util.generateId());
};

Util.assignId = function(object, id) {
  return object.id = id;
};

counter = 0;

Util.generateId = function() {
  return "id" + Math.random().toString(36).substr(2, 6) + Date.now().toString(36) + (counter++).toString(36);
};

Util.quadrance = function(p1, p2) {
  var d;
  d = numeric['-'](p1, p2);
  return numeric.dot(d, d);
};

Util.solve = function(objective, startArgs) {
  var solution, uncmin;
  uncmin = numeric.uncmin(objective, startArgs);
  if (isNaN(uncmin.f)) {
    console.warn("NaN");
    return startArgs;
  } else {
    solution = uncmin.solution;
    return solution;
  }
};

Util.precision = function(x) {
  var decimalIndex;
  x = "" + x;
  decimalIndex = x.indexOf(".");
  if (decimalIndex === -1) {
    return 0;
  }
  return x.length - decimalIndex - 1;
};

Util.toPrecision = function(x, precision) {
  x = Util.roundToPrecision(x, precision);
  return x.toFixed(precision);
};

Util.toMaxPrecision = function(x, precision) {
  x = Util.toPrecision(x, precision);
  if (x.indexOf(".")) {
    x = x.replace(/\.?0+$/, "");
  }
  return x;
};

Util.roundToPrecision = function(x, precision) {
  var multiplier;
  multiplier = Math.pow(10, precision);
  x = Math.round(x * multiplier) / multiplier;
  return x;
};

Util.stringMatchIndices = function(haystack, needle) {
  var cursor, indices;
  indices = [];
  cursor = -1;
  while (true) {
    cursor = haystack.indexOf(needle, cursor + 1);
    if (cursor === -1) {
      break;
    }
    indices.push(cursor);
  }
  return indices;
};

Util.charToLineCh = function(string, char) {
  var lines, stringUpToChar;
  stringUpToChar = string.substr(0, char);
  lines = stringUpToChar.split("\n");
  return {
    line: lines.length - 1,
    ch: _.last(lines).length
  };
};

Util.isNumberString = function(string) {
  return /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(string);
};


},{"./Matrix":27,"numeric":5,"underscore":"underscore"}],29:[function(require,module,exports){
var Model, R, Util, _;

_ = require("underscore");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("AttributeRow", {
  propTypes: {
    attribute: Model.Attribute
  },
  contextTypes: {
    project: Model.Project,
    hoverManager: R.HoverManager
  },
  render: function() {
    var attribute;
    attribute = this.props.attribute;
    return R.div({
      className: R.cx({
        AttributeRow: true,
        isInherited: !attribute.isNovel(),
        isWrapped: this._isWrapped(),
        isGoingToChange: this._isGoingToChange()
      })
    }, R.div({
      className: "AttributeRowControl"
    }, R.div({
      className: R.cx({
        AttributeControl: true,
        Interactive: true,
        isControllable: this._isControllable(),
        isControlled: this._isControlled(),
        isImplicitlyControlled: this._isImplicityControlled()
      }),
      onClick: this._toggleControl
    })), R.div({
      className: "AttributeRowLabel"
    }, R.AttributeLabel({
      attribute: attribute
    })), R.div({
      className: "AttributeRowExpression"
    }, R.Expression({
      attribute: attribute
    })));
  },
  _isWrapped: function() {
    var attribute;
    attribute = this.props.attribute;
    return attribute.exprString.indexOf("\n") !== -1;
  },
  _isGoingToChange: function() {
    var attribute, hoverManager;
    attribute = this.props.attribute;
    hoverManager = this.context.hoverManager;
    return _.contains(hoverManager.attributesToChange, attribute);
  },
  _selectedElement: function() {
    var project, ref, selectedElement;
    project = this.context.project;
    return selectedElement = (ref = project.selectedParticularElement) != null ? ref.element : void 0;
  },
  _isControlled: function() {
    return _.contains(this.context.project.controlledAttributes(), this.props.attribute);
  },
  _isImplicityControlled: function() {
    return _.contains(this.context.project.implicitlyControlledAttributes(), this.props.attribute);
  },
  _isControllable: function() {
    return _.contains(this.context.project.controllableAttributes(), this.props.attribute);
  },
  _toggleControl: function() {
    var attribute, project, ref, selectedElement;
    attribute = this.props.attribute;
    project = this.context.project;
    selectedElement = (ref = project.selectedParticularElement) != null ? ref.element : void 0;
    if (!selectedElement) {
      return;
    }
    if (this._isControlled()) {
      return selectedElement.removeControlledAttribute(attribute);
    } else {
      return selectedElement.addControlledAttribute(attribute);
    }
  }
});

R.create("AttributeLabel", {
  propTypes: {
    attribute: Model.Attribute
  },
  contextTypes: {
    dragManager: R.DragManager,
    hoverManager: R.HoverManager
  },
  mixins: [R.AnnotateMixin],
  render: function() {
    var attribute, hoverManager;
    attribute = this.props.attribute;
    hoverManager = this.context.hoverManager;
    return R.div({
      className: R.cx({
        AttributeLabel: true,
        Interactive: true,
        isHovered: hoverManager.hoveredAttribute === attribute,
        isGoingToChange: _.contains(hoverManager.attributesToChange, attribute)
      }),
      onMouseDown: this._onMouseDown,
      onMouseEnter: this._onMouseEnter,
      onMouseLeave: this._onMouseLeave
    }, R.EditableText({
      className: "EditableTextInline Interactive",
      value: attribute.label,
      setValue: function(newValue) {
        return attribute.label = newValue;
      }
    }));
  },
  annotation: function() {
    return {
      attribute: this.props.attribute
    };
  },
  _onMouseDown: function(mouseDownEvent) {
    var attribute, dragManager, hoverManager, ref;
    if (Util.closest(mouseDownEvent.target, ".EditableTextInline")) {
      return;
    }
    attribute = this.props.attribute;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    mouseDownEvent.preventDefault();
    return dragManager.start(mouseDownEvent, {
      type: "transcludeAttribute",
      attribute: attribute,
      x: mouseDownEvent.clientX,
      y: mouseDownEvent.clientY,
      onMove: function(mouseMoveEvent) {
        dragManager.drag.x = mouseMoveEvent.clientX;
        return dragManager.drag.y = mouseMoveEvent.clientY;
      },
      onDrop: function() {
        return hoverManager.hoveredAttribute = null;
      },
      onCancel: (function(_this) {
        return function() {
          return _this._transcludeIntoFocusedExpression();
        };
      })(this)
    });
  },
  _transcludeIntoFocusedExpression: function() {
    var attribute, expressionCode, expressionCodeEl, focusedCodeMirrorEl;
    attribute = this.props.attribute;
    focusedCodeMirrorEl = document.querySelector(".CodeMirror-focused");
    if (!focusedCodeMirrorEl) {
      return;
    }
    expressionCodeEl = Util.closest(focusedCodeMirrorEl, ".ExpressionCode");
    expressionCode = expressionCodeEl.annotation.component;
    return expressionCode.transcludeAttribute(attribute);
  },
  _onMouseEnter: function(e) {
    var attribute, dragManager, hoverManager, ref;
    attribute = this.props.attribute;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    return hoverManager.hoveredAttribute = attribute;
  },
  _onMouseLeave: function(e) {
    var dragManager, hoverManager, ref;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    return hoverManager.hoveredAttribute = null;
  }
});

R.create("AttributeToken", {
  propTypes: {
    attribute: Model.Attribute,
    contextElement: "any"
  },
  contextTypes: {
    dragManager: R.DragManager,
    hoverManager: R.HoverManager
  },
  render: function() {
    var attribute, hoverManager;
    attribute = this.props.attribute;
    hoverManager = this.context.hoverManager;
    return R.span({
      className: R.cx({
        ReferenceToken: true,
        isHovered: hoverManager.hoveredAttribute === attribute,
        isGoingToChange: _.contains(hoverManager.attributesToChange, attribute)
      }),
      onMouseEnter: this._onMouseEnter,
      onMouseLeave: this._onMouseLeave
    }, this._label());
  },
  _label: function() {
    var attribute, contextElement, isSameContext, parentElement, ref;
    ref = this.props, attribute = ref.attribute, contextElement = ref.contextElement;
    parentElement = attribute.parentElement();
    if (contextElement) {
      isSameContext = parentElement.isAncestorOf(contextElement);
    } else {
      isSameContext = false;
    }
    if (isSameContext) {
      return attribute.label;
    } else {
      return parentElement.label + "s " + attribute.label;
    }
  },
  _onMouseEnter: function(e) {
    var attribute, dragManager, hoverManager, ref;
    attribute = this.props.attribute;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    return hoverManager.hoveredAttribute = attribute;
  },
  _onMouseLeave: function(e) {
    var dragManager, hoverManager, ref;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    return hoverManager.hoveredAttribute = null;
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"underscore":"underscore"}],30:[function(require,module,exports){
var Model, R, Util, _, key, numeric;

_ = require("underscore");

numeric = require("numeric");

key = require("keymaster");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("Canvas", {
  contextTypes: {
    project: Model.Project,
    hoverManager: R.HoverManager,
    dragManager: R.DragManager
  },
  render: function() {
    return R.div({
      className: "Canvas",
      onMouseDown: this._onMouseDown,
      onMouseEnter: this._onMouseEnter,
      onMouseLeave: this._onMouseLeave,
      onMouseMove: this._onMouseMove,
      onWheel: this._onWheel
    }, R.HTMLCanvas({
      ref: "HTMLCanvas",
      draw: this._draw
    }));
  },
  componentDidMount: function() {
    return window.addEventListener("resize", this._onResize);
  },
  _draw: function(ctx) {
    var graphic, highlight, hoverManager, i, len, project, ref, ref1, renderOpts, viewMatrix;
    ref = this.context, project = ref.project, hoverManager = ref.hoverManager;
    viewMatrix = this._viewMatrix();
    highlight = function(graphic) {
      var particularElement, ref1, ref2, ref3;
      particularElement = graphic.particularElement;
      if ((ref1 = hoverManager.controllerParticularElement) != null ? ref1.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#c00",
          lineWidth: 2.5
        };
      }
      if ((ref2 = project.selectedParticularElement) != null ? ref2.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#09c",
          lineWidth: 2.5
        };
      }
      if ((ref3 = hoverManager.hoveredParticularElement) != null ? ref3.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#0c9",
          lineWidth: 2.5
        };
      }
    };
    renderOpts = {
      ctx: ctx,
      viewMatrix: viewMatrix,
      highlight: highlight
    };
    if (!this._editingElement().isGridHidden) {
      this._drawBackgroundGrid(ctx);
    }
    ref1 = this._graphics();
    for (i = 0, len = ref1.length; i < len; i++) {
      graphic = ref1[i];
      graphic.render(renderOpts);
    }
    return this._drawControlPoints(ctx);
  },
  _drawControlPoints: function(ctx) {
    var color, controlPoint, hoverManager, i, len, ref, ref1, results, x, y;
    hoverManager = this.context.hoverManager;
    ref = this._controlPoints();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      controlPoint = ref[i];
      ctx.save();
      ctx.beginPath();
      ref1 = controlPoint.point, x = ref1[0], y = ref1[1];
      ctx.arc(x, y, this._controlPointRadius, 0, 2 * Math.PI, false);
      color = "#09c";
      if (controlPoint.attributesToChange.length > 0) {
        if (_.intersection(controlPoint.attributesToChange, hoverManager.attributesToChange).length > 0) {
          color = "#c00";
        }
      }
      ctx.fillStyle = controlPoint.filled ? color : "#fff";
      ctx.fill();
      ctx.strokeStyle = color;
      results.push(ctx.stroke());
    }
    return results;
  },
  _drawBackgroundGrid: function(ctx) {
    var i, j, matrix, project, ref, x, y;
    project = this.context.project;
    matrix = (ref = project.selectedParticularElement) != null ? ref.contextMatrix() : void 0;
    if (matrix == null) {
      matrix = new Util.Matrix();
    }
    matrix = this._viewMatrix().compose(matrix);
    ctx.save();
    ctx.beginPath();
    matrix.canvasTransform(ctx);
    for (x = i = -10; i <= 10; x = ++i) {
      ctx.moveTo(x, -10);
      ctx.lineTo(x, 10);
    }
    for (y = j = -10; j <= 10; y = ++j) {
      ctx.moveTo(-10, y);
      ctx.lineTo(10, y);
    }
    ctx.restore();
    ctx.save();
    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 0.5;
    ctx.stroke();
    ctx.restore();
    ctx.save();
    ctx.beginPath();
    matrix.canvasTransform(ctx);
    ctx.moveTo(-10, 0);
    ctx.lineTo(10, 0);
    ctx.moveTo(0, -10);
    ctx.lineTo(0, 10);
    ctx.restore();
    ctx.save();
    ctx.strokeStyle = "#ccc";
    ctx.lineWidth = 1;
    ctx.stroke();
    return ctx.restore();
  },
  _controlPointRadius: 5,
  _controlPoints: function() {
    var controlPoint, controlPoints, i, len, matrix, project, selectedParticularElement;
    project = this.context.project;
    selectedParticularElement = project.selectedParticularElement;
    if (!selectedParticularElement) {
      return [];
    }
    matrix = selectedParticularElement.accumulatedMatrix();
    matrix = this._viewMatrix().compose(matrix);
    controlPoints = selectedParticularElement.element.controlPoints();
    for (i = 0, len = controlPoints.length; i < len; i++) {
      controlPoint = controlPoints[i];
      controlPoint.point = matrix.fromLocal(controlPoint.point);
    }
    return controlPoints;
  },
  _hitDetectControlPoint: function(mouseEvent) {
    var controlPoint, controlPoints, i, len, mousePixel, quadrance;
    mousePixel = this._mousePosition(mouseEvent);
    controlPoints = this._controlPoints();
    quadrance = this._controlPointRadius * this._controlPointRadius;
    for (i = 0, len = controlPoints.length; i < len; i++) {
      controlPoint = controlPoints[i];
      if (Util.quadrance(mousePixel, controlPoint.point) <= quadrance) {
        return controlPoint;
      }
    }
    return null;
  },
  _onMouseDown: function(mouseEvent) {
    var isDoubleClick;
    mouseEvent.preventDefault();
    Util.clearTextFocus();
    isDoubleClick = this._isDoubleClick();
    this._updateSelected(mouseEvent, isDoubleClick);
    this._updateHoverAndCursor(mouseEvent);
    return this._startAppropriateDrag(mouseEvent);
  },
  _onMouseMove: function(mouseEvent) {
    var dragManager;
    dragManager = this.context.dragManager;
    if (!dragManager.drag) {
      return this._updateHoverAndCursor(mouseEvent);
    }
  },
  _onMouseEnter: function(mouseEvent) {
    var dragManager, element, ref;
    dragManager = this.context.dragManager;
    if (((ref = dragManager.drag) != null ? ref.type : void 0) !== "createElement") {
      return;
    }
    element = dragManager.drag.element;
    return this._createElement(mouseEvent, element);
  },
  _onMouseLeave: function(mouseEvent) {},
  _onWheel: function(wheelEvent) {
    wheelEvent.preventDefault();
    return this._zoom(wheelEvent);
  },
  _isDoubleClick: function() {
    var currentTime, doubleClickThreshold, isDoubleClick;
    doubleClickThreshold = 400;
    if (this._lastMouseDownTime == null) {
      this._lastMouseDownTime = 0;
    }
    currentTime = Date.now();
    isDoubleClick = currentTime - this._lastMouseDownTime < doubleClickThreshold;
    this._lastMouseDownTime = currentTime;
    return isDoubleClick;
  },
  _onResize: function() {
    this.refs.HTMLCanvas.resize();
    return this._rectCached = null;
  },
  _intent: function(mouseEvent) {
    var attributesToChange, controlPoint, controller, hits, nextSelectDouble, nextSelectSingle, project, selectedParticularElement;
    project = this.context.project;
    selectedParticularElement = project.selectedParticularElement;
    hits = this._hitDetect(mouseEvent);
    controlPoint = this._hitDetectControlPoint(mouseEvent);
    controller = (function() {
      var hit, i, len;
      if (controlPoint) {
        return null;
      }
      if (!hits) {
        return null;
      }
      for (i = 0, len = hits.length; i < len; i++) {
        hit = hits[i];
        if (hit.element.isController()) {
          return hit;
        }
      }
      return null;
    })();
    nextSelectDouble = (function() {
      var hit, i, index, len, nextHit, ref;
      if (controlPoint) {
        return selectedParticularElement;
      }
      if (!hits) {
        return null;
      }
      if (!selectedParticularElement) {
        return (ref = hits[hits.length - 2]) != null ? ref : hits[hits.length - 1];
      }
      for (index = i = 0, len = hits.length; i < len; index = ++i) {
        hit = hits[index];
        nextHit = hits[index + 1];
        if (!nextHit || nextHit.isAncestorOf(selectedParticularElement)) {
          return hit;
        }
      }
    })();
    nextSelectSingle = (function() {
      if (!nextSelectDouble) {
        return null;
      }
      if (controller || controlPoint) {
        return selectedParticularElement;
      }
      if (selectedParticularElement != null ? selectedParticularElement.isAncestorOf(nextSelectDouble) : void 0) {
        return selectedParticularElement;
      } else {
        return nextSelectDouble;
      }
    })();
    if (controlPoint) {
      attributesToChange = controlPoint.attributesToChange;
    } else if (controller) {
      attributesToChange = controller.element.attributesToChange();
    } else if (nextSelectSingle) {
      attributesToChange = nextSelectSingle.element.attributesToChange();
    } else {
      attributesToChange = [];
    }
    return {
      controlPoint: controlPoint,
      controller: controller,
      nextSelectDouble: nextSelectDouble,
      nextSelectSingle: nextSelectSingle,
      attributesToChange: attributesToChange
    };
  },
  _updateHoverAndCursor: function(mouseEvent) {
    var attributesToChange, controlPoint, controller, hoverManager, nextSelectSingle, ref;
    hoverManager = this.context.hoverManager;
    ref = this._intent(mouseEvent), controlPoint = ref.controlPoint, controller = ref.controller, nextSelectSingle = ref.nextSelectSingle, attributesToChange = ref.attributesToChange;
    hoverManager.hoveredParticularElement = nextSelectSingle;
    hoverManager.controllerParticularElement = controller;
    return hoverManager.attributesToChange = attributesToChange;
  },
  _updateSelected: function(mouseEvent, isDoubleClick) {
    var nextSelectDouble, nextSelectSingle, project, ref;
    project = this.context.project;
    ref = this._intent(mouseEvent), nextSelectDouble = ref.nextSelectDouble, nextSelectSingle = ref.nextSelectSingle;
    if (isDoubleClick) {
      return project.select(nextSelectDouble);
    } else {
      return project.select(nextSelectSingle);
    }
  },
  _startAppropriateDrag: function(mouseDownEvent) {
    var accumulatedMatrix, attributesToChange, controlPoint, controller, nextSelectSingle, originalMouseLocal, originalMousePixel, particularElementToDrag, project, ref;
    project = this.context.project;
    ref = this._intent(mouseDownEvent), controlPoint = ref.controlPoint, controller = ref.controller, nextSelectSingle = ref.nextSelectSingle, attributesToChange = ref.attributesToChange;
    if (controlPoint) {
      particularElementToDrag = project.selectedParticularElement;
    } else {
      particularElementToDrag = controller != null ? controller : nextSelectSingle;
    }
    if (particularElementToDrag) {
      accumulatedMatrix = particularElementToDrag.accumulatedMatrix();
      originalMousePixel = this._mousePosition(mouseDownEvent);
      originalMouseLocal = this._viewMatrix().compose(accumulatedMatrix).toLocal(originalMousePixel);
      return this._startDrag(mouseDownEvent, particularElementToDrag, attributesToChange, originalMouseLocal);
    } else {
      return this._startPan(mouseDownEvent);
    }
  },
  _startDrag: function(mouseDownEvent, particularElementToDrag, attributesToChange, originalMouseLocal, startImmediately) {
    var dragManager;
    if (startImmediately == null) {
      startImmediately = false;
    }
    dragManager = this.context.dragManager;
    dragManager.start(mouseDownEvent, {
      onMove: (function(_this) {
        return function(mouseMoveEvent) {
          var attribute, currentMousePixel, i, index, initialValues, len, objective, precision, precisions, results, solvedValue, solvedValues;
          if (!(startImmediately || dragManager.drag.consummated)) {
            return;
          }
          currentMousePixel = _this._mousePosition(mouseMoveEvent);
          initialValues = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = attributesToChange.length; i < len; i++) {
              attribute = attributesToChange[i];
              results.push(attribute.value());
            }
            return results;
          })();
          precisions = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = attributesToChange.length; i < len; i++) {
              attribute = attributesToChange[i];
              results.push(Util.precision(attribute.exprString));
            }
            return results;
          })();
          objective = function(trialValues) {
            var error, i, index, len, trialAccumulatedMatrix, trialMousePixel, trialValue;
            for (index = i = 0, len = attributesToChange.length; i < len; index = ++i) {
              attribute = attributesToChange[index];
              trialValue = trialValues[index];
              attribute.setExpression(trialValue);
            }
            trialAccumulatedMatrix = particularElementToDrag.accumulatedMatrix();
            trialMousePixel = _this._viewMatrix().compose(trialAccumulatedMatrix).fromLocal(originalMouseLocal);
            error = Util.quadrance(trialMousePixel, currentMousePixel);
            return error;
          };
          solvedValues = Util.solve(objective, initialValues);
          results = [];
          for (index = i = 0, len = attributesToChange.length; i < len; index = ++i) {
            attribute = attributesToChange[index];
            solvedValue = solvedValues[index];
            precision = precisions[index];
            if (key.command) {
              solvedValue = Util.roundToPrecision(solvedValue, precision - 1);
            }
            solvedValue = Util.toPrecision(solvedValue, precision);
            results.push(attribute.setExpression(solvedValue));
          }
          return results;
        };
      })(this)
    });
    if (startImmediately) {
      return dragManager.drag.onMove(mouseDownEvent);
    }
  },
  _createElement: function(mouseEvent, element) {
    var attributesToChange, newElement, newParticularElement, parent, project;
    project = this.context.project;
    parent = this._editingElement();
    newElement = element.createVariant();
    parent.addChild(newElement);
    newParticularElement = new Model.ParticularElement(newElement);
    project.select(newParticularElement);
    attributesToChange = newParticularElement.element.attributesToChange();
    return this._startDrag(mouseEvent, newParticularElement, attributesToChange, [0, 0], true);
  },
  _startPan: function(mouseDownEvent) {
    var dragManager, element, originalMouseLocal, originalMousePixel;
    dragManager = this.context.dragManager;
    element = this._editingElement();
    originalMousePixel = this._mousePosition(mouseDownEvent);
    originalMouseLocal = this._viewMatrix().toLocal(originalMousePixel);
    return dragManager.start(mouseDownEvent, {
      onMove: (function(_this) {
        return function(mouseMoveEvent) {
          var currentMouseLocal, currentMousePixel, offset, ref;
          if (!dragManager.drag.consummated) {
            return;
          }
          currentMousePixel = _this._mousePosition(mouseMoveEvent);
          currentMouseLocal = _this._viewMatrix().toLocal(currentMousePixel);
          offset = numeric.sub(currentMouseLocal, originalMouseLocal);
          return element.viewMatrix = (ref = element.viewMatrix).translate.apply(ref, offset);
        };
      })(this)
    });
  },
  _zoom: function(wheelEvent) {
    var element, matrix, mousePixel, ref, scaleFactor, x, y;
    element = this._editingElement();
    scaleFactor = Math.pow(1.001, -wheelEvent.deltaY);
    mousePixel = this._mousePosition(wheelEvent);
    ref = this._viewMatrix().toLocal(mousePixel), x = ref[0], y = ref[1];
    matrix = element.viewMatrix;
    matrix = matrix.translate(x, y);
    matrix = matrix.scale(scaleFactor, scaleFactor);
    matrix = matrix.translate(-x, -y);
    return element.viewMatrix = matrix;
  },
  _hitDetect: function(mouseEvent) {
    var graphic, hitDetectOpts, hits, i, len, ref, ref1, ref2, viewMatrix, x, y;
    viewMatrix = this._viewMatrix();
    ref = this._mousePosition(mouseEvent), x = ref[0], y = ref[1];
    hitDetectOpts = {
      viewMatrix: viewMatrix,
      x: x,
      y: y
    };
    hits = null;
    ref1 = this._graphics(true);
    for (i = 0, len = ref1.length; i < len; i++) {
      graphic = ref1[i];
      hits = (ref2 = graphic.hitDetect(hitDetectOpts)) != null ? ref2 : hits;
    }
    return hits;
  },
  _mousePosition: function(mouseEvent) {
    var rect, x, y;
    rect = this._rect();
    x = mouseEvent.clientX - rect.left;
    y = mouseEvent.clientY - rect.top;
    return [x, y];
  },
  _rect: function() {
    var el;
    if (this._rectCached != null) {
      return this._rectCached;
    }
    el = this.getDOMNode();
    return this._rectCached = el.getBoundingClientRect();
  },
  _editingElement: function() {
    var element, project;
    project = this.context.project;
    element = project.editingElement;
    return element;
  },
  _graphics: function(useCached) {
    var element;
    if (useCached == null) {
      useCached = false;
    }
    if (useCached && this._cachedGraphics) {
      return this._cachedGraphics;
    }
    element = this._editingElement();
    return this._cachedGraphics = element.allGraphics();
  },
  _viewMatrix: function() {
    var element, elementViewMatrix, height, rect, screenMatrix, width;
    element = this._editingElement();
    rect = this._rect();
    width = rect.width, height = rect.height;
    screenMatrix = new Util.Matrix(1, 0, 0, -1, width / 2, height / 2);
    elementViewMatrix = element.viewMatrix;
    return screenMatrix.compose(elementViewMatrix);
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"keymaster":4,"numeric":5,"underscore":"underscore"}],31:[function(require,module,exports){
var Model, R, Util, _;

_ = require("underscore");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("CreatePanel", {
  contextTypes: {
    project: Model.Project
  },
  render: function() {
    var element, project;
    project = this.context.project;
    return R.div({
      className: "CreatePanel"
    }, R.div({
      className: "Header"
    }, "Symbols"), R.div({
      className: "Scroller"
    }, (function() {
      var i, len, ref, results;
      ref = project.createPanelElements;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];
        results.push(R.CreatePanelItem({
          element: element,
          key: Util.getId(element)
        }));
      }
      return results;
    })(), R.div({
      className: "CreatePanelAddItem"
    }, R.button({
      className: "AddButton",
      onClick: this._createNewElement
    }))));
  },
  _createNewElement: function() {
    var element, project;
    project = this.context.project;
    element = project.createNewElement();
    project.createPanelElements.push(element);
    return project.setEditing(element);
  }
});

R.create("CreatePanelItem", {
  contextTypes: {
    project: Model.Project,
    dragManager: R.DragManager
  },
  propTypes: {
    element: Model.Element
  },
  render: function() {
    var element;
    element = this.props.element;
    return R.div({
      className: R.cx({
        "CreatePanelItem": true,
        "isEditing": this._isEditing()
      })
    }, R.div({
      className: "CreatePanelThumbnail",
      onMouseDown: this._onMouseDown
    }, R.Thumbnail({
      element: element
    })), this._isEditable() ? R.span({}, R.div({
      className: "CreatePanelItemEditButton icon-pencil",
      onClick: this._editElement
    })) : void 0, this._isEditable() && !this._isEditing() ? R.div({
      className: "CreatePanelItemRemoveButton icon-x",
      onClick: this._remove
    }) : void 0, R.div({
      className: "CreatePanelLabel"
    }, R.EditableText({
      value: element.label,
      setValue: this._setLabelValue
    })));
  },
  _isEditing: function() {
    var element, project;
    element = this.props.element;
    project = this.context.project;
    return element === project.editingElement;
  },
  _isEditable: function() {
    var builtIn, element;
    element = this.props.element;
    builtIn = _.values(Model);
    return !_.contains(builtIn, element);
  },
  _setLabelValue: function(newValue) {
    return this.props.element.label = newValue;
  },
  _editElement: function() {
    var element, project;
    element = this.props.element;
    project = this.context.project;
    return project.setEditing(element);
  },
  _remove: function() {
    var element, project;
    element = this.props.element;
    project = this.context.project;
    return project.createPanelElements = _.without(project.createPanelElements, element);
  },
  _onMouseDown: function(mouseDownEvent) {
    var dragManager, element;
    dragManager = this.context.dragManager;
    element = this.props.element;
    mouseDownEvent.preventDefault();
    Util.clearTextFocus();
    return dragManager.start(mouseDownEvent, {
      type: "createElement",
      element: element,
      onCancel: (function(_this) {
        return function() {
          if (_this._isEditable()) {
            return _this._editElement();
          }
        };
      })(this)
    });
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"underscore":"underscore"}],32:[function(require,module,exports){
var Model, R;

R = require("./R");

Model = require("../Model/Model");

R.create("Editor", {
  propTypes: {
    editor: Model.Editor
  },
  childContextTypes: {
    editor: Model.Editor,
    project: Model.Project,
    dragManager: R.DragManager,
    hoverManager: R.HoverManager
  },
  componentWillMount: function() {
    this._dragManager = new R.DragManager();
    return this._hoverManager = new R.HoverManager();
  },
  getChildContext: function() {
    var editor;
    editor = this.props.editor;
    return {
      editor: editor,
      project: editor.project,
      dragManager: this._dragManager,
      hoverManager: this._hoverManager
    };
  },
  render: function() {
    var cursor, ref;
    cursor = (ref = this._dragManager.drag) != null ? ref.cursor : void 0;
    return R.div({
      className: R.cx({
        CursorOverride: cursor != null
      }),
      style: {
        cursor: cursor != null ? cursor : ""
      }
    }, R.DragHint({}), R.CreatePanel({}), R.Outline({}), R.Inspector({}), R.Menubar({}), R.Canvas({}));
  }
});

R.create("ContextWrapper", {
  propTypes: {
    childRender: Function,
    context: Object
  },
  childContextTypes: {
    editor: Model.Editor,
    project: Model.Project,
    dragManager: R.DragManager,
    hoverManager: R.HoverManager
  },
  getChildContext: function() {
    return this.props.context;
  },
  render: function() {
    return this.props.childRender();
  }
});

R.create("DragHint", {
  contextTypes: {
    dragManager: R.DragManager
  },
  render: function() {
    var drag, dragManager;
    dragManager = this.context.dragManager;
    drag = dragManager.drag;
    return R.div({
      className: "DragHintContainer"
    }, (drag != null ? drag.type : void 0) === "transcludeAttribute" && drag.consummated ? R.div({
      className: "DragHint",
      style: {
        left: drag.x + 5,
        top: drag.y + 5
      }
    }, R.AttributeToken({
      attribute: drag.attribute,
      contextElement: null
    })) : void 0);
  }
});


},{"../Model/Model":21,"./R":43}],33:[function(require,module,exports){
var Dataflow, Model, R, Util, _;

_ = require("underscore");

R = require("./R");

Model = require("../Model/Model");

Dataflow = require("../Dataflow/Dataflow");

Util = require("../Util/Util");

R.create("Expression", {
  propTypes: {
    attribute: Model.Attribute
  },
  render: function() {
    var attribute;
    attribute = this.props.attribute;
    return R.div({
      className: "Expression"
    }, R.ExpressionCode({
      attribute: attribute
    }), R.ExpressionValue({
      attribute: attribute
    }));
  }
});

R.create("ExpressionValue", {
  propTypes: {
    attribute: Model.Attribute
  },
  render: function() {
    var attribute, value;
    attribute = this.props.attribute;
    if (attribute.isTrivial()) {
      return R.span({});
    } else {
      value = attribute.value();
      return R.div({
        className: "ExpressionValue"
      }, R.Value({
        value: value
      }));
    }
  }
});

R.create("Value", {
  propTypes: {
    value: "any"
  },
  render: function() {
    var value;
    value = this.props.value;
    return R.span({
      className: "Value"
    }, value instanceof Error ? "(Error)" : _.isFunction(value) ? "(Function)" : value instanceof Dataflow.Spread ? "(Spread) " + JSON.stringify(value.items) : _.isNumber(value) ? Util.toMaxPrecision(value, 3) : JSON.stringify(value));
  }
});

R.create("SpreadValue", {
  propTypes: {
    spread: "any"
  },
  maxSpreadItems: 5,
  render: function() {
    var index, value;
    return R.span({
      className: "SpreadValue"
    }, (function() {
      var i, ref, results;
      results = [];
      for (index = i = 0, ref = Math.min(this.spread.length, this.maxSpreadItems); 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        value = this.spread.take(index);
        results.push(R.span({
          className: "SpreadValueItem"
        }, R.Value({
          value: value
        })));
      }
      return results;
    }).call(this), this.spread.length > this.maxSpreadItems ? "..." : void 0);
  }
});


},{"../Dataflow/Dataflow":9,"../Model/Model":21,"../Util/Util":28,"./R":43,"underscore":"underscore"}],34:[function(require,module,exports){
var CodeMirror, Model, R, Util, _,
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

require("codemirror/addon/hint/show-hint");

require("codemirror/mode/javascript/javascript");

CodeMirror = require("codemirror");

_ = require("underscore");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("ExpressionCode", {
  propTypes: {
    attribute: Model.Attribute
  },
  contextTypes: {
    editor: Model.Editor,
    project: Model.Project,
    dragManager: R.DragManager,
    hoverManager: R.HoverManager
  },
  mixins: [R.AnnotateMixin],
  render: function() {
    var attribute;
    attribute = this.props.attribute;
    return R.div({
      className: "ExpressionCode Interactive",
      onMouseUp: this._onMouseUp
    });
  },
  annotation: function() {
    return {
      component: this
    };
  },
  componentDidMount: function() {
    var el;
    el = this.getDOMNode();
    this.mirror = CodeMirror(el, {
      mode: "javascript",
      viewportMargin: Infinity,
      smartIndent: true,
      indentUnit: 2,
      tabSize: 2,
      indentWithTabs: true,
      lineWrapping: true,
      scrollbarStyle: "null",
      undoDepth: 0
    });
    this.mirror.on("change", this._onChange);
    this.mirror.on("mousedown", this._onMirrorMouseDown);
    return this.componentDidUpdate();
  },
  componentDidUpdate: function() {
    return this._updateMirrorFromAttribute();
  },
  _onChange: function() {
    this._updateAttributeFromMirror();
    if (this.mirror.hasFocus()) {
      return this._showAutocomplete();
    }
  },
  _onMirrorMouseDown: function(mirror, mouseDownEvent) {
    var el;
    el = mouseDownEvent.target;
    if (Util.matches(el, ".cm-number")) {
      mouseDownEvent.preventDefault();
      return this._startNumberScrub(mouseDownEvent);
    }
  },
  _onMouseUp: function(mouseUpEvent) {
    var attribute, dragManager, ref;
    attribute = this.props.attribute;
    dragManager = this.context.dragManager;
    if (((ref = dragManager.drag) != null ? ref.type : void 0) === "transcludeAttribute") {
      return this.transcludeAttribute(dragManager.drag.attribute);
    }
  },
  _updateMirrorFromAttribute: function() {
    var attribute, ref, value;
    attribute = this.props.attribute;
    value = (ref = attribute.exprString) != null ? ref : "";
    if (this.mirror.getValue() !== value) {
      this.mirror.setValue(value);
    }
    return this._updateMarks();
  },
  _updateAttributeFromMirror: function() {
    var attribute, isUsed, newExprString, newReferences, oldReferences, referenceKey, referenceNode;
    attribute = this.props.attribute;
    newExprString = this.mirror.getValue();
    if (attribute.exprString !== newExprString) {
      oldReferences = attribute.references();
      newReferences = {};
      for (referenceKey in oldReferences) {
        if (!hasProp.call(oldReferences, referenceKey)) continue;
        referenceNode = oldReferences[referenceKey];
        isUsed = newExprString.indexOf(referenceKey) !== -1;
        if (isUsed) {
          newReferences[referenceKey] = referenceNode;
        }
      }
      return attribute.setExpression(newExprString, newReferences);
    }
  },
  transcludeAttribute: function(referenceAttribute) {
    if (this.mirror.hasFocus()) {
      return this._replaceSelectionWithReference(referenceAttribute);
    } else {
      return this._replaceAllWithReference(referenceAttribute);
    }
  },
  _replaceSelectionWithReference: function(referenceAttribute) {
    var attribute, exprString, referenceKey, references;
    attribute = this.props.attribute;
    references = attribute.references();
    referenceKey = Util.generateId();
    references[referenceKey] = referenceAttribute;
    exprString = attribute.exprString;
    attribute.setExpression(exprString, references);
    return this.mirror.replaceSelection(referenceKey);
  },
  _replaceAllWithReference: function(referenceAttribute) {
    var attribute, exprString, referenceKey, references;
    attribute = this.props.attribute;
    references = {};
    referenceKey = Util.generateId();
    references[referenceKey] = referenceAttribute;
    exprString = referenceKey;
    return attribute.setExpression(exprString, references);
  },
  _marks: function() {
    return this._attributeTokenMarks();
  },
  _attributeTokenMarks: function() {
    var attribute, endChar, fn, marks, ref, referenceAttribute, referenceKey, startChar, value;
    attribute = this.props.attribute;
    value = this.mirror.getValue();
    marks = [];
    ref = attribute.references();
    fn = function(referenceAttribute) {
      var from, render, to;
      from = Util.charToLineCh(value, startChar);
      to = Util.charToLineCh(value, endChar);
      render = function() {
        return R.AttributeToken({
          attribute: referenceAttribute,
          contextElement: attribute.parentElement()
        });
      };
      return marks.push({
        from: from,
        to: to,
        render: render
      });
    };
    for (referenceKey in ref) {
      if (!hasProp.call(ref, referenceKey)) continue;
      referenceAttribute = ref[referenceKey];
      startChar = value.indexOf(referenceKey);
      if (startChar === -1) {
        continue;
      }
      endChar = startChar + referenceKey.length;
      fn(referenceAttribute);
    }
    return marks;
  },
  _updateMarks: function() {
    var corresponds, el, existingMark, existingMarkToRemove, existingMarksToRemove, i, j, k, keepExistingMark, l, len, len1, len2, len3, mark, marks, newMark, range, ref, results, updatedMarks;
    marks = this._marks();
    if (this._existingMarks == null) {
      this._existingMarks = [];
    }
    updatedMarks = [];
    existingMarksToRemove = [];
    ref = this._existingMarks;
    for (i = 0, len = ref.length; i < len; i++) {
      existingMark = ref[i];
      keepExistingMark = false;
      range = existingMark.find();
      if (range) {
        for (j = 0, len1 = marks.length; j < len1; j++) {
          mark = marks[j];
          corresponds = range.from.line === mark.from.line && range.from.ch === mark.from.ch && range.to.line === mark.to.line && range.to.ch === mark.to.ch;
          if (corresponds) {
            this._renderMark(mark, existingMark.el);
            updatedMarks.push(mark);
            keepExistingMark = true;
          }
        }
      }
      if (!keepExistingMark) {
        existingMarksToRemove.push(existingMark);
      }
    }
    for (k = 0, len2 = existingMarksToRemove.length; k < len2; k++) {
      existingMarkToRemove = existingMarksToRemove[k];
      existingMarkToRemove.clear();
      this._existingMarks = _.without(this._existingMarks, existingMarkToRemove);
    }
    results = [];
    for (l = 0, len3 = marks.length; l < len3; l++) {
      mark = marks[l];
      if (indexOf.call(updatedMarks, mark) < 0) {
        el = document.createElement("span");
        this._renderMark(mark, el);
        newMark = this.mirror.markText(mark.from, mark.to, {
          replacedWith: el
        });
        newMark.el = el;
        results.push(this._existingMarks.push(newMark));
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  _renderMark: function(mark, el) {
    var wrappedReactElement;
    wrappedReactElement = R.ContextWrapper({
      context: this.context,
      childRender: mark.render
    });
    return React.render(wrappedReactElement, el);
  },
  _showAutocomplete: function() {
    return this.mirror.showHint({
      hint: this._hint,
      completeSingle: false
    });
  },
  _shouldShowHint: function(token) {
    var attribute, letters, referenceAttribute, referenceKey, references;
    attribute = this.props.attribute;
    if (token.type !== "variable") {
      return false;
    }
    letters = token.string;
    references = attribute.references();
    for (referenceKey in references) {
      if (!hasProp.call(references, referenceKey)) continue;
      referenceAttribute = references[referenceKey];
      if (letters.indexOf(referenceKey) !== -1) {
        return false;
      }
    }
    return true;
  },
  _hint: function(mirror) {
    var completions, cursor, from, letters, to, token;
    cursor = mirror.getCursor();
    token = mirror.getTokenAt(cursor);
    if (!this._shouldShowHint(token)) {
      return;
    }
    from = CodeMirror.Pos(cursor.line, token.start);
    to = CodeMirror.Pos(cursor.line, cursor.ch);
    letters = token.string.toLowerCase();
    completions = this._completions(letters, from, to);
    return {
      list: completions,
      from: from,
      to: to
    };
  },
  _completions: function(letters, from, to) {
    var attribute, completions, matchingAttributes, project;
    attribute = this.props.attribute;
    project = this.context.project;
    matchingAttributes = this._matchingAttributes(letters);
    completions = _.map(matchingAttributes, (function(_this) {
      return function(matchingAttribute) {
        return {
          render: function(el) {
            var wrappedReactElement;
            wrappedReactElement = R.ContextWrapper({
              context: _this.context,
              childRender: function() {
                return R.AttributeToken({
                  attribute: matchingAttribute,
                  contextElement: attribute.parentElement()
                });
              }
            });
            return React.render(wrappedReactElement, el);
          },
          hint: function() {
            _this.mirror.setSelection(from, to);
            return _this._replaceSelectionWithReference(matchingAttribute);
          }
        };
      };
    })(this));
    completions.push({
      displayText: "Create Variable: " + letters,
      hint: (function(_this) {
        return function() {
          var variable;
          variable = project.editingElement.addVariable();
          variable.label = letters;
          _this.mirror.setSelection(from, to);
          return _this._replaceSelectionWithReference(variable);
        };
      })(this)
    });
    return completions;
  },
  _matchingAttributes: function(letters) {
    var attributeLabelEls, matchingAttributes;
    attributeLabelEls = document.querySelectorAll(".AttributeLabel");
    matchingAttributes = _.map(attributeLabelEls, (function(_this) {
      return function(attributeLabelEl) {
        return attributeLabelEl.annotation.attribute;
      };
    })(this));
    matchingAttributes = _.filter(matchingAttributes, (function(_this) {
      return function(attribute) {
        var completionLetters, isMatch, label;
        label = attribute.label;
        completionLetters = label.toLowerCase();
        isMatch = _.every(letters, function(letter) {
          return completionLetters.indexOf(letter) !== -1;
        });
        return isMatch;
      };
    })(this));
    matchingAttributes = _.unique(matchingAttributes);
    return matchingAttributes;
  },
  _startNumberScrub: function(mouseDownEvent) {
    var end, ref, start;
    ref = this._getTokenPositionFromCursor(mouseDownEvent), start = ref.start, end = ref.end;
    this.mirror.focus();
    this.mirror.setSelection(start, end);
    return this._startScrubbingSelection(mouseDownEvent);
  },
  _getTokenPositionFromCursor: function(mouseDownEvent) {
    var earlyStart, end, position, start, token;
    position = this.mirror.coordsChar({
      left: mouseDownEvent.clientX,
      top: mouseDownEvent.clientY
    });
    if (this.mirror.cursorCoords(position).left < mouseDownEvent.clientX) {
      position.ch++;
    }
    token = this.mirror.getTokenAt(position);
    start = {
      line: position.line,
      ch: token.start
    };
    end = {
      line: position.line,
      ch: token.end
    };
    if (start.ch > 0) {
      earlyStart = {
        line: start.line,
        ch: start.ch - 1
      };
      if (this.mirror.getRange(earlyStart, start) === "-") {
        start = earlyStart;
      }
    }
    return {
      start: start,
      end: end
    };
  },
  _startScrubbingSelection: function(mouseDownEvent) {
    var dragManager, originalValue, precision, startX;
    dragManager = this.context.dragManager;
    originalValue = +this.mirror.getSelection();
    precision = Util.precision(this.mirror.getSelection());
    startX = mouseDownEvent.clientX;
    return dragManager.start(mouseDownEvent, {
      cursor: "ew-resize",
      onMove: (function(_this) {
        return function(moveEvent) {
          var delta, dx, newValue;
          dx = moveEvent.clientX - startX;
          dx = dx / 3;
          delta = dx * Math.pow(10, -precision);
          newValue = originalValue + delta;
          newValue = Util.toPrecision(newValue, precision);
          return _this.mirror.replaceSelection("" + newValue, "around");
        };
      })(this)
    });
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"codemirror":2,"codemirror/addon/hint/show-hint":1,"codemirror/mode/javascript/javascript":3,"underscore":"underscore"}],35:[function(require,module,exports){
var R, _;

_ = require("underscore");

R = require("../R");

R.create("EditableText", {
  propTypes: {
    value: String,
    setValue: Function
  },
  shouldComponentUpdate: function(nextProps) {
    return this._isDirty || nextProps.value !== this.props.value;
  },
  render: function() {
    var props;
    props = {
      contentEditable: true,
      onInput: this._onInput,
      onKeyDown: this._onKeyDown
    };
    _.defaults(props, this.props);
    return R.div(props);
  },
  componentDidMount: function() {
    this._refresh();
    if (this.props.value === "" || !this.props.value) {
      return this.getDOMNode().focus();
    }
  },
  componentDidUpdate: function() {
    return this._refresh();
  },
  _refresh: function() {
    var el;
    el = this.getDOMNode();
    if (el.textContent !== this.props.value) {
      el.textContent = this.props.value;
    }
    return this._isDirty = false;
  },
  _onInput: function() {
    var el, newValue;
    this._isDirty = true;
    el = this.getDOMNode();
    newValue = el.textContent;
    return this.props.setValue(newValue);
  },
  _onKeyDown: function(e) {
    if (e.keyCode === 13) {
      return e.preventDefault();
    }
  }
});


},{"../R":43,"underscore":"underscore"}],36:[function(require,module,exports){
var R, _, devicePixelRatio, sizeCanvas;

_ = require("underscore");

R = require("../R");

devicePixelRatio = window.devicePixelRatio || 1;

sizeCanvas = function(canvas) {
  var rect;
  rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * devicePixelRatio;
  return canvas.height = rect.height * devicePixelRatio;
};

R.create("HTMLCanvas", {
  propTypes: {
    draw: Function
  },
  render: function() {
    var props;
    props = {};
    _.defaults(props, this.props);
    return R.canvas(props);
  },
  componentDidMount: function() {
    return this._refresh();
  },
  componentDidUpdate: function() {
    return this._refresh();
  },
  resize: function() {
    return this._canvasIsSized = false;
  },
  _refresh: function() {
    var canvas, ctx;
    canvas = this.getDOMNode();
    if (this._canvasIsSized) {
      canvas.width = canvas.width;
    } else {
      sizeCanvas(canvas);
      this._canvasIsSized = true;
    }
    ctx = canvas.getContext("2d");
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    return this.props.draw(ctx);
  }
});


},{"../R":43,"underscore":"underscore"}],37:[function(require,module,exports){
var Model, R, Util;

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("Inspector", {
  contextTypes: {
    project: Model.Project
  },
  render: function() {
    var element, project, ref, ref1;
    project = this.context.project;
    element = (ref = project.selectedParticularElement) != null ? ref.element : void 0;
    return R.div({
      className: "Inspector"
    }, R.div({
      className: "Header"
    }, (ref1 = element != null ? element.label : void 0) != null ? ref1 : ""), R.div({
      className: "Scroller"
    }, element ? R.FullAttributesList({
      element: element
    }) : void 0));
  }
});

R.create("FullAttributesList", {
  propTypes: {
    element: Model.Element
  },
  render: function() {
    var attribute, component, element;
    element = this.props.element;
    return R.div({
      className: "InspectorList"
    }, R.div({
      className: "ComponentSection"
    }, R.div({
      className: "ComponentSectionTitle"
    }, R.span({}, "Variables")), R.div({
      className: "ComponentSectionContent"
    }, (function() {
      var i, len, ref, results;
      ref = element.variables();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        results.push(R.AttributeRow({
          attribute: attribute,
          key: Util.getId(attribute)
        }));
      }
      return results;
    })()), R.div({
      className: "AddVariableRow"
    }, R.button({
      className: "AddButton",
      onClick: this._addVariable
    }))), (function() {
      var i, len, ref, results;
      ref = element.components();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        component = ref[i];
        results.push(R.ComponentSection({
          component: component,
          key: Util.getId(component)
        }));
      }
      return results;
    })());
  },
  _addVariable: function() {
    var element;
    element = this.props.element;
    return element.addVariable();
  }
});

R.create("ComponentSection", {
  propTypes: {
    component: Model.Component
  },
  render: function() {
    var attribute, component;
    component = this.props.component;
    return R.div({
      className: "ComponentSection"
    }, R.div({
      className: "ComponentSectionTitle"
    }, R.span, component.label), R.div({
      className: "ComponentSectionContent"
    }, (function() {
      var i, len, ref, results;
      ref = component.attributes();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        results.push(R.AttributeRow({
          attribute: attribute,
          key: Util.getId(attribute)
        }));
      }
      return results;
    })()));
  }
});

R.create("NovelAttributesList", {
  propTypes: {
    element: Model.Element
  },
  contextTypes: {
    project: Model.Project
  },
  render: function() {
    var attribute, element, project, shouldShow;
    element = this.props.element;
    project = this.context.project;
    return R.div({
      className: "AttributesList"
    }, (function() {
      var i, len, ref, results;
      ref = element.attributes();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        shouldShow = attribute.isNovel() || attribute.isVariantOf(Model.Variable);
        if (shouldShow) {
          results.push(R.AttributeRow({
            attribute: attribute
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    })(), element === project.editingElement ? R.div({
      className: "AddVariableRow"
    }, R.button({
      className: "AddButton Interactive",
      onClick: this._addVariable
    })) : void 0);
  },
  _addVariable: function() {
    var element;
    element = this.props.element;
    return element.addVariable();
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43}],38:[function(require,module,exports){
var Drag, DragManager, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require("underscore");


/*

These are the options you can pass in to DragManager.start:

    cursor: (String) Sets the global cursor for the duration of the drag
    gesture.

    onConsummate(mouseMoveEvent): Will be called once the user has moved the
    mouse 3 pixels from the initial mouse down location.

    onMove(mouseMoveEvent): Will be called repeatedly, every time the mouse
    moves after the drag has been consummated.

    onDrop(mouseUpEvent): Will be called once the user releases the object being
    dragged.

    onCancel(mouseUpEvent): Will be called if the user releases the object
    without ever consummating the drag. When sticky is false, this is equivalent
    to a click. When sticky is true, this is equivalent to a double click.
 */

module.exports = DragManager = (function() {
  function DragManager() {
    this._onMouseUp = bind(this._onMouseUp, this);
    this._onMouseMove = bind(this._onMouseMove, this);
    this.drag = null;
    window.addEventListener("mousemove", this._onMouseMove);
    window.addEventListener("mouseup", this._onMouseUp);
  }

  DragManager.prototype.start = function(mouseDownEvent, spec) {
    return this.drag = new Drag(mouseDownEvent, spec);
  };

  DragManager.prototype._onMouseMove = function(mouseMoveEvent) {
    var base, d, dx, dy;
    if (!this.drag) {
      return;
    }
    if (!this.drag.consummated) {
      dx = mouseMoveEvent.clientX - this.drag.originalX;
      dy = mouseMoveEvent.clientY - this.drag.originalY;
      d = Math.max(Math.abs(dx), Math.abs(dy));
      if (d > 3) {
        return this._consummate(mouseMoveEvent);
      }
    } else {
      return typeof (base = this.drag).onMove === "function" ? base.onMove(mouseMoveEvent) : void 0;
    }
  };

  DragManager.prototype._onMouseUp = function(mouseUpEvent) {
    var base, base1, base2;
    if (!this.drag) {
      return;
    }
    if (this.drag.consummated) {
      if (typeof (base = this.drag).onDrop === "function") {
        base.onDrop(mouseUpEvent);
      }
    } else {
      if (typeof (base1 = this.drag).onCancel === "function") {
        base1.onCancel(mouseUpEvent);
      }
    }
    if (typeof (base2 = this.drag).onUp === "function") {
      base2.onUp(mouseUpEvent);
    }
    return this.drag = null;
  };

  DragManager.prototype._consummate = function(mouseMoveEvent) {
    var base;
    this.drag.consummated = true;
    return typeof (base = this.drag).onConsummate === "function" ? base.onConsummate(mouseMoveEvent) : void 0;
  };

  return DragManager;

})();

Drag = (function() {
  function Drag(mouseDownEvent, spec) {
    _.extend(this, spec);
    this.originalX = mouseDownEvent.clientX;
    this.originalY = mouseDownEvent.clientY;
    if (this.consummated == null) {
      this.consummated = false;
    }
  }

  return Drag;

})();


},{"underscore":"underscore"}],39:[function(require,module,exports){
var HoverManager;

module.exports = HoverManager = (function() {
  function HoverManager() {
    this.hoveredParticularElement = null;
    this.controllerParticularElement = null;
    this.attributesToChange = [];
    this.hoveredAttribute = null;
  }

  return HoverManager;

})();


},{}],40:[function(require,module,exports){
var Model, R, Util, key;

key = require("keymaster");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("Menubar", {
  contextTypes: {
    editor: Model.Editor,
    project: Model.Project
  },
  render: function() {
    var editor, isSelection, project, ref;
    ref = this.context, editor = ref.editor, project = ref.project;
    isSelection = project.selectedParticularElement != null;
    return R.div({
      className: "Menubar"
    }, R.MenubarItem({
      title: "New",
      isDisabled: false,
      fn: this._new
    }), R.MenubarItem({
      title: "Load",
      isDisabled: false,
      fn: this._load
    }), R.MenubarItem({
      title: "Save",
      isDisabled: false,
      fn: this._save
    }), R.div({
      className: "MenubarSeparator"
    }), R.MenubarItem({
      title: "Undo",
      isDisabled: !editor.isUndoable(),
      fn: this._undo
    }), R.MenubarItem({
      title: "Redo",
      isDisabled: !editor.isRedoable(),
      fn: this._redo
    }), R.div({
      className: "MenubarSeparator"
    }), R.MenubarItem({
      title: "Delete",
      isDisabled: !isSelection,
      fn: this._removeSelectedElement
    }), R.MenubarItem({
      title: "Group",
      isDisabled: !isSelection,
      fn: this._groupSelectedElement
    }), R.MenubarItem({
      title: "Create Symbol",
      isDisabled: !isSelection,
      fn: this._createSymbolFromSelectedElement
    }));
  },
  componentDidMount: function() {
    return key("backspace", (function(_this) {
      return function(e) {
        if (Util.textFocus()) {
          return;
        }
        e.preventDefault();
        return _this._removeSelectedElement();
      };
    })(this));
  },
  _new: function() {
    var editor;
    editor = this.context.editor;
    return editor.createNewProject();
  },
  _load: function() {
    var editor;
    editor = this.context.editor;
    return editor.loadFromFile();
  },
  _save: function() {
    var editor;
    editor = this.context.editor;
    return editor.saveToFile();
  },
  _undo: function() {
    var editor;
    editor = this.context.editor;
    return editor.undo();
  },
  _redo: function() {
    var editor;
    editor = this.context.editor;
    return editor.redo();
  },
  _todo: function() {},
  _removeSelectedElement: function() {
    var project;
    project = this.context.project;
    return project.removeSelectedElement();
  },
  _groupSelectedElement: function() {
    var project;
    project = this.context.project;
    return project.groupSelectedElement();
  },
  _duplicateSelectedElement: function() {
    var project;
    project = this.context.project;
    return project.duplicateSelectedElement();
  },
  _createSymbolFromSelectedElement: function() {
    var project;
    project = this.context.project;
    return project.createSymbolFromSelectedElement();
  }
});

R.create("MenubarItem", {
  propTypes: {
    title: String,
    isDisabled: Boolean,
    fn: Function
  },
  render: function() {
    var fn, isDisabled, ref, title;
    ref = this.props, title = ref.title, isDisabled = ref.isDisabled, fn = ref.fn;
    return R.div({
      className: R.cx({
        MenubarItem: true,
        isDisabled: isDisabled
      }),
      onClick: this._activate
    }, title);
  },
  _activate: function() {
    var fn, isDisabled, ref;
    ref = this.props, isDisabled = ref.isDisabled, fn = ref.fn;
    if (isDisabled) {
      return;
    }
    return fn();
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"keymaster":4}],41:[function(require,module,exports){
var Model, R, Util, _;

_ = require("underscore");

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("Outline", {
  contextTypes: {
    project: Model.Project
  },
  render: function() {
    var element, project;
    project = this.context.project;
    element = project.editingElement;
    return R.div({
      className: "Outline"
    }, R.div({
      className: "Header"
    }, "Outline"), R.div({
      className: "Scroller"
    }, R.OutlineTree({
      element: element
    })));
  }
});

R.create("OutlineTree", {
  propTypes: {
    element: Model.Element
  },
  contextTypes: {
    dragManager: R.DragManager
  },
  mixins: [R.AnnotateMixin],
  render: function() {
    var drag, dragManager, element, isBeingDragged, isExpanded, outlineTree;
    element = this.props.element;
    dragManager = this.context.dragManager;
    isExpanded = element.expanded;
    drag = dragManager.drag;
    isBeingDragged = (drag != null ? drag.type : void 0) === "outlineReorder" && drag.consummated && drag.element === element;
    outlineTree = R.div({
      className: "OutlineTree"
    }, R.OutlineItem({
      element: element
    }), isExpanded ? R.OutlineChildren({
      element: element
    }) : void 0);
    if (isBeingDragged) {
      return R.div({}, R.div({
        className: "OutlineDragging",
        style: {
          left: drag.x,
          top: drag.y,
          width: drag.width
        }
      }, outlineTree), R.div({
        className: "OutlinePlaceholder",
        style: {
          height: drag.height
        }
      }));
    } else {
      return outlineTree;
    }
  },
  annotation: function() {
    return {
      element: this.props.element
    };
  }
});

R.create("OutlineChildren", {
  propTypes: {
    element: Model.Element
  },
  mixins: [R.AnnotateMixin],
  render: function() {
    var childElement, element;
    element = this.props.element;
    return R.div({
      className: "OutlineChildren"
    }, (function() {
      var i, len, ref, results;
      ref = element.childElements();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        childElement = ref[i];
        results.push(R.OutlineTree({
          element: childElement,
          key: Util.getId(childElement)
        }));
      }
      return results;
    })());
  },
  annotation: function() {
    return {
      element: this.props.element
    };
  }
});

R.create("OutlineItem", {
  propTypes: {
    element: Model.Element
  },
  contextTypes: {
    project: Model.Project,
    hoverManager: R.HoverManager,
    dragManager: R.DragManager
  },
  render: function() {
    var element, hoverManager, isActiveController, isController, isExpanded, isHovered, isSelected, project, ref, ref1, ref2;
    project = this.context.project;
    element = this.props.element;
    hoverManager = this.context.hoverManager;
    isSelected = ((ref = project.selectedParticularElement) != null ? ref.element : void 0) === element;
    isHovered = ((ref1 = hoverManager.hoveredParticularElement) != null ? ref1.element : void 0) === element;
    isActiveController = ((ref2 = hoverManager.controllerParticularElement) != null ? ref2.element : void 0) === element;
    isController = element.isController();
    isExpanded = element.expanded;
    return R.div({
      className: R.cx({
        OutlineItem: true,
        isSelected: isSelected,
        isHovered: isHovered,
        isActiveController: isActiveController,
        isController: isController
      }),
      onMouseDown: this._onMouseDown,
      onMouseEnter: this._onMouseEnter,
      onMouseLeave: this._onMouseLeave
    }, R.div({
      className: "ElementRow"
    }, R.div({
      className: "ElementRowDisclosure"
    }, R.div({
      className: R.cx({
        DisclosureTriangle: true,
        Interactive: true,
        isExpanded: isExpanded
      }),
      onClick: this._onClickTriangle
    })), R.div({
      className: "ElementRowLabel"
    }, R.EditableText({
      className: "EditableTextInline Interactive",
      value: element.label,
      setValue: this._setLabelValue
    }))), R.NovelAttributesList({
      element: element
    }));
  },
  _onMouseDown: function(mouseDownEvent) {
    var target;
    target = mouseDownEvent.target;
    if (Util.closest(target, ".Interactive")) {
      return;
    }
    mouseDownEvent.preventDefault();
    Util.clearTextFocus();
    this._select();
    return this._startDragToReorder(mouseDownEvent);
  },
  _onMouseEnter: function() {
    var dragManager, element, hoverManager, particularElement, ref;
    element = this.props.element;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    particularElement = new Model.ParticularElement(element);
    return hoverManager.hoveredParticularElement = particularElement;
  },
  _onMouseLeave: function() {
    var dragManager, hoverManager, ref;
    ref = this.context, dragManager = ref.dragManager, hoverManager = ref.hoverManager;
    if (dragManager.drag != null) {
      return;
    }
    return hoverManager.hoveredParticularElement = null;
  },
  _setLabelValue: function(newValue) {
    return this.props.element.label = newValue;
  },
  _onClickTriangle: function() {
    var element;
    element = this.props.element;
    element.expanded = !element.expanded;
  },
  _select: function() {
    var element, particularElement, project;
    element = this.props.element;
    project = this.context.project;
    particularElement = new Model.ParticularElement(element);
    return project.select(particularElement);
  },
  _startDragToReorder: function(mouseDownEvent) {
    var dragManager, el, element, height, offsetX, offsetY, outlineEl, outlineTreeEl, rect, width;
    element = this.props.element;
    dragManager = this.context.dragManager;
    el = this.getDOMNode();
    outlineTreeEl = Util.closest(el, ".OutlineTree");
    outlineEl = Util.closest(el, ".Outline");
    rect = outlineTreeEl.getBoundingClientRect();
    offsetX = mouseDownEvent.clientX - rect.left;
    offsetY = mouseDownEvent.clientY - rect.top;
    width = rect.width;
    height = rect.height;
    return dragManager.start(mouseDownEvent, {
      type: "outlineReorder",
      element: element,
      outlineEl: outlineEl,
      width: width,
      height: height,
      onMove: (function(_this) {
        return function(mouseMoveEvent) {
          var dropSpot;
          dragManager.drag.x = mouseMoveEvent.clientX - offsetX;
          dragManager.drag.y = mouseMoveEvent.clientY - offsetY;
          dropSpot = _this._findDropSpot(dragManager.drag);
          if (dropSpot) {
            return _this._reorderItem(dropSpot);
          }
        };
      })(this)
    });
  },
  _findDropSpot: function(drag) {
    var bestDropSpot, checkFit, childEl, childEls, dragPosition, droppedPosition, i, j, len, len1, outlineChildrenEl, outlineChildrenEls, outlineEl, outlinePlaceholderEl, rect, x, y;
    x = drag.x, y = drag.y, outlineEl = drag.outlineEl;
    dragPosition = [x, y];
    outlinePlaceholderEl = outlineEl.querySelector(".OutlinePlaceholder");
    if (outlinePlaceholderEl != null) {
      outlinePlaceholderEl.style.display = "none";
    }
    bestDropSpot = {
      quadrance: 40 * 40
    };
    checkFit = (function(_this) {
      return function(droppedPosition, outlineChildrenEl, beforeOutlineTreeEl) {
        var quadrance;
        quadrance = Util.quadrance(dragPosition, droppedPosition);
        if (quadrance < bestDropSpot.quadrance) {
          return bestDropSpot = {
            quadrance: quadrance,
            outlineChildrenEl: outlineChildrenEl,
            beforeOutlineTreeEl: beforeOutlineTreeEl
          };
        }
      };
    })(this);
    outlineChildrenEls = outlineEl.querySelectorAll(".OutlineChildren");
    for (i = 0, len = outlineChildrenEls.length; i < len; i++) {
      outlineChildrenEl = outlineChildrenEls[i];
      if (Util.closest(outlineChildrenEl, ".OutlineDragging")) {
        continue;
      }
      childEls = _.filter(outlineChildrenEl.childNodes, function(el) {
        return Util.matches(el, ".OutlineTree");
      });
      for (j = 0, len1 = childEls.length; j < len1; j++) {
        childEl = childEls[j];
        rect = childEl.getBoundingClientRect();
        droppedPosition = [rect.left, rect.top];
        checkFit(droppedPosition, outlineChildrenEl, childEl);
      }
      rect = outlineChildrenEl.getBoundingClientRect();
      droppedPosition = [rect.left, rect.bottom];
      checkFit(droppedPosition, outlineChildrenEl, null);
    }
    if (outlinePlaceholderEl != null) {
      outlinePlaceholderEl.style.display = "";
    }
    if (bestDropSpot.outlineChildrenEl) {
      return bestDropSpot;
    } else {
      return null;
    }
  },
  _reorderItem: function(dropSpot) {
    var beforeElement, beforeOutlineTreeEl, element, index, outlineChildrenEl, parentElement;
    element = this.props.element;
    outlineChildrenEl = dropSpot.outlineChildrenEl, beforeOutlineTreeEl = dropSpot.beforeOutlineTreeEl;
    parentElement = outlineChildrenEl.annotation.element;
    if (beforeOutlineTreeEl) {
      beforeElement = beforeOutlineTreeEl.annotation.element;
      if (parentElement.children().indexOf(element) !== -1) {
        parentElement.removeChild(element);
      }
      index = parentElement.children().indexOf(beforeElement);
      return parentElement.addChild(element, index);
    } else {
      return parentElement.addChild(element);
    }
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43,"underscore":"underscore"}],42:[function(require,module,exports){
var Model, R, Util;

R = require("./R");

Model = require("../Model/Model");

Util = require("../Util/Util");

R.create("Thumbnail", {
  propTypes: {
    element: Model.Element
  },
  render: function() {
    var element;
    element = this.props.element;
    return R.div({
      className: "Thumbnail"
    }, R.Picture({
      element: element
    }));
  }
});

R.create("Picture", {
  contextTypes: {
    project: Model.Project,
    hoverManager: R.HoverManager
  },
  propTypes: {
    element: Model.Element
  },
  render: function() {
    return R.HTMLCanvas({
      draw: this._draw
    });
  },
  _draw: function(ctx) {
    var element, graphic, highlight, hoverManager, i, len, project, ref, renderOpts, results, viewMatrix;
    project = this.context.project;
    hoverManager = this.context.hoverManager;
    element = this.props.element;
    viewMatrix = this._viewMatrix();
    highlight = function(graphic) {
      var particularElement, ref, ref1, ref2;
      particularElement = graphic.particularElement;
      if ((ref = hoverManager.controllerParticularElement) != null ? ref.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#c00",
          lineWidth: 2.5
        };
      }
      if ((ref1 = project.selectedParticularElement) != null ? ref1.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#09c",
          lineWidth: 2.5
        };
      }
      if ((ref2 = hoverManager.hoveredParticularElement) != null ? ref2.isAncestorOf(particularElement) : void 0) {
        return {
          color: "#0c9",
          lineWidth: 2.5
        };
      }
    };
    renderOpts = {
      ctx: ctx,
      viewMatrix: viewMatrix,
      highlight: highlight
    };
    ref = element.allGraphics();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      graphic = ref[i];
      results.push(graphic.render(renderOpts));
    }
    return results;
  },
  _viewMatrix: function() {
    var element, elementViewMatrix, height, ref, screenMatrix, width;
    element = this.props.element;
    ref = this._size(), width = ref.width, height = ref.height;
    screenMatrix = new Util.Matrix(0.1, 0, 0, -0.1, width / 2, height / 2);
    elementViewMatrix = element.viewMatrix;
    return screenMatrix.compose(elementViewMatrix);
  },
  _size: function() {
    var el, height, rect, width;
    if (this._cachedSize) {
      return this._cachedSize;
    }
    el = this.getDOMNode();
    rect = el.getBoundingClientRect();
    width = rect.width, height = rect.height;
    return this._cachedSize = {
      width: width,
      height: height
    };
  }
});


},{"../Model/Model":21,"../Util/Util":28,"./R":43}],43:[function(require,module,exports){
var Model, R, _, desugarPropType, desugarPropTypes, key, ref, value,
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

Model = require("../Model/Model");

module.exports = R = {};

ref = React.DOM;
for (key in ref) {
  if (!hasProp.call(ref, key)) continue;
  value = ref[key];
  R[key] = value;
}

R.cx = function(classNames) {
  return Object.keys(classNames).filter(function(className) {
    return classNames[className];
  }).join(" ");
};

R.AnnotateMixin = {
  componentDidMount: function() {
    return this._annotateDOMNode();
  },
  componentDidUpdate: function() {
    return this._annotateDOMNode();
  },
  componentWillUnmount: function() {
    return this._clearAnnotation();
  },
  _annotateDOMNode: function() {
    var el;
    el = this.getDOMNode();
    return el.annotation = this.annotation();
  },
  _clearAnnotation: function() {
    var el;
    el = this.getDOMNode();
    return delete el.annotation;
  }
};

R.create = function(name, spec) {
  var component, i, len, ref1, typesProperty;
  spec.displayName = name;
  ref1 = ["propTypes", "childContextTypes", "contextTypes"];
  for (i = 0, len = ref1.length; i < len; i++) {
    typesProperty = ref1[i];
    if (spec[typesProperty]) {
      spec[typesProperty] = desugarPropTypes(spec[typesProperty]);
    }
  }
  component = React.createClass(spec);
  return R[name] = React.createFactory(component);
};

R.render = React.render;

desugarPropTypes = function(propTypes) {
  return _.mapObject(propTypes, desugarPropType);
};

desugarPropType = function(propType) {
  if (propType === Number) {
    return React.PropTypes.number.isRequired;
  } else if (propType === String) {
    return React.PropTypes.string.isRequired;
  } else if (propType === Boolean) {
    return React.PropTypes.bool.isRequired;
  } else if (propType === Function) {
    return React.PropTypes.func.isRequired;
  } else if (propType === Array) {
    return React.PropTypes.array.isRequired;
  } else if (propType === Object) {
    return React.PropTypes.object.isRequired;
  } else if (propType === "any") {
    return React.PropTypes.any;
  } else if (propType.isVariantOf != null) {
    return function(props, propName, componentName) {
      var prop;
      prop = props[propName];
      if (!prop.isVariantOf(propType)) {
        return new Error("In `" + componentName + "`, property `" + propName + "` is the wrong type.");
      }
    };
  } else {
    return React.PropTypes.instanceOf(propType).isRequired;
  }
};

R.DragManager = require("./Manager/DragManager");

R.HoverManager = require("./Manager/HoverManager");

require("./Generic/EditableText");

require("./Generic/HTMLCanvas");

require("./Picture");

require("./Editor");

require("./Menubar");

require("./CreatePanel");

require("./Canvas");

require("./Outline");

require("./Inspector");

require("./AttributeRow");

require("./Expression");

require("./ExpressionCode");


},{"../Model/Model":21,"./AttributeRow":29,"./Canvas":30,"./CreatePanel":31,"./Editor":32,"./Expression":33,"./ExpressionCode":34,"./Generic/EditableText":35,"./Generic/HTMLCanvas":36,"./Inspector":37,"./Manager/DragManager":38,"./Manager/HoverManager":39,"./Menubar":40,"./Outline":41,"./Picture":42,"underscore":"underscore"}],44:[function(require,module,exports){
var Apparatus, Dataflow, Model, R, Storage, Util, _, debouncedShouldCheckpoint, editor, eventName, i, len, refresh, refreshEventNames, render, shouldCheckpoint, willRefreshNextFrame;

_ = require("underscore");

R = require("./View/R");

Model = require("./Model/Model");

Dataflow = require("./Dataflow/Dataflow");

Storage = require("./Storage/Storage");

Util = require("./Util/Util");

Apparatus = window.Apparatus = {};

Apparatus.Dataflow = Dataflow;

Apparatus.Model = Model;

Apparatus.Storage = Storage;

Apparatus.R = R;

Apparatus.Util = Util;

editor = new Model.Editor();

Apparatus.editor = editor;

render = function() {
  return Dataflow.run(function() {
    return R.render(R.Editor({
      editor: editor
    }), document.body);
  });
};

render();

shouldCheckpoint = false;

document.addEventListener("mouseup", function() {
  return shouldCheckpoint = true;
});

debouncedShouldCheckpoint = _.debounce(function() {
  return shouldCheckpoint = true;
}, 500);

document.addEventListener("keydown", function() {
  return debouncedShouldCheckpoint();
});

willRefreshNextFrame = false;

refresh = Apparatus.refresh = function() {
  if (willRefreshNextFrame) {
    return;
  }
  willRefreshNextFrame = true;
  return requestAnimationFrame(function() {
    render();
    if (shouldCheckpoint) {
      editor.checkpoint();
      shouldCheckpoint = false;
    }
    return willRefreshNextFrame = false;
  });
};

refreshEventNames = ["mousedown", "mousemove", "mouseup", "keydown", "keyup", "scroll", "change", "wheel", "mousewheel"];

for (i = 0, len = refreshEventNames.length; i < len; i++) {
  eventName = refreshEventNames[i];
  window.addEventListener(eventName, refresh);
}


},{"./Dataflow/Dataflow":9,"./Model/Model":21,"./Storage/Storage":26,"./Util/Util":28,"./View/R":43,"underscore":"underscore"}]},{},[44])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzIiwibm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHQuanMiLCJub2RlX21vZHVsZXMva2V5bWFzdGVyL2tleW1hc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9udW1lcmljL251bWVyaWMtMS4yLjYuanMiLCJub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5LXN0cmluZy9ub2RlX21vZHVsZXMvc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL0RhdGFmbG93L0NvbXB1dGF0aW9uTWFuYWdlci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL0RhdGFmbG93L0RhdGFmbG93LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvRGF0YWZsb3cvRHluYW1pY1Njb3BlLmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvRGF0YWZsb3cvU3ByZWFkLmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvRGF0YWZsb3cvU3ByZWFkRW52LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvRXZhbHVhdG9yL0V2YWx1YXRvci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL0V2YWx1YXRvci9ldmFsdWF0ZS5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL0V2YWx1YXRvci9zcHJlYWQuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9HcmFwaGljL0dyYXBoaWMuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9Nb2RlbC9BdHRyaWJ1dGUuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9Nb2RlbC9FZGl0b3IuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9Nb2RlbC9FbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvTW9kZWwvTGluay5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL01vZGVsL01vZGVsLmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvTW9kZWwvTm9kZS5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL01vZGVsL1BhcnRpY3VsYXJFbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvTW9kZWwvUHJvamVjdC5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1N0b3JhZ2UvU2VyaWFsaXplci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1N0b3JhZ2UvU3RvcmFnZS5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1V0aWwvTWF0cml4LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvVXRpbC9VdGlsLmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvVmlldy9BdHRyaWJ1dGVSb3cuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L0NhbnZhcy5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1ZpZXcvQ3JlYXRlUGFuZWwuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L0VkaXRvci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1ZpZXcvRXhwcmVzc2lvbi5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1ZpZXcvRXhwcmVzc2lvbkNvZGUuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L0dlbmVyaWMvRWRpdGFibGVUZXh0LmNvZmZlZSIsIi9Vc2Vycy90b2J5c2NoYWNobWFuL0Ryb3Bib3gvUHVibGljL3dlYi9BcHBhcmF0dXMgNC9zcmMvVmlldy9HZW5lcmljL0hUTUxDYW52YXMuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L0luc3BlY3Rvci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1ZpZXcvTWFuYWdlci9EcmFnTWFuYWdlci5jb2ZmZWUiLCIvVXNlcnMvdG9ieXNjaGFjaG1hbi9Ecm9wYm94L1B1YmxpYy93ZWIvQXBwYXJhdHVzIDQvc3JjL1ZpZXcvTWFuYWdlci9Ib3Zlck1hbmFnZXIuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L01lbnViYXIuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L091dGxpbmUuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L1BpY3R1cmUuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9WaWV3L1IuY29mZmVlIiwiL1VzZXJzL3RvYnlzY2hhY2htYW4vRHJvcGJveC9QdWJsaWMvd2ViL0FwcGFyYXR1cyA0L3NyYy9pbmRleC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3gwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxDQUFzQixTQUFBO0lBQ3BCLE1BQUEsQ0FBQTtJQUNBLElBQUcsZ0JBQUg7TUFDRSxNQUFNLENBQUMsVUFBUCxDQUFBO01BQ0EsZ0JBQUEsR0FBbUIsTUFGckI7O1dBR0Esb0JBQUEsR0FBdUI7RUFMSCxDQUF0QjtBQUg0Qjs7QUFVOUIsaUJBQUEsR0FBb0IsQ0FDbEIsV0FEa0IsRUFFbEIsV0FGa0IsRUFHbEIsU0FIa0IsRUFJbEIsU0FKa0IsRUFLbEIsT0FMa0IsRUFNbEIsUUFOa0IsRUFPbEIsUUFQa0IsRUFRbEIsT0FSa0IsRUFTbEIsWUFUa0I7O0FBWXBCLEtBQUEsbURBQUE7O0VBQ0UsTUFBTSxDQUFDLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLE9BQW5DO0FBREYiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgSElOVF9FTEVNRU5UX0NMQVNTICAgICAgICA9IFwiQ29kZU1pcnJvci1oaW50XCI7XG4gIHZhciBBQ1RJVkVfSElOVF9FTEVNRU5UX0NMQVNTID0gXCJDb2RlTWlycm9yLWhpbnQtYWN0aXZlXCI7XG5cbiAgLy8gVGhpcyBpcyB0aGUgb2xkIGludGVyZmFjZSwga2VwdCBhcm91bmQgZm9yIG5vdyB0byBzdGF5XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmxlLlxuICBDb2RlTWlycm9yLnNob3dIaW50ID0gZnVuY3Rpb24oY20sIGdldEhpbnRzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFnZXRIaW50cykgcmV0dXJuIGNtLnNob3dIaW50KG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXN5bmMpIGdldEhpbnRzLmFzeW5jID0gdHJ1ZTtcbiAgICB2YXIgbmV3T3B0cyA9IHtoaW50OiBnZXRIaW50c307XG4gICAgaWYgKG9wdGlvbnMpIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykgbmV3T3B0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgcmV0dXJuIGNtLnNob3dIaW50KG5ld09wdHMpO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2hvd0hpbnRcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIFdlIHdhbnQgYSBzaW5nbGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgIGlmICh0aGlzLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoID4gMSB8fCB0aGlzLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHJldHVybjtcblxuICAgIGlmICh0aGlzLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUpIHRoaXMuc3RhdGUuY29tcGxldGlvbkFjdGl2ZS5jbG9zZSgpO1xuICAgIHZhciBjb21wbGV0aW9uID0gdGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlID0gbmV3IENvbXBsZXRpb24odGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9uLm9wdGlvbnMuaGludCkgcmV0dXJuO1xuXG4gICAgQ29kZU1pcnJvci5zaWduYWwodGhpcywgXCJzdGFydENvbXBsZXRpb25cIiwgdGhpcyk7XG4gICAgY29tcGxldGlvbi51cGRhdGUodHJ1ZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIENvbXBsZXRpb24oY20sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5idWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy53aWRnZXQgPSBudWxsO1xuICAgIHRoaXMuZGVib3VuY2UgPSAwO1xuICAgIHRoaXMudGljayA9IDA7XG4gICAgdGhpcy5zdGFydFBvcyA9IHRoaXMuY20uZ2V0Q3Vyc29yKCk7XG4gICAgdGhpcy5zdGFydExlbiA9IHRoaXMuY20uZ2V0TGluZSh0aGlzLnN0YXJ0UG9zLmxpbmUpLmxlbmd0aDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjbS5vbihcImN1cnNvckFjdGl2aXR5XCIsIHRoaXMuYWN0aXZpdHlGdW5jID0gZnVuY3Rpb24oKSB7IHNlbGYuY3Vyc29yQWN0aXZpdHkoKTsgfSk7XG4gIH1cblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCAxMDAwLzYwKTtcbiAgfTtcbiAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGNsZWFyVGltZW91dDtcblxuICBDb21wbGV0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKCkpIHJldHVybjtcbiAgICAgIHRoaXMuY20uc3RhdGUuY29tcGxldGlvbkFjdGl2ZSA9IG51bGw7XG4gICAgICB0aGlzLnRpY2sgPSBudWxsO1xuICAgICAgdGhpcy5jbS5vZmYoXCJjdXJzb3JBY3Rpdml0eVwiLCB0aGlzLmFjdGl2aXR5RnVuYyk7XG5cbiAgICAgIGlmICh0aGlzLndpZGdldCAmJiB0aGlzLmRhdGEpIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuZGF0YSwgXCJjbG9zZVwiKTtcbiAgICAgIGlmICh0aGlzLndpZGdldCkgdGhpcy53aWRnZXQuY2xvc2UoKTtcbiAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuY20sIFwiZW5kQ29tcGxldGlvblwiLCB0aGlzLmNtKTtcbiAgICB9LFxuXG4gICAgYWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUgPT0gdGhpcztcbiAgICB9LFxuXG4gICAgcGljazogZnVuY3Rpb24oZGF0YSwgaSkge1xuICAgICAgdmFyIGNvbXBsZXRpb24gPSBkYXRhLmxpc3RbaV07XG4gICAgICBpZiAoY29tcGxldGlvbi5oaW50KSBjb21wbGV0aW9uLmhpbnQodGhpcy5jbSwgZGF0YSwgY29tcGxldGlvbik7XG4gICAgICBlbHNlIHRoaXMuY20ucmVwbGFjZVJhbmdlKGdldFRleHQoY29tcGxldGlvbiksIGNvbXBsZXRpb24uZnJvbSB8fCBkYXRhLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24udG8gfHwgZGF0YS50bywgXCJjb21wbGV0ZVwiKTtcbiAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGRhdGEsIFwicGlja1wiLCBjb21wbGV0aW9uKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9LFxuXG4gICAgY3Vyc29yQWN0aXZpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGVib3VuY2UpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWJvdW5jZSk7XG4gICAgICAgIHRoaXMuZGVib3VuY2UgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5jbS5nZXRDdXJzb3IoKSwgbGluZSA9IHRoaXMuY20uZ2V0TGluZShwb3MubGluZSk7XG4gICAgICBpZiAocG9zLmxpbmUgIT0gdGhpcy5zdGFydFBvcy5saW5lIHx8IGxpbmUubGVuZ3RoIC0gcG9zLmNoICE9IHRoaXMuc3RhcnRMZW4gLSB0aGlzLnN0YXJ0UG9zLmNoIHx8XG4gICAgICAgICAgcG9zLmNoIDwgdGhpcy5zdGFydFBvcy5jaCB8fCB0aGlzLmNtLnNvbWV0aGluZ1NlbGVjdGVkKCkgfHxcbiAgICAgICAgICAocG9zLmNoICYmIHRoaXMub3B0aW9ucy5jbG9zZUNoYXJhY3RlcnMudGVzdChsaW5lLmNoYXJBdChwb3MuY2ggLSAxKSkpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kZWJvdW5jZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtzZWxmLnVwZGF0ZSgpO30pO1xuICAgICAgICBpZiAodGhpcy53aWRnZXQpIHRoaXMud2lkZ2V0LmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbihmaXJzdCkge1xuICAgICAgaWYgKHRoaXMudGljayA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5kYXRhKSBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmRhdGEsIFwidXBkYXRlXCIpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaGludC5hc3luYykge1xuICAgICAgICB0aGlzLmZpbmlzaFVwZGF0ZSh0aGlzLm9wdGlvbnMuaGludCh0aGlzLmNtLCB0aGlzLm9wdGlvbnMpLCBmaXJzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbXlUaWNrID0gKyt0aGlzLnRpY2ssIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGludCh0aGlzLmNtLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgaWYgKHNlbGYudGljayA9PSBteVRpY2spIHNlbGYuZmluaXNoVXBkYXRlKGRhdGEsIGZpcnN0KTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoVXBkYXRlOiBmdW5jdGlvbihkYXRhLCBmaXJzdCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgdmFyIHBpY2tlZCA9ICh0aGlzLndpZGdldCAmJiB0aGlzLndpZGdldC5waWNrZWQpIHx8IChmaXJzdCAmJiB0aGlzLm9wdGlvbnMuY29tcGxldGVTaW5nbGUpO1xuICAgICAgaWYgKHRoaXMud2lkZ2V0KSB0aGlzLndpZGdldC5jbG9zZSgpO1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5saXN0Lmxlbmd0aCkge1xuICAgICAgICBpZiAocGlja2VkICYmIGRhdGEubGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHRoaXMucGljayhkYXRhLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndpZGdldCA9IG5ldyBXaWRnZXQodGhpcywgZGF0YSk7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoZGF0YSwgXCJzaG93blwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmNtLm9wdGlvbnMuaGludE9wdGlvbnM7XG4gICAgICB2YXIgb3V0ID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRPcHRpb25zKSBvdXRbcHJvcF0gPSBkZWZhdWx0T3B0aW9uc1twcm9wXTtcbiAgICAgIGlmIChlZGl0b3IpIGZvciAodmFyIHByb3AgaW4gZWRpdG9yKVxuICAgICAgICBpZiAoZWRpdG9yW3Byb3BdICE9PSB1bmRlZmluZWQpIG91dFtwcm9wXSA9IGVkaXRvcltwcm9wXTtcbiAgICAgIGlmIChvcHRpb25zKSBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpXG4gICAgICAgIGlmIChvcHRpb25zW3Byb3BdICE9PSB1bmRlZmluZWQpIG91dFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUZXh0KGNvbXBsZXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGNvbXBsZXRpb24gPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbXBsZXRpb247XG4gICAgZWxzZSByZXR1cm4gY29tcGxldGlvbi50ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRLZXlNYXAoY29tcGxldGlvbiwgaGFuZGxlKSB7XG4gICAgdmFyIGJhc2VNYXAgPSB7XG4gICAgICBVcDogZnVuY3Rpb24oKSB7aGFuZGxlLm1vdmVGb2N1cygtMSk7fSxcbiAgICAgIERvd246IGZ1bmN0aW9uKCkge2hhbmRsZS5tb3ZlRm9jdXMoMSk7fSxcbiAgICAgIFBhZ2VVcDogZnVuY3Rpb24oKSB7aGFuZGxlLm1vdmVGb2N1cygtaGFuZGxlLm1lbnVTaXplKCkgKyAxLCB0cnVlKTt9LFxuICAgICAgUGFnZURvd246IGZ1bmN0aW9uKCkge2hhbmRsZS5tb3ZlRm9jdXMoaGFuZGxlLm1lbnVTaXplKCkgLSAxLCB0cnVlKTt9LFxuICAgICAgSG9tZTogZnVuY3Rpb24oKSB7aGFuZGxlLnNldEZvY3VzKDApO30sXG4gICAgICBFbmQ6IGZ1bmN0aW9uKCkge2hhbmRsZS5zZXRGb2N1cyhoYW5kbGUubGVuZ3RoIC0gMSk7fSxcbiAgICAgIEVudGVyOiBoYW5kbGUucGljayxcbiAgICAgIFRhYjogaGFuZGxlLnBpY2ssXG4gICAgICBFc2M6IGhhbmRsZS5jbG9zZVxuICAgIH07XG4gICAgdmFyIGN1c3RvbSA9IGNvbXBsZXRpb24ub3B0aW9ucy5jdXN0b21LZXlzO1xuICAgIHZhciBvdXJNYXAgPSBjdXN0b20gPyB7fSA6IGJhc2VNYXA7XG4gICAgZnVuY3Rpb24gYWRkQmluZGluZyhrZXksIHZhbCkge1xuICAgICAgdmFyIGJvdW5kO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgYm91bmQgPSBmdW5jdGlvbihjbSkgeyByZXR1cm4gdmFsKGNtLCBoYW5kbGUpOyB9O1xuICAgICAgLy8gVGhpcyBtZWNoYW5pc20gaXMgZGVwcmVjYXRlZFxuICAgICAgZWxzZSBpZiAoYmFzZU1hcC5oYXNPd25Qcm9wZXJ0eSh2YWwpKVxuICAgICAgICBib3VuZCA9IGJhc2VNYXBbdmFsXTtcbiAgICAgIGVsc2VcbiAgICAgICAgYm91bmQgPSB2YWw7XG4gICAgICBvdXJNYXBba2V5XSA9IGJvdW5kO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tKVxuICAgICAgZm9yICh2YXIga2V5IGluIGN1c3RvbSkgaWYgKGN1c3RvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICBhZGRCaW5kaW5nKGtleSwgY3VzdG9tW2tleV0pO1xuICAgIHZhciBleHRyYSA9IGNvbXBsZXRpb24ub3B0aW9ucy5leHRyYUtleXM7XG4gICAgaWYgKGV4dHJhKVxuICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhKSBpZiAoZXh0cmEuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgYWRkQmluZGluZyhrZXksIGV4dHJhW2tleV0pO1xuICAgIHJldHVybiBvdXJNYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIaW50RWxlbWVudChoaW50c0VsZW1lbnQsIGVsKSB7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9IGhpbnRzRWxlbWVudCkge1xuICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiTElcIiAmJiBlbC5wYXJlbnROb2RlID09IGhpbnRzRWxlbWVudCkgcmV0dXJuIGVsO1xuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFdpZGdldChjb21wbGV0aW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucGlja2VkID0gZmFsc2U7XG4gICAgdmFyIHdpZGdldCA9IHRoaXMsIGNtID0gY29tcGxldGlvbi5jbTtcblxuICAgIHZhciBoaW50cyA9IHRoaXMuaGludHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgaGludHMuY2xhc3NOYW1lID0gXCJDb2RlTWlycm9yLWhpbnRzXCI7XG4gICAgdGhpcy5zZWxlY3RlZEhpbnQgPSBkYXRhLnNlbGVjdGVkSGludCB8fCAwO1xuXG4gICAgdmFyIGNvbXBsZXRpb25zID0gZGF0YS5saXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcGxldGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlbHQgPSBoaW50cy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpLCBjdXIgPSBjb21wbGV0aW9uc1tpXTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBISU5UX0VMRU1FTlRfQ0xBU1MgKyAoaSAhPSB0aGlzLnNlbGVjdGVkSGludCA/IFwiXCIgOiBcIiBcIiArIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1MpO1xuICAgICAgaWYgKGN1ci5jbGFzc05hbWUgIT0gbnVsbCkgY2xhc3NOYW1lID0gY3VyLmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgZWx0LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIGlmIChjdXIucmVuZGVyKSBjdXIucmVuZGVyKGVsdCwgZGF0YSwgY3VyKTtcbiAgICAgIGVsc2UgZWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1ci5kaXNwbGF5VGV4dCB8fCBnZXRUZXh0KGN1cikpKTtcbiAgICAgIGVsdC5oaW50SWQgPSBpO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBjbS5jdXJzb3JDb29yZHMoY29tcGxldGlvbi5vcHRpb25zLmFsaWduV2l0aFdvcmQgPyBkYXRhLmZyb20gOiBudWxsKTtcbiAgICB2YXIgbGVmdCA9IHBvcy5sZWZ0LCB0b3AgPSBwb3MuYm90dG9tLCBiZWxvdyA9IHRydWU7XG4gICAgaGludHMuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgaGludHMuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4sIHRoZW4gd2Ugd2FudCB0aGUgbWVudSB0byBhcHBlYXIgb24gdGhlIGxlZnQgb2YgdGhlIGN1cnNvci5cbiAgICB2YXIgd2luVyA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IE1hdGgubWF4KGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCk7XG4gICAgdmFyIHdpbkggPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpO1xuICAgIChjb21wbGV0aW9uLm9wdGlvbnMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKGhpbnRzKTtcbiAgICB2YXIgYm94ID0gaGludHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG92ZXJsYXBZID0gYm94LmJvdHRvbSAtIHdpbkg7XG4gICAgaWYgKG92ZXJsYXBZID4gMCkge1xuICAgICAgdmFyIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wLCBjdXJUb3AgPSBwb3MudG9wIC0gKHBvcy5ib3R0b20gLSBib3gudG9wKTtcbiAgICAgIGlmIChjdXJUb3AgLSBoZWlnaHQgPiAwKSB7IC8vIEZpdHMgYWJvdmUgY3Vyc29yXG4gICAgICAgIGhpbnRzLnN0eWxlLnRvcCA9ICh0b3AgPSBwb3MudG9wIC0gaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgYmVsb3cgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID4gd2luSCkge1xuICAgICAgICBoaW50cy5zdHlsZS5oZWlnaHQgPSAod2luSCAtIDUpICsgXCJweFwiO1xuICAgICAgICBoaW50cy5zdHlsZS50b3AgPSAodG9wID0gcG9zLmJvdHRvbSAtIGJveC50b3ApICsgXCJweFwiO1xuICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChkYXRhLmZyb20uY2ggIT0gY3Vyc29yLmNoKSB7XG4gICAgICAgICAgcG9zID0gY20uY3Vyc29yQ29vcmRzKGN1cnNvcik7XG4gICAgICAgICAgaGludHMuc3R5bGUubGVmdCA9IChsZWZ0ID0gcG9zLmxlZnQpICsgXCJweFwiO1xuICAgICAgICAgIGJveCA9IGhpbnRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBvdmVybGFwWCA9IGJveC5yaWdodCAtIHdpblc7XG4gICAgaWYgKG92ZXJsYXBYID4gMCkge1xuICAgICAgaWYgKGJveC5yaWdodCAtIGJveC5sZWZ0ID4gd2luVykge1xuICAgICAgICBoaW50cy5zdHlsZS53aWR0aCA9ICh3aW5XIC0gNSkgKyBcInB4XCI7XG4gICAgICAgIG92ZXJsYXBYIC09IChib3gucmlnaHQgLSBib3gubGVmdCkgLSB3aW5XO1xuICAgICAgfVxuICAgICAgaGludHMuc3R5bGUubGVmdCA9IChsZWZ0ID0gcG9zLmxlZnQgLSBvdmVybGFwWCkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwID0gYnVpbGRLZXlNYXAoY29tcGxldGlvbiwge1xuICAgICAgbW92ZUZvY3VzOiBmdW5jdGlvbihuLCBhdm9pZFdyYXApIHsgd2lkZ2V0LmNoYW5nZUFjdGl2ZSh3aWRnZXQuc2VsZWN0ZWRIaW50ICsgbiwgYXZvaWRXcmFwKTsgfSxcbiAgICAgIHNldEZvY3VzOiBmdW5jdGlvbihuKSB7IHdpZGdldC5jaGFuZ2VBY3RpdmUobik7IH0sXG4gICAgICBtZW51U2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB3aWRnZXQuc2NyZWVuQW1vdW50KCk7IH0sXG4gICAgICBsZW5ndGg6IGNvbXBsZXRpb25zLmxlbmd0aCxcbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHsgY29tcGxldGlvbi5jbG9zZSgpOyB9LFxuICAgICAgcGljazogZnVuY3Rpb24oKSB7IHdpZGdldC5waWNrKCk7IH0sXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuXG4gICAgaWYgKGNvbXBsZXRpb24ub3B0aW9ucy5jbG9zZU9uVW5mb2N1cykge1xuICAgICAgdmFyIGNsb3NpbmdPbkJsdXI7XG4gICAgICBjbS5vbihcImJsdXJcIiwgdGhpcy5vbkJsdXIgPSBmdW5jdGlvbigpIHsgY2xvc2luZ09uQmx1ciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNvbXBsZXRpb24uY2xvc2UoKTsgfSwgMTAwKTsgfSk7XG4gICAgICBjbS5vbihcImZvY3VzXCIsIHRoaXMub25Gb2N1cyA9IGZ1bmN0aW9uKCkgeyBjbGVhclRpbWVvdXQoY2xvc2luZ09uQmx1cik7IH0pO1xuICAgIH1cblxuICAgIHZhciBzdGFydFNjcm9sbCA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICBjbS5vbihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VyU2Nyb2xsID0gY20uZ2V0U2Nyb2xsSW5mbygpLCBlZGl0b3IgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5ld1RvcCA9IHRvcCArIHN0YXJ0U2Nyb2xsLnRvcCAtIGN1clNjcm9sbC50b3A7XG4gICAgICB2YXIgcG9pbnQgPSBuZXdUb3AgLSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wKTtcbiAgICAgIGlmICghYmVsb3cpIHBvaW50ICs9IGhpbnRzLm9mZnNldEhlaWdodDtcbiAgICAgIGlmIChwb2ludCA8PSBlZGl0b3IudG9wIHx8IHBvaW50ID49IGVkaXRvci5ib3R0b20pIHJldHVybiBjb21wbGV0aW9uLmNsb3NlKCk7XG4gICAgICBoaW50cy5zdHlsZS50b3AgPSBuZXdUb3AgKyBcInB4XCI7XG4gICAgICBoaW50cy5zdHlsZS5sZWZ0ID0gKGxlZnQgKyBzdGFydFNjcm9sbC5sZWZ0IC0gY3VyU2Nyb2xsLmxlZnQpICsgXCJweFwiO1xuICAgIH0pO1xuXG4gICAgQ29kZU1pcnJvci5vbihoaW50cywgXCJkYmxjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IGdldEhpbnRFbGVtZW50KGhpbnRzLCBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xuICAgICAgaWYgKHQgJiYgdC5oaW50SWQgIT0gbnVsbCkge3dpZGdldC5jaGFuZ2VBY3RpdmUodC5oaW50SWQpOyB3aWRnZXQucGljaygpO31cbiAgICB9KTtcblxuICAgIENvZGVNaXJyb3Iub24oaGludHMsIFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHQgPSBnZXRIaW50RWxlbWVudChoaW50cywgZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcbiAgICAgIGlmICh0ICYmIHQuaGludElkICE9IG51bGwpIHtcbiAgICAgICAgd2lkZ2V0LmNoYW5nZUFjdGl2ZSh0LmhpbnRJZCk7XG4gICAgICAgIGlmIChjb21wbGV0aW9uLm9wdGlvbnMuY29tcGxldGVPblNpbmdsZUNsaWNrKSB3aWRnZXQucGljaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgQ29kZU1pcnJvci5vbihoaW50cywgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y20uZm9jdXMoKTt9LCAyMCk7XG4gICAgfSk7XG5cbiAgICBDb2RlTWlycm9yLnNpZ25hbChkYXRhLCBcInNlbGVjdFwiLCBjb21wbGV0aW9uc1swXSwgaGludHMuZmlyc3RDaGlsZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRpb24ud2lkZ2V0ICE9IHRoaXMpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcGxldGlvbi53aWRnZXQgPSBudWxsO1xuICAgICAgdGhpcy5oaW50cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGludHMpO1xuICAgICAgdGhpcy5jb21wbGV0aW9uLmNtLnJlbW92ZUtleU1hcCh0aGlzLmtleU1hcCk7XG5cbiAgICAgIHZhciBjbSA9IHRoaXMuY29tcGxldGlvbi5jbTtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRpb24ub3B0aW9ucy5jbG9zZU9uVW5mb2N1cykge1xuICAgICAgICBjbS5vZmYoXCJibHVyXCIsIHRoaXMub25CbHVyKTtcbiAgICAgICAgY20ub2ZmKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzKTtcbiAgICAgIH1cbiAgICAgIGNtLm9mZihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbXBsZXRpb24uY20ucmVtb3ZlS2V5TWFwKHRoaXMua2V5TWFwKTtcbiAgICAgIHZhciB3aWRnZXQgPSB0aGlzO1xuICAgICAgdGhpcy5rZXlNYXAgPSB7RW50ZXI6IGZ1bmN0aW9uKCkgeyB3aWRnZXQucGlja2VkID0gdHJ1ZTsgfX07XG4gICAgICB0aGlzLmNvbXBsZXRpb24uY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwKTtcbiAgICB9LFxuXG4gICAgcGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbXBsZXRpb24ucGljayh0aGlzLmRhdGEsIHRoaXMuc2VsZWN0ZWRIaW50KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlQWN0aXZlOiBmdW5jdGlvbihpLCBhdm9pZFdyYXApIHtcbiAgICAgIGlmIChpID49IHRoaXMuZGF0YS5saXN0Lmxlbmd0aClcbiAgICAgICAgaSA9IGF2b2lkV3JhcCA/IHRoaXMuZGF0YS5saXN0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgZWxzZSBpZiAoaSA8IDApXG4gICAgICAgIGkgPSBhdm9pZFdyYXAgPyAwICA6IHRoaXMuZGF0YS5saXN0Lmxlbmd0aCAtIDE7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEhpbnQgPT0gaSkgcmV0dXJuO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmhpbnRzLmNoaWxkTm9kZXNbdGhpcy5zZWxlY3RlZEhpbnRdO1xuICAgICAgbm9kZS5jbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZS5yZXBsYWNlKFwiIFwiICsgQUNUSVZFX0hJTlRfRUxFTUVOVF9DTEFTUywgXCJcIik7XG4gICAgICBub2RlID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3RoaXMuc2VsZWN0ZWRIaW50ID0gaV07XG4gICAgICBub2RlLmNsYXNzTmFtZSArPSBcIiBcIiArIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1M7XG4gICAgICBpZiAobm9kZS5vZmZzZXRUb3AgPCB0aGlzLmhpbnRzLnNjcm9sbFRvcClcbiAgICAgICAgdGhpcy5oaW50cy5zY3JvbGxUb3AgPSBub2RlLm9mZnNldFRvcCAtIDM7XG4gICAgICBlbHNlIGlmIChub2RlLm9mZnNldFRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdGhpcy5oaW50cy5zY3JvbGxUb3AgKyB0aGlzLmhpbnRzLmNsaWVudEhlaWdodClcbiAgICAgICAgdGhpcy5oaW50cy5zY3JvbGxUb3AgPSBub2RlLm9mZnNldFRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0IC0gdGhpcy5oaW50cy5jbGllbnRIZWlnaHQgKyAzO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwodGhpcy5kYXRhLCBcInNlbGVjdFwiLCB0aGlzLmRhdGEubGlzdFt0aGlzLnNlbGVjdGVkSGludF0sIG5vZGUpO1xuICAgIH0sXG5cbiAgICBzY3JlZW5BbW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5oaW50cy5jbGllbnRIZWlnaHQgLyB0aGlzLmhpbnRzLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIH1cbiAgfTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFwiLCBcImF1dG9cIiwgZnVuY3Rpb24oY20sIG9wdGlvbnMpIHtcbiAgICB2YXIgaGVscGVycyA9IGNtLmdldEhlbHBlcnMoY20uZ2V0Q3Vyc29yKCksIFwiaGludFwiKSwgd29yZHM7XG4gICAgaWYgKGhlbHBlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlbHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IGhlbHBlcnNbaV0oY20sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3VyICYmIGN1ci5saXN0Lmxlbmd0aCkgcmV0dXJuIGN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdvcmRzID0gY20uZ2V0SGVscGVyKGNtLmdldEN1cnNvcigpLCBcImhpbnRXb3Jkc1wiKSkge1xuICAgICAgaWYgKHdvcmRzKSByZXR1cm4gQ29kZU1pcnJvci5oaW50LmZyb21MaXN0KGNtLCB7d29yZHM6IHdvcmRzfSk7XG4gICAgfSBlbHNlIGlmIChDb2RlTWlycm9yLmhpbnQuYW55d29yZCkge1xuICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaGludC5hbnl3b3JkKGNtLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50XCIsIFwiZnJvbUxpc3RcIiwgZnVuY3Rpb24oY20sIG9wdGlvbnMpIHtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCksIHRva2VuID0gY20uZ2V0VG9rZW5BdChjdXIpO1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSBvcHRpb25zLndvcmRzW2ldO1xuICAgICAgaWYgKHdvcmQuc2xpY2UoMCwgdG9rZW4uc3RyaW5nLmxlbmd0aCkgPT0gdG9rZW4uc3RyaW5nKVxuICAgICAgICBmb3VuZC5wdXNoKHdvcmQpO1xuICAgIH1cblxuICAgIGlmIChmb3VuZC5sZW5ndGgpIHJldHVybiB7XG4gICAgICBsaXN0OiBmb3VuZCxcbiAgICAgIGZyb206IENvZGVNaXJyb3IuUG9zKGN1ci5saW5lLCB0b2tlbi5zdGFydCksXG4gICAgICAgICAgICB0bzogQ29kZU1pcnJvci5Qb3MoY3VyLmxpbmUsIHRva2VuLmVuZClcbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmNvbW1hbmRzLmF1dG9jb21wbGV0ZSA9IENvZGVNaXJyb3Iuc2hvd0hpbnQ7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGhpbnQ6IENvZGVNaXJyb3IuaGludC5hdXRvLFxuICAgIGNvbXBsZXRlU2luZ2xlOiB0cnVlLFxuICAgIGFsaWduV2l0aFdvcmQ6IHRydWUsXG4gICAgY2xvc2VDaGFyYWN0ZXJzOiAvW1xccygpXFxbXFxde307Oj4sXS8sXG4gICAgY2xvc2VPblVuZm9jdXM6IHRydWUsXG4gICAgY29tcGxldGVPblNpbmdsZUNsaWNrOiBmYWxzZSxcbiAgICBjb250YWluZXI6IG51bGwsXG4gICAgY3VzdG9tS2V5czogbnVsbCxcbiAgICBleHRyYUtleXM6IG51bGxcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImhpbnRPcHRpb25zXCIsIG51bGwpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHA6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxuLy8gaW1wbGVtZW50ZWQgaW4gSmF2YVNjcmlwdCBvbiB0b3Agb2YgdGhlIGJyb3dzZXIncyBET00uXG4vL1xuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcbi8vIGF0IGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy8jY20taW50ZXJuYWxzIC5cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtb2QoKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgcmV0dXJuIGRlZmluZShbXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIHRoaXMuQ29kZU1pcnJvciA9IG1vZCgpO1xufSkoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIEJST1dTRVIgU05JRkZJTkdcblxuICAvLyBLbHVkZ2VzIGZvciBidWdzIGFuZCBiZWhhdmlvciBkaWZmZXJlbmNlcyB0aGF0IGNhbid0IGJlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0ZWQgYXJlIGVuYWJsZWQgYmFzZWQgb24gdXNlckFnZW50IGV0YyBzbmlmZmluZy5cblxuICB2YXIgZ2Vja28gPSAvZ2Vja29cXC9cXGQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgaWVfdXB0bzEwID0gL01TSUUgXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGllID0gaWVfdXB0bzEwIHx8IGllXzExdXA7XG4gIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cFsxXSk7XG4gIHZhciB3ZWJraXQgPSAvV2ViS2l0XFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBjaHJvbWUgPSAvQ2hyb21lXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgcHJlc3RvID0gL09wZXJhXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgc2FmYXJpID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuICB2YXIgbWFjX2dlTW91bnRhaW5MaW9uID0gL01hYyBPUyBYIDFcXGRcXEQoWzgtOV18XFxkXFxkKVxcRC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIHZhciBpb3MgPSAvQXBwbGVXZWJLaXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL01vYmlsZVxcL1xcdysvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIC8vIFRoaXMgaXMgd29lZnVsbHkgaW5jb21wbGV0ZS4gU3VnZ2VzdGlvbnMgZm9yIGFsdGVybmF0aXZlIG1ldGhvZHMgd2VsY29tZS5cbiAgdmFyIG1vYmlsZSA9IGlvcyB8fCAvQW5kcm9pZHx3ZWJPU3xCbGFja0JlcnJ5fE9wZXJhIE1pbml8T3BlcmEgTW9iaXxJRU1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5cbiAgdmFyIHByZXN0b192ZXJzaW9uID0gcHJlc3RvICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7XG4gIGlmIChwcmVzdG9fdmVyc2lvbikgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pO1xuICBpZiAocHJlc3RvX3ZlcnNpb24gJiYgcHJlc3RvX3ZlcnNpb24gPj0gMTUpIHsgcHJlc3RvID0gZmFsc2U7IHdlYmtpdCA9IHRydWU7IH1cbiAgLy8gU29tZSBicm93c2VycyB1c2UgdGhlIHdyb25nIGV2ZW50IHByb3BlcnRpZXMgdG8gc2lnbmFsIGNtZC9jdHJsIG9uIE9TIFhcbiAgdmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpO1xuICB2YXIgY2FwdHVyZVJpZ2h0Q2xpY2sgPSBnZWNrbyB8fCAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KTtcblxuICAvLyBPcHRpbWl6ZSBzb21lIGNvZGUgd2hlbiB0aGVzZSBmZWF0dXJlcyBhcmUgbm90IHVzZWQuXG4gIHZhciBzYXdSZWFkT25seVNwYW5zID0gZmFsc2UsIHNhd0NvbGxhcHNlZFNwYW5zID0gZmFsc2U7XG5cbiAgLy8gRURJVE9SIENPTlNUUlVDVE9SXG5cbiAgLy8gQSBDb2RlTWlycm9yIGluc3RhbmNlIHJlcHJlc2VudHMgYW4gZWRpdG9yLiBUaGlzIGlzIHRoZSBvYmplY3RcbiAgLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXG5cbiAgZnVuY3Rpb24gQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSkgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxuICAgIGNvcHlPYmooZGVmYXVsdHMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMob3B0aW9ucyk7XG5cbiAgICB2YXIgZG9jID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSBkb2MgPSBuZXcgRG9jKGRvYywgb3B0aW9ucy5tb2RlKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcblxuICAgIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yLmlucHV0U3R5bGVzW29wdGlvbnMuaW5wdXRTdHlsZV0odGhpcyk7XG4gICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCk7XG4gICAgZGlzcGxheS53cmFwcGVyLkNvZGVNaXJyb3IgPSB0aGlzO1xuICAgIHVwZGF0ZUd1dHRlcnModGhpcyk7XG4gICAgdGhlbWVDaGFuZ2VkKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgIHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcIiBDb2RlTWlycm9yLXdyYXBcIjtcbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgIGluaXRTY3JvbGxiYXJzKHRoaXMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGtleU1hcHM6IFtdLCAgLy8gc3RvcmVzIG1hcHMgYWRkZWQgYnkgYWRkS2V5TWFwXG4gICAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxuICAgICAgbW9kZUdlbjogMCwgICAvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxuICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0VkaXRzOiBmYWxzZSwgLy8gdXNlZCB0byBkaXNhYmxlIGVkaXRpbmcgZHVyaW5nIGtleSBoYW5kbGVycyB3aGVuIGluIHJlYWRPbmx5IG1vZGVcbiAgICAgIHBhc3RlSW5jb21pbmc6IGZhbHNlLCBjdXRJbmNvbWluZzogZmFsc2UsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBjbSA9IHRoaXM7XG5cbiAgICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xuICAgIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApO1xuXG4gICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMpO1xuICAgIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCk7XG5cbiAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcblxuICAgIGlmICgob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgfHwgY20uaGFzRm9jdXMoKSlcbiAgICAgIHNldFRpbWVvdXQoYmluZChvbkZvY3VzLCB0aGlzKSwgMjApO1xuICAgIGVsc2VcbiAgICAgIG9uQmx1cih0aGlzKTtcblxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICBvcHRpb25IYW5kbGVyc1tvcHRdKHRoaXMsIG9wdGlvbnNbb3B0XSwgSW5pdCk7XG4gICAgbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkgb3B0aW9ucy5maW5pc2hJbml0KHRoaXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSBpbml0SG9va3NbaV0odGhpcyk7XG4gICAgZW5kT3BlcmF0aW9uKHRoaXMpO1xuICAgIC8vIFN1cHByZXNzIG9wdGltaXplbGVnaWJpbGl0eSBpbiBXZWJraXQsIHNpbmNlIGl0IGJyZWFrcyB0ZXh0XG4gICAgLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cbiAgICBpZiAod2Via2l0ICYmIG9wdGlvbnMubGluZVdyYXBwaW5nICYmXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nID09IFwib3B0aW1pemVsZWdpYmlsaXR5XCIpXG4gICAgICBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFwiYXV0b1wiO1xuICB9XG5cbiAgLy8gRElTUExBWSBDT05TVFJVQ1RPUlxuXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xuICAvLyBhbmQgY29udGVudCBkcmF3aW5nLiBJdCBob2xkcyByZWZlcmVuY2VzIHRvIERPTSBub2RlcyBhbmRcbiAgLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxuXG4gIGZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQpIHtcbiAgICB2YXIgZCA9IHRoaXM7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgLy8gQ292ZXJzIGJvdHRvbS1yaWdodCBzcXVhcmUgd2hlbiBib3RoIHNjcm9sbGJhcnMgYXJlIHByZXNlbnQuXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIik7XG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cbiAgICAvLyBhbmQgaCBzY3JvbGxiYXIgaXMgcHJlc2VudC5cbiAgICBkLmd1dHRlckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKTtcbiAgICBkLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXG4gICAgZC5saW5lRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xuICAgIGQuY3Vyc29yRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO1xuICAgIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGQubGluZVNwYWNlID0gZWx0KFwiZGl2XCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXG4gICAgZC5tb3ZlciA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIFtkLmxpbmVTcGFjZV0sIFwiQ29kZU1pcnJvci1saW5lc1wiKV0sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgIC8vIFNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgYWxsb3dpbmcgc2Nyb2xsaW5nLlxuICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XG4gICAgZC5zaXplcldpZHRoID0gbnVsbDtcbiAgICAvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcbiAgICAvLyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoZVxuICAgIC8vIHNjcm9sbGFibGUgYXJlYSBpcyBiaWcgZW5vdWdoLlxuICAgIGQuaGVpZ2h0Rm9yY2VyID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IFwiICsgc2Nyb2xsZXJHYXAgKyBcInB4OyB3aWR0aDogMXB4O1wiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cbiAgICBkLmd1dHRlcnMgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlcnNcIik7XG4gICAgZC5saW5lR3V0dGVyID0gbnVsbDtcbiAgICAvLyBBY3R1YWwgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIGQuc2Nyb2xsZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO1xuICAgIGQuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKTtcbiAgICAvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxuICAgIGQud3JhcHBlciA9IGVsdChcImRpdlwiLCBbZC5zY3JvbGxiYXJGaWxsZXIsIGQuZ3V0dGVyRmlsbGVyLCBkLnNjcm9sbGVyXSwgXCJDb2RlTWlycm9yXCIpO1xuXG4gICAgLy8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBkLmd1dHRlcnMuc3R5bGUuekluZGV4ID0gLTE7IGQuc2Nyb2xsZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gMDsgfVxuICAgIGlmICghd2Via2l0ICYmICEoZ2Vja28gJiYgbW9iaWxlKSkgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xuXG4gICAgaWYgKHBsYWNlKSB7XG4gICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7XG4gICAgICBlbHNlIHBsYWNlKGQud3JhcHBlcik7XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCByZW5kZXJlZCByYW5nZSAobWF5IGJlIGJpZ2dlciB0aGFuIHRoZSB2aWV3IHdpbmRvdykuXG4gICAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0O1xuICAgIGQucmVwb3J0ZWRWaWV3RnJvbSA9IGQucmVwb3J0ZWRWaWV3VG8gPSBkb2MuZmlyc3Q7XG4gICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVkIGxpbmVzLlxuICAgIGQudmlldyA9IFtdO1xuICAgIGQucmVuZGVyZWRWaWV3ID0gbnVsbDtcbiAgICAvLyBIb2xkcyBpbmZvIGFib3V0IGEgc2luZ2xlIHJlbmRlcmVkIGxpbmUgd2hlbiBpdCB3YXMgcmVuZGVyZWRcbiAgICAvLyBmb3IgbWVhc3VyZW1lbnQsIHdoaWxlIG5vdCBpbiB2aWV3LlxuICAgIGQuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgLy8gRW1wdHkgc3BhY2UgKGluIHBpeGVscykgYWJvdmUgdGhlIHZpZXdcbiAgICBkLnZpZXdPZmZzZXQgPSAwO1xuICAgIGQubGFzdFdyYXBIZWlnaHQgPSBkLmxhc3RXcmFwV2lkdGggPSAwO1xuICAgIGQudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xuXG4gICAgZC5uYXRpdmVCYXJXaWR0aCA9IGQuYmFySGVpZ2h0ID0gZC5iYXJXaWR0aCA9IDA7XG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCB0byBvbmx5IHJlc2l6ZSB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIHdoZW4gbmVjZXNzYXJ5ICh3aGVuXG4gICAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBjcm9zc2VzIGEgYm91bmRhcnkgdGhhdCBtYWtlcyBpdHMgd2lkdGggY2hhbmdlKVxuICAgIGQubGluZU51bVdpZHRoID0gZC5saW5lTnVtSW5uZXJXaWR0aCA9IGQubGluZU51bUNoYXJzID0gbnVsbDtcbiAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXG4gICAgLy8gYWRkZWQuIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZSB3aWRnZXQgYWxpZ25pbmcgaXMgc2tpcHBlZCB3aGVuXG4gICAgLy8gdGhpcyBpcyBmYWxzZS5cbiAgICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xuXG4gICAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcblxuICAgIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxuICAgIC8vIGNhbiBiZSBrZXB0IHN0YXRpYyB3aGVuIHNjcm9sbGluZy5cbiAgICBkLm1heExpbmUgPSBudWxsO1xuICAgIGQubWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCBmb3IgbWVhc3VyaW5nIHdoZWVsIHNjcm9sbGluZyBncmFudWxhcml0eVxuICAgIGQud2hlZWxEWCA9IGQud2hlZWxEWSA9IGQud2hlZWxTdGFydFggPSBkLndoZWVsU3RhcnRZID0gbnVsbDtcblxuICAgIC8vIFRydWUgd2hlbiBzaGlmdCBpcyBoZWxkIGRvd24uXG4gICAgZC5zaGlmdCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcbiAgICAvLyB3YXMgb3BlbmVkLlxuICAgIGQuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuXG4gICAgZC5hY3RpdmVUb3VjaCA9IG51bGw7XG5cbiAgICBpbnB1dC5pbml0KGQpO1xuICB9XG5cbiAgLy8gU1RBVEUgVVBEQVRFU1xuXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cblxuICBmdW5jdGlvbiBsb2FkTW9kZShjbSkge1xuICAgIGNtLmRvYy5tb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKTtcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldE1vZGVTdGF0ZShjbSkge1xuICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICBpZiAobGluZS5zdHlsZXMpIGxpbmUuc3R5bGVzID0gbnVsbDtcbiAgICB9KTtcbiAgICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gICAgY20uc3RhdGUubW9kZUdlbisrO1xuICAgIGlmIChjbS5jdXJPcCkgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBcIlwiO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgZmluZE1heExpbmUoY20pO1xuICAgIH1cbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcbiAgICByZWdDaGFuZ2UoY20pO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dXBkYXRlU2Nyb2xsYmFycyhjbSk7fSwgMTAwKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGltYXRlcyB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgdG8gdXNlIGFzXG4gIC8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xuICAvLyBwcm9wZXJseSBtZWFzdXJhYmxlKS5cbiAgZnVuY3Rpb24gZXN0aW1hdGVIZWlnaHQoY20pIHtcbiAgICB2YXIgdGggPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpO1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHJldHVybiAwO1xuXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XG4gICAgICBpZiAobGluZS53aWRnZXRzKSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZS53aWRnZXRzW2ldLmhlaWdodCkgd2lkZ2V0c0hlaWdodCArPSBsaW5lLndpZGdldHNbaV0uaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAod3JhcHBpbmcpXG4gICAgICAgIHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgKE1hdGguY2VpbChsaW5lLnRleHQubGVuZ3RoIC8gcGVyTGluZSkgfHwgMSkgKiB0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyB0aDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKTtcbiAgICBkb2MuaXRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0KGxpbmUpO1xuICAgICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XG4gICAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLCBcIlwiKSArXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csIFwiIGNtLXMtXCIpO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1dHRlcnNDaGFuZ2VkKGNtKSB7XG4gICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YWxpZ25Ib3Jpem9udGFsbHkoY20pO30sIDIwKTtcbiAgfVxuXG4gIC8vIFJlYnVpbGQgdGhlIGd1dHRlciBlbGVtZW50cywgZW5zdXJlIHRoZSBtYXJnaW4gdG8gdGhlIGxlZnQgb2YgdGhlXG4gIC8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVycyhjbSkge1xuICAgIHZhciBndXR0ZXJzID0gY20uZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGNtLm9wdGlvbnMuZ3V0dGVycztcbiAgICByZW1vdmVDaGlsZHJlbihndXR0ZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZ3V0dGVyQ2xhc3MgPSBzcGVjc1tpXTtcbiAgICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlciBcIiArIGd1dHRlckNsYXNzKSk7XG4gICAgICBpZiAoZ3V0dGVyQ2xhc3MgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgY20uZGlzcGxheS5saW5lR3V0dGVyID0gZ0VsdDtcbiAgICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gaSA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xuICAgIHZhciB3aWR0aCA9IGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFwicHhcIjtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgYSBsaW5lLCB0YWtpbmcgaW50byBhY2NvdW50XG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxuICAvLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxuICBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBjdXIgPSBmb3VuZC5mcm9tLmxpbmU7XG4gICAgICBsZW4gKz0gZm91bmQuZnJvbS5jaCAtIGZvdW5kLnRvLmNoO1xuICAgIH1cbiAgICBjdXIgPSBsaW5lO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBsZW4gLT0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQuZnJvbS5jaDtcbiAgICAgIGN1ciA9IGZvdW5kLnRvLmxpbmU7XG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQudG8uY2g7XG4gICAgfVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsb25nZXN0IGxpbmUgaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGQubWF4TGluZSA9IGdldExpbmUoZG9jLCBkb2MuZmlyc3QpO1xuICAgIGQubWF4TGluZUxlbmd0aCA9IGxpbmVMZW5ndGgoZC5tYXhMaW5lKTtcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICBkb2MuaXRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgZC5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBndXR0ZXJzIG9wdGlvbnMgY29udGFpbnMgdGhlIGVsZW1lbnRcbiAgLy8gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXG4gIGZ1bmN0aW9uIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKSB7XG4gICAgdmFyIGZvdW5kID0gaW5kZXhPZihvcHRpb25zLmd1dHRlcnMsIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKTtcbiAgICBpZiAoZm91bmQgPT0gLTEgJiYgb3B0aW9ucy5saW5lTnVtYmVycykge1xuICAgICAgb3B0aW9ucy5ndXR0ZXJzID0gb3B0aW9ucy5ndXR0ZXJzLmNvbmNhdChbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKTtcbiAgICB9IGVsc2UgaWYgKGZvdW5kID4gLTEgJiYgIW9wdGlvbnMubGluZU51bWJlcnMpIHtcbiAgICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKTtcbiAgICAgIG9wdGlvbnMuZ3V0dGVycy5zcGxpY2UoZm91bmQsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNDUk9MTEJBUlNcblxuICAvLyBQcmVwYXJlIERPTSByZWFkcyBuZWVkZWQgdG8gdXBkYXRlIHRoZSBzY3JvbGxiYXJzLiBEb25lIGluIG9uZVxuICAvLyBzaG90IHRvIG1pbmltaXplIHVwZGF0ZS9tZWFzdXJlIHJvdW5kdHJpcHMuXG4gIGZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBndXR0ZXJXID0gZC5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBkb2NIID0gTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRIZWlnaHQ6IGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgdmlld0hlaWdodDogZC53cmFwcGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcbiAgICAgIHZpZXdXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRoLFxuICAgICAgYmFyTGVmdDogY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGd1dHRlclcgOiAwLFxuICAgICAgZG9jSGVpZ2h0OiBkb2NILFxuICAgICAgc2Nyb2xsSGVpZ2h0OiBkb2NIICsgc2Nyb2xsR2FwKGNtKSArIGQuYmFySGVpZ2h0LFxuICAgICAgbmF0aXZlQmFyV2lkdGg6IGQubmF0aXZlQmFyV2lkdGgsXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBOYXRpdmVTY3JvbGxiYXJzKHBsYWNlLCBzY3JvbGwsIGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJtaW4td2lkdGg6IDFweFwiKV0sIFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpO1xuICAgIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgcGxhY2UodmVydCk7IHBsYWNlKGhvcml6KTtcblxuICAgIG9uKHZlcnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHZlcnQuY2xpZW50SGVpZ2h0KSBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFwidmVydGljYWxcIik7XG4gICAgfSk7XG4gICAgb24oaG9yaXosIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSBzY3JvbGwoaG9yaXouc2Nyb2xsTGVmdCwgXCJob3Jpem9udGFsXCIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jaGVja2VkT3ZlcmxheSA9IGZhbHNlO1xuICAgIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXCIxOHB4XCI7XG4gIH1cblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZSA9IGNvcHlPYmooe1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obWVhc3VyZSkge1xuICAgICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcbiAgICAgIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoO1xuXG4gICAgICBpZiAobmVlZHNWKSB7XG4gICAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLnZlcnQuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XG4gICAgICAgIHZhciB0b3RhbEhlaWdodCA9IG1lYXN1cmUudmlld0hlaWdodCAtIChuZWVkc0ggPyBzV2lkdGggOiAwKTtcbiAgICAgICAgLy8gQSBidWcgaW4gSUU4IGNhbiBjYXVzZSB0aGlzIHZhbHVlIHRvIGJlIG5lZ2F0aXZlLCBzbyBndWFyZCBpdC5cbiAgICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cbiAgICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRzSCkge1xuICAgICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgICAgICB2YXIgdG90YWxXaWR0aCA9IG1lYXN1cmUudmlld1dpZHRoIC0gbWVhc3VyZS5iYXJMZWZ0IC0gKG5lZWRzViA/IHNXaWR0aCA6IDApO1xuICAgICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxuICAgICAgICAgIChtZWFzdXJlLnNjcm9sbFdpZHRoIC0gbWVhc3VyZS5jbGllbnRXaWR0aCArIHRvdGFsV2lkdGgpICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGVja2VkT3ZlcmxheSAmJiBtZWFzdXJlLmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgICAgaWYgKHNXaWR0aCA9PSAwKSB0aGlzLm92ZXJsYXlIYWNrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tlZE92ZXJsYXkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9O1xuICAgIH0sXG4gICAgc2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgdGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gcG9zO1xuICAgIH0sXG4gICAgc2V0U2Nyb2xsVG9wOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgdGhpcy52ZXJ0LnNjcm9sbFRvcCA9IHBvcztcbiAgICB9LFxuICAgIG92ZXJsYXlIYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcIjEycHhcIiA6IFwiMThweFwiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSB3O1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGJhck1vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGVfdGFyZ2V0KGUpICE9IHNlbGYudmVydCAmJiBlX3RhcmdldChlKSAhPSBzZWxmLmhvcml6KVxuICAgICAgICAgIG9wZXJhdGlvbihzZWxmLmNtLCBvbk1vdXNlRG93bikoZSk7XG4gICAgICB9O1xuICAgICAgb24odGhpcy52ZXJ0LCBcIm1vdXNlZG93blwiLCBiYXJNb3VzZURvd24pO1xuICAgICAgb24odGhpcy5ob3JpeiwgXCJtb3VzZWRvd25cIiwgYmFyTW91c2VEb3duKTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmhvcml6LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KTtcbiAgICB9XG4gIH0sIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBOdWxsU2Nyb2xsYmFycygpIHt9XG5cbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlID0gY29weU9iaih7XG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHtib3R0b206IDAsIHJpZ2h0OiAwfTsgfSxcbiAgICBzZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbigpIHt9LFxuICAgIHNldFNjcm9sbFRvcDogZnVuY3Rpb24oKSB7fSxcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7fVxuICB9LCBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUpO1xuXG4gIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSB7XCJuYXRpdmVcIjogTmF0aXZlU2Nyb2xsYmFycywgXCJudWxsXCI6IE51bGxTY3JvbGxiYXJzfTtcblxuICBmdW5jdGlvbiBpbml0U2Nyb2xsYmFycyhjbSkge1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMpIHtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5jbGVhcigpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcbiAgICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7XG4gICAgfVxuXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24obm9kZSkge1xuICAgICAgY20uZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShub2RlLCBjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7XG4gICAgICAvLyBQcmV2ZW50IGNsaWNrcyBpbiB0aGUgc2Nyb2xsYmFycyBmcm9tIGtpbGxpbmcgZm9jdXNcbiAgICAgIG9uKG5vZGUsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTtcbiAgICAgIH0pO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgfSwgZnVuY3Rpb24ocG9zLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PSBcImhvcml6b250YWxcIikgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTtcbiAgICAgIGVsc2Ugc2V0U2Nyb2xsVG9wKGNtLCBwb3MpO1xuICAgIH0sIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xuICAgIGlmICghbWVhc3VyZSkgbWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICB2YXIgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGgsIHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcbiAgICAgIGlmIChzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtcbiAgICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlLXN5bmNocm9uaXplIHRoZSBmYWtlIHNjcm9sbGJhcnMgd2l0aCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlXG4gIC8vIGNvbnRlbnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xuXG4gICAgZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAoZC5iYXJXaWR0aCA9IHNpemVzLnJpZ2h0KSArIFwicHhcIjtcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXCJweFwiO1xuXG4gICAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcInB4XCI7XG4gICAgfSBlbHNlIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIGlmIChzaXplcy5ib3R0b20gJiYgY20ub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciAmJiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUud2lkdGggPSBtZWFzdXJlLmd1dHRlcldpZHRoICsgXCJweFwiO1xuICAgIH0gZWxzZSBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGxpbmVzIHRoYXQgYXJlIHZpc2libGUgaW4gYSBnaXZlbiB2aWV3cG9ydCAoZGVmYXVsdHNcbiAgLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcbiAgLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MsIHZpZXdwb3J0KSB7XG4gICAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XG4gICAgdmFyIGJvdHRvbSA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LmJvdHRvbSAhPSBudWxsID8gdmlld3BvcnQuYm90dG9tIDogdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgIHZhciBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgdG9wKSwgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBib3R0b20pO1xuICAgIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcbiAgICAvLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cbiAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XG4gICAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7XG4gICAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcbiAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XG4gICAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5taW4oZW5zdXJlVG8sIGRvYy5sYXN0TGluZSgpKSA+PSB0bykge1xuICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIHRvID0gZW5zdXJlVG87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9O1xuICB9XG5cbiAgLy8gTElORSBOVU1CRVJTXG5cbiAgLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcbiAgLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXG4gIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHJldHVybjtcbiAgICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXCJweFwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgJiYgdmlld1tpXS5ndXR0ZXIpXG4gICAgICAgIHZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGU7XG4gICAgICBpZiAoYWxpZ24pIGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXG4gICAgICAgIGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcbiAgICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcbiAgLy8gc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2l6ZS4gUmV0dXJucyB0cnVlIHdoZW4gYW4gdXBkYXRlXG4gIC8vIGlzIG5lZWRlZC5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZU51bWJlcnMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGFzdC5sZW5ndGggIT0gZGlzcGxheS5saW5lTnVtQ2hhcnMpIHtcbiAgICAgIHZhciB0ZXN0ID0gZGlzcGxheS5tZWFzdXJlLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIGxhc3QpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO1xuICAgICAgdmFyIGlubmVyVyA9IHRlc3QuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgcGFkZGluZyA9IHRlc3Qub2Zmc2V0V2lkdGggLSBpbm5lclc7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZykgKyAxO1xuICAgICAgZGlzcGxheS5saW5lTnVtV2lkdGggPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgcGFkZGluZztcbiAgICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTE7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBkaXNwbGF5LmxpbmVOdW1XaWR0aCArIFwicHhcIjtcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcbiAgICByZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKTtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcbiAgLy8gcmVzdWx0LlxuICBmdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgfVxuXG4gIC8vIERJU1BMQVkgRFJBV0lOR1xuXG4gIGZ1bmN0aW9uIERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0LCBmb3JjZSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcblxuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAvLyBTdG9yZSBzb21lIHZhbHVlcyB0aGF0IHdlJ2xsIG5lZWQgbGF0ZXIgKGJ1dCBkb24ndCB3YW50IHRvIGZvcmNlIGEgcmVsYXlvdXQgZm9yKVxuICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICB0aGlzLmVkaXRvcklzSGlkZGVuID0gIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLndyYXBwZXJIZWlnaHQgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgIHRoaXMud3JhcHBlcldpZHRoID0gZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgIHRoaXMub2xkRGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoKGNtKTtcbiAgICB0aGlzLmZvcmNlID0gZm9yY2U7XG4gICAgdGhpcy5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgfVxuXG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcbiAgICAgIHRoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKTtcbiAgfTtcbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHNpZ25hbC5hcHBseShudWxsLCB0aGlzLmV2ZW50c1tpXSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xuICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLWRpc3BsYXkubmF0aXZlQmFyV2lkdGggKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRG9lcyB0aGUgYWN0dWFsIHVwZGF0aW5nIG9mIHRoZSBsaW5lIGRpc3BsYXkuIEJhaWxzIG91dFxuICAvLyAocmV0dXJuaW5nIGZhbHNlKSB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgZG9uZSBhbmQgZm9yY2VkIGlzXG4gIC8vIGZhbHNlLlxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuXG4gICAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxuICAgICAgICB1cGRhdGUudmlzaWJsZS5mcm9tID49IGRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSAmJlxuICAgICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXG4gICAgdmFyIGVuZCA9IGRvYy5maXJzdCArIGRvYy5zaXplO1xuICAgIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdCk7XG4gICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTtcbiAgICBpZiAoZGlzcGxheS52aWV3VG8gPiB0byAmJiBkaXNwbGF5LnZpZXdUbyAtIHRvIDwgMjApIHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7XG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XG4gICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XG4gICAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW50ID0gZnJvbSAhPSBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvICE9IGRpc3BsYXkudmlld1RvIHx8XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKTtcblxuICAgIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpO1xuICAgIC8vIFBvc2l0aW9uIHRoZSBtb3ZlciBkaXYgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFwicHhcIjtcblxuICAgIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKTtcbiAgICBpZiAoIWRpZmZlcmVudCAmJiB0b1VwZGF0ZSA9PSAwICYmICF1cGRhdGUuZm9yY2UgJiYgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBGb3IgYmlnIGNoYW5nZXMsIHdlIGhpZGUgdGhlIGVuY2xvc2luZyBlbGVtZW50IGR1cmluZyB0aGVcbiAgICAvLyB1cGRhdGUsIHNpbmNlIHRoYXQgc3BlZWRzIHVwIHRoZSBvcGVyYXRpb25zIG9uIG1vc3QgYnJvd3NlcnMuXG4gICAgdmFyIGZvY3VzZWQgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHBhdGNoRGlzcGxheShjbSwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycywgdXBkYXRlLmRpbXMpO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9IGRpc3BsYXkudmlldztcbiAgICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxuICAgIC8vIGhpZGRlbiBvciB1cGRhdGVkLCBpZiBzbyByZS1mb2N1cyBpdC5cbiAgICBpZiAoZm9jdXNlZCAmJiBhY3RpdmVFbHQoKSAhPSBmb2N1c2VkICYmIGZvY3VzZWQub2Zmc2V0SGVpZ2h0KSBmb2N1c2VkLmZvY3VzKCk7XG5cbiAgICAvLyBQcmV2ZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycyBmcm9tIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtcbiAgICBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gMDtcblxuICAgIGlmIChkaWZmZXJlbnQpIHtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBXaWR0aCA9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSkge1xuICAgIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcbiAgICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsKVxuICAgICAgICAgIHZpZXdwb3J0ID0ge3RvcDogTWF0aC5taW4oY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpIC0gZGlzcGxheUhlaWdodChjbSksIHZpZXdwb3J0LnRvcCl9O1xuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XG4gICAgICAgIC8vIGFjdHVhbGx5IGNvdmVyaW5nIHRoZSB2aWV3cG9ydC4gS2VlcCBsb29waW5nIHVudGlsIGl0IGRvZXMuXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIGJyZWFrO1xuICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ1cGRhdGVcIiwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdGcm9tICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSB8fCBjbS5kaXNwbGF5LnZpZXdUbyAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKSB7XG4gICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInZpZXdwb3J0Q2hhbmdlXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XG4gICAgICBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvID0gY20uZGlzcGxheS52aWV3VG87XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgdmlld3BvcnQpIHtcbiAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcbiAgICBpZiAodXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERvY3VtZW50SGVpZ2h0KGNtLCBtZWFzdXJlKSB7XG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICB2YXIgdG90YWwgPSBtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIGNtLmRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLnRvcCA9IHRvdGFsICsgXCJweFwiO1xuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBNYXRoLm1heCh0b3RhbCArIHNjcm9sbEdhcChjbSksIG1lYXN1cmUuY2xpZW50SGVpZ2h0KSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbiAgZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCBoZWlnaHQ7XG4gICAgICBpZiAoY3VyLmhpZGRlbikgY29udGludWU7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcbiAgICAgICAgcHJldkJvdHRvbSA9IGJvdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcbiAgICAgIGlmIChoZWlnaHQgPCAyKSBoZWlnaHQgPSB0ZXh0SGVpZ2h0KGRpc3BsYXkpO1xuICAgICAgaWYgKGRpZmYgPiAuMDAxIHx8IGRpZmYgPCAtLjAwMSkge1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xuICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICBpZiAoY3VyLnJlc3QpIGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXG4gICAgICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5yZXN0W2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gIC8vIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZVdpZGdldEhlaWdodChsaW5lKSB7XG4gICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpXG4gICAgICBsaW5lLndpZGdldHNbaV0uaGVpZ2h0ID0gbGluZS53aWRnZXRzW2ldLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxuICAvLyB2aWV3LCBzbyB0aGF0IHdlIGRvbid0IGludGVybGVhdmUgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgRE9NLlxuICBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge307XG4gICAgdmFyIGd1dHRlckxlZnQgPSBkLmd1dHRlcnMuY2xpZW50TGVmdDtcbiAgICBmb3IgKHZhciBuID0gZC5ndXR0ZXJzLmZpcnN0Q2hpbGQsIGkgPSAwOyBuOyBuID0gbi5uZXh0U2libGluZywgKytpKSB7XG4gICAgICBsZWZ0W2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0O1xuICAgICAgd2lkdGhbY20ub3B0aW9ucy5ndXR0ZXJzW2ldXSA9IG4uY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxuICAgICAgICAgICAgZ3V0dGVyVG90YWxXaWR0aDogZC5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgZ3V0dGVyTGVmdDogbGVmdCxcbiAgICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRofTtcbiAgfVxuXG4gIC8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4gIC8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcbiAgLy8gZGF0ZS5cbiAgZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xuICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gZGlzcGxheS52aWV3LCBsaW5lTiA9IGRpc3BsYXkudmlld0Zyb207XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcbiAgICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3LmhpZGRlbikge1xuICAgICAgfSBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcbiAgICAgICAgdmFyIG5vZGUgPSBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XG4gICAgICB9IGVsc2UgeyAvLyBBbHJlYWR5IGRyYXduXG4gICAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgY3VyID0gcm0oY3VyKTtcbiAgICAgICAgdmFyIHVwZGF0ZU51bWJlciA9IGxpbmVOdW1iZXJzICYmIHVwZGF0ZU51bWJlcnNGcm9tICE9IG51bGwgJiZcbiAgICAgICAgICB1cGRhdGVOdW1iZXJzRnJvbSA8PSBsaW5lTiAmJiBsaW5lVmlldy5saW5lTnVtYmVyO1xuICAgICAgICBpZiAobGluZVZpZXcuY2hhbmdlcykge1xuICAgICAgICAgIGlmIChpbmRleE9mKGxpbmVWaWV3LmNoYW5nZXMsIFwiZ3V0dGVyXCIpID4gLTEpIHVwZGF0ZU51bWJlciA9IGZhbHNlO1xuICAgICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtcbiAgICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbGluZVZpZXcubm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XG4gICAgfVxuICAgIHdoaWxlIChjdXIpIGN1ciA9IHJtKGN1cik7XG4gIH1cblxuICAvLyBXaGVuIGFuIGFzcGVjdCBvZiBhIGxpbmUgY2hhbmdlcywgYSBzdHJpbmcgaXMgYWRkZWQgdG9cbiAgLy8gbGluZVZpZXcuY2hhbmdlcy4gVGhpcyB1cGRhdGVzIHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZSBsaW5lJ3NcbiAgLy8gRE9NIHN0cnVjdHVyZS5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHR5cGUgPSBsaW5lVmlldy5jaGFuZ2VzW2pdO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ0ZXh0XCIpIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldyk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiY2xhc3NcIikgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIndpZGdldFwiKSB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgIH1cbiAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICBsaW5lVmlldy5ub2RlID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcbiAgICAgICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQmFja2dyb3VuZChsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICBpZiAoY2xzKSBjbHMgKz0gXCIgQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZFwiO1xuICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoY2xzKSBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNscztcbiAgICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsOyB9XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcImRpdlwiLCBudWxsLCBjbHMpLCB3cmFwLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBwZXIgYXJvdW5kIGJ1aWxkTGluZUNvbnRlbnQgd2hpY2ggd2lsbCByZXVzZSB0aGUgc3RydWN0dXJlXG4gIC8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxuICBmdW5jdGlvbiBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xuICAgICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUgPSBleHQubWVhc3VyZTtcbiAgICAgIHJldHVybiBleHQuYnVpbHQ7XG4gICAgfVxuICAgIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gIH1cblxuICAvLyBSZWRyYXcgdGhlIGxpbmUncyB0ZXh0LiBJbnRlcmFjdHMgd2l0aCB0aGUgYmFja2dyb3VuZCBhbmQgdGV4dFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcbiAgLy8gY2xhc3Nlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XG4gICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpO1xuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IGNscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldykge1xuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpXG4gICAgICBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7XG4gICAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxuICAgICAgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiO1xuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbWFya2VycyA9IGxpbmVWaWV3LmxpbmUuZ3V0dGVyTWFya2VycztcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyB8fCBtYXJrZXJzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLCBcImxlZnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHg7IHdpZHRoOiBcIiArIGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIik7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoZ3V0dGVyV3JhcCk7XG4gICAgICB3cmFwLmluc2VydEJlZm9yZShndXR0ZXJXcmFwLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKVxuICAgICAgICBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSlcbiAgICAgICAgbGluZVZpZXcubGluZU51bWJlciA9IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgZWx0KFwiZGl2XCIsIGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pLFxuICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcbiAgICAgICAgICAgICAgXCJsZWZ0OiBcIiArIGRpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0gKyBcInB4OyB3aWR0aDogXCJcbiAgICAgICAgICAgICAgKyBjbS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgXCJweFwiKSk7XG4gICAgICBpZiAobWFya2VycykgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGlkID0gY20ub3B0aW9ucy5ndXR0ZXJzW2tdLCBmb3VuZCA9IG1hcmtlcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hcmtlcnNbaWRdO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2ZvdW5kXSwgXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIiwgXCJsZWZ0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltcy5ndXR0ZXJMZWZ0W2lkXSArIFwicHg7IHdpZHRoOiBcIiArIGRpbXMuZ3V0dGVyV2lkdGhbaWRdICsgXCJweFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKGxpbmVWaWV3LmFsaWduYWJsZSkgbGluZVZpZXcuYWxpZ25hYmxlID0gbnVsbDtcbiAgICBmb3IgKHZhciBub2RlID0gbGluZVZpZXcubm9kZS5maXJzdENoaWxkLCBuZXh0OyBub2RlOyBub2RlID0gbmV4dCkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKG5vZGUuY2xhc3NOYW1lID09IFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIpXG4gICAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gIH1cblxuICAvLyBCdWlsZCBhIGxpbmUncyBET00gcmVwcmVzZW50YXRpb24gZnJvbSBzY3JhdGNoXG4gIGZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MpIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgIGlmIChidWlsdC50ZXh0Q2xhc3MpIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTtcbiAgICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGU7XG4gIH1cblxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcucmVzdFtpXSwgbGluZVZpZXcsIGRpbXMsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lLCBsaW5lVmlldywgZGltcywgYWxsb3dBYm92ZSkge1xuICAgIGlmICghbGluZS53aWRnZXRzKSByZXR1cm47XG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpIDwgd3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3aWRnZXQgPSB3c1tpXSwgbm9kZSA9IGVsdChcImRpdlwiLCBbd2lkZ2V0Lm5vZGVdLCBcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKTtcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xuICAgICAgaWYgKGFsbG93QWJvdmUgJiYgd2lkZ2V0LmFib3ZlKVxuICAgICAgICB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7XG4gICAgICBlbHNlXG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgICAgIChsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKTtcbiAgICAgIHZhciB3aWR0aCA9IGRpbXMud3JhcHBlcldpZHRoO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFwicHhcIjtcbiAgICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nTGVmdCA9IGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9XG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA1O1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBPQkpFQ1RcblxuICAvLyBBIFBvcyBpbnN0YW5jZSByZXByZXNlbnRzIGEgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0LlxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3MgPSBmdW5jdGlvbihsaW5lLCBjaCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCk7XG4gICAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbiAgLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxuICB2YXIgY21wID0gQ29kZU1pcnJvci5jbXBQb3MgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2g7IH07XG5cbiAgZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpO31cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYTsgfVxuICBmdW5jdGlvbiBtaW5Qb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiOyB9XG5cbiAgLy8gSU5QVVQgSEFORExJTkdcblxuICBmdW5jdGlvbiBlbnN1cmVGb2N1cyhjbSkge1xuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IG9uRm9jdXMoY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlYWRPbmx5KGNtKSB7XG4gICAgcmV0dXJuIGNtLm9wdGlvbnMucmVhZE9ubHkgfHwgY20uZG9jLmNhbnRFZGl0O1xuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGJlIHNldCB0byBhbiBhcnJheSBvZiBzdHJpbmdzIHdoZW4gY29weWluZywgc28gdGhhdCxcbiAgLy8gd2hlbiBwYXN0aW5nLCB3ZSBrbm93IHdoYXQga2luZCBvZiBzZWxlY3Rpb25zIHRoZSBjb3BpZWQgdGV4dFxuICAvLyB3YXMgbWFkZSBvdXQgb2YuXG4gIHZhciBsYXN0Q29waWVkID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgaWYgKCFzZWwpIHNlbCA9IGRvYy5zZWw7XG5cbiAgICB2YXIgcGFzdGUgPSBjbS5zdGF0ZS5wYXN0ZUluY29taW5nIHx8IG9yaWdpbiA9PSBcInBhc3RlXCI7XG4gICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXMoaW5zZXJ0ZWQpLCBtdWx0aVBhc3RlID0gbnVsbDtcbiAgICAvLyBXaGVuIHBhc2luZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxuICAgIGlmIChwYXN0ZSAmJiBzZWwucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQuam9pbihcIlxcblwiKSA9PSBpbnNlcnRlZClcbiAgICAgICAgbXVsdGlQYXN0ZSA9IHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC5sZW5ndGggPT0gMCAmJiBtYXAobGFzdENvcGllZCwgc3BsaXRMaW5lcyk7XG4gICAgICBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoKVxuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24obCkgeyByZXR1cm4gW2xdOyB9KTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxuICAgIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgICAgICBmcm9tID0gUG9zKGZyb20ubGluZSwgZnJvbS5jaCAtIGRlbGV0ZWQpO1xuICAgICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXG4gICAgICAgICAgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpICUgbXVsdGlQYXN0ZS5sZW5ndGhdIDogdGV4dExpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luIHx8IChwYXN0ZSA/IFwicGFzdGVcIiA6IGNtLnN0YXRlLmN1dEluY29taW5nID8gXCJjdXRcIiA6IFwiK2lucHV0XCIpfTtcbiAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJpbnB1dFJlYWRcIiwgY20sIGNoYW5nZUV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkICYmICFwYXN0ZSlcbiAgICAgIHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpO1xuXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgY20uY3VyT3AudXBkYXRlSW5wdXQgPSB1cGRhdGVJbnB1dDtcbiAgICBjbS5jdXJPcC50eXBpbmcgPSB0cnVlO1xuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSwgY20pIHtcbiAgICB2YXIgcGFzdGVkID0gZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICBpZiAocGFzdGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHsgYXBwbHlUZXh0SW5wdXQoY20sIHBhc3RlZCwgMCwgbnVsbCwgXCJwYXN0ZVwiKTsgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB7XG4gICAgLy8gV2hlbiBhbiAnZWxlY3RyaWMnIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgaW1tZWRpYXRlbHkgdHJpZ2dlciBhIHJlaW5kZW50XG4gICAgaWYgKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgfHwgIWNtLm9wdGlvbnMuc21hcnRJbmRlbnQpIHJldHVybjtcbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbDtcblxuICAgIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPiAxMDAgfHwgKGkgJiYgc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lID09IHJhbmdlLmhlYWQubGluZSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQocmFuZ2UuaGVhZCk7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChtb2RlLmVsZWN0cmljQ2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb2RlLmVsZWN0cmljQ2hhcnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xuICAgICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dCkge1xuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLCByYW5nZS5oZWFkLmNoKSkpXG4gICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFwic21hcnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZW50ZWQpIHNpZ25hbExhdGVyKGNtLCBcImVsZWN0cmljSW5wdXRcIiwgY20sIHJhbmdlLmhlYWQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcbiAgICB2YXIgdGV4dCA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcbiAgICAgIHZhciBsaW5lUmFuZ2UgPSB7YW5jaG9yOiBQb3MobGluZSwgMCksIGhlYWQ6IFBvcyhsaW5lICsgMSwgMCl9O1xuICAgICAgcmFuZ2VzLnB1c2gobGluZVJhbmdlKTtcbiAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHQ6IHRleHQsIHJhbmdlczogcmFuZ2VzfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQpIHtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsIFwiZmFsc2VcIik7XG4gIH1cblxuICAvLyBURVhUQVJFQSBJTlBVVCBTVFlMRVxuXG4gIGZ1bmN0aW9uIFRleHRhcmVhSW5wdXQoY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgLy8gU2VlIGlucHV0LnBvbGwgYW5kIGlucHV0LnJlc2V0XG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXG4gICAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXG4gICAgLy8gcG9sbGluZyBpbnRlbnNpdmVseS5cbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgLy8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgLy8gVHJhY2tzIHdoZW4gaW5wdXQucmVzZXQgaGFzIHB1bnRlZCB0byBqdXN0IHB1dHRpbmcgYSBzaG9ydFxuICAgIC8vIHN0cmluZyBpbnRvIHRoZSB0ZXh0YXJlYSBpbnN0ZWFkIG9mIHRoZSBmdWxsIHNlbGVjdGlvbi5cbiAgICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxuICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICB2YXIgZGl2ID0gZWx0KFwiZGl2XCIsIFt0ZV0sIG51bGwsIFwib3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogM3B4OyBoZWlnaHQ6IDBweDtcIik7XG4gICAgLy8gVGhlIHRleHRhcmVhIGlzIGtlcHQgcG9zaXRpb25lZCBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCB0aGVcbiAgICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXG4gICAgLy8gb3VyIGZha2UgY3Vyc29yIG91dCBvZiB2aWV3LiBPbiB3ZWJraXQsIHdoZW4gd3JhcD1vZmYsIHBhc3RlIGlzXG4gICAgLy8gdmVyeSBzbG93LiBTbyBtYWtlIHRoZSBhcmVhIHdpZGUgaW5zdGVhZC5cbiAgICBpZiAod2Via2l0KSB0ZS5zdHlsZS53aWR0aCA9IFwiMTAwMHB4XCI7XG4gICAgZWxzZSB0ZS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsIFwib2ZmXCIpO1xuICAgIC8vIElmIGJvcmRlcjogMDsgLS0gaU9TIGZhaWxzIHRvIG9wZW4ga2V5Ym9hcmQgKGlzc3VlICMxMjg3KVxuICAgIGlmIChpb3MpIHRlLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIGJsYWNrXCI7XG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlID0gY29weU9iaih7XG4gICAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSB0aGlzLmNtO1xuXG4gICAgICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcbiAgICAgIHZhciBkaXYgPSB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xuICAgICAgLy8gVGhlIHNlbWloaWRkZW4gdGV4dGFyZWEgdGhhdCBpcyBmb2N1c2VkIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgICAgLy8gZm9jdXNlZCwgYW5kIHJlY2VpdmVzIGlucHV0LlxuICAgICAgdmFyIHRlID0gdGhpcy50ZXh0YXJlYSA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShkaXYsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgICAgLy8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXG4gICAgICBpZiAoaW9zKSB0ZS5zdHlsZS53aWR0aCA9IFwiMHB4XCI7XG5cbiAgICAgIG9uKHRlLCBcImlucHV0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIGlucHV0Lmhhc1NlbGVjdGlvbikgaW5wdXQuaGFzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaW5wdXQucG9sbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGhhbmRsZVBhc3RlKGUsIGNtKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XG4gICAgICAgIGlucHV0LmZhc3RQb2xsKCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xuICAgICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIGxhc3RDb3BpZWQgPSBjbS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgaWYgKGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICAgICAgICBpbnB1dC5pbmFjY3VyYXRlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgICAgbGFzdENvcGllZCA9IHJhbmdlcy50ZXh0O1xuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCBudWxsLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICAgICAgICB0ZS52YWx1ZSA9IHJhbmdlcy50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgY20uc3RhdGUuY3V0SW5jb21pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb24odGUsIFwiY3V0XCIsIHByZXBhcmVDb3B5Q3V0KTtcbiAgICAgIG9uKHRlLCBcImNvcHlcIiwgcHJlcGFyZUNvcHlDdXQpO1xuXG4gICAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcInBhc3RlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHJldHVybjtcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxuICAgICAgb24oZGlzcGxheS5saW5lU3BhY2UsIFwic2VsZWN0c3RhcnRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB9KTtcblxuICAgICAgb24odGUsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBvbih0ZSwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykge1xuICAgICAgICAgIGlucHV0LnBvbGwoKTtcbiAgICAgICAgICBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHJlcGFyZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24oY20pO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xuICAgICAgaWYgKGNtLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xuICAgICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3JkcyhjbSwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpO1xuICAgICAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24oZHJhd24pIHtcbiAgICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XG4gICAgICBpZiAoZHJhd24udGVUb3AgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcbiAgICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHR5cGluZykge1xuICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nKSByZXR1cm47XG4gICAgICB2YXIgbWluaW1hbCwgc2VsZWN0ZWQsIGNtID0gdGhpcy5jbSwgZG9jID0gY20uZG9jO1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgICAgbWluaW1hbCA9IGhhc0NvcHlFdmVudCAmJlxuICAgICAgICAgIChyYW5nZS50bygpLmxpbmUgLSByYW5nZS5mcm9tKCkubGluZSA+IDEwMCB8fCAoc2VsZWN0ZWQgPSBjbS5nZXRTZWxlY3Rpb24oKSkubGVuZ3RoID4gMTAwMCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gbWluaW1hbCA/IFwiLVwiIDogc2VsZWN0ZWQgfHwgY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSBjb250ZW50O1xuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgc2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSk7XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAoIXR5cGluZykge1xuICAgICAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBtaW5pbWFsO1xuICAgIH0sXG5cbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRleHRhcmVhOyB9LFxuXG4gICAgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiICYmICghbW9iaWxlIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMudGV4dGFyZWEpKSB7XG4gICAgICAgIHRyeSB7IHRoaXMudGV4dGFyZWEuZm9jdXMoKTsgfVxuICAgICAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBibHVyOiBmdW5jdGlvbigpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCk7IH0sXG5cbiAgICByZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDA7XG4gICAgfSxcblxuICAgIHJlY2VpdmVkRm9jdXM6IGZ1bmN0aW9uKCkgeyB0aGlzLnNsb3dQb2xsKCk7IH0sXG5cbiAgICAvLyBQb2xsIGZvciBpbnB1dCBjaGFuZ2VzLCB1c2luZyB0aGUgbm9ybWFsIHJhdGUgb2YgcG9sbGluZy4gVGhpc1xuICAgIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgc2xvd1BvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICAgIGlmIChpbnB1dC5wb2xsaW5nRmFzdCkgcmV0dXJuO1xuICAgICAgaW5wdXQucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0LnBvbGwoKTtcbiAgICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIGlucHV0LnNsb3dQb2xsKCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhbiBldmVudCBoYXMganVzdCBjb21lIGluIHRoYXQgaXMgbGlrZWx5IHRvIGFkZCBvciBjaGFuZ2VcbiAgICAvLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxuICAgIGZhc3RQb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzO1xuICAgICAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlO1xuICAgICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBpbnB1dC5wb2xsKCk7XG4gICAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApO31cbiAgICAgICAgZWxzZSB7aW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTsgaW5wdXQuc2xvd1BvbGwoKTt9XG4gICAgICB9XG4gICAgICBpbnB1dC5wb2xsaW5nLnNldCgyMCwgcCk7XG4gICAgfSxcblxuICAgIC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxuICAgIC8vIFdoZW4gc29tZXRoaW5nIGlzIHNlbGVjdGVkLCBpdCBpcyBwcmVzZW50IGluIHRoZSB0ZXh0YXJlYSwgYW5kXG4gICAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcbiAgICAvLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxuICAgIC8vIHNlZW4gdGV4dCAoY2FuIGJlIGVtcHR5KSwgd2hpY2ggaXMgc3RvcmVkIGluIHByZXZJbnB1dCAod2UgbXVzdFxuICAgIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cbiAgICBwb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjbSA9IHRoaXMuY20sIGlucHV0ID0gdGhpcy50ZXh0YXJlYSwgcHJldklucHV0ID0gdGhpcy5wcmV2SW5wdXQ7XG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xuICAgICAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxuICAgICAgLy8gd2lsbCBiZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGEgbG90IG9mIHRleHQgaW4gdGhlIHRleHRhcmVhLFxuICAgICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHxcbiAgICAgICAgICAoaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0KSB8fFxuICAgICAgICAgIGlzUmVhZE9ubHkoY20pIHx8IGNtLm9wdGlvbnMuZGlzYWJsZUlucHV0IHx8IGNtLnN0YXRlLmtleVNlcSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgdGV4dCA9IGlucHV0LnZhbHVlO1xuICAgICAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxuICAgICAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXG4gICAgICAvLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXG4gICAgICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMuaGFzU2VsZWN0aW9uID09PSB0ZXh0IHx8XG4gICAgICAgICAgbWFjICYmIC9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChmaXJzdCA9PSAweDIwMGIgJiYgIXByZXZJbnB1dCkgcHJldklucHV0ID0gXCJcXHUyMDBiXCI7XG4gICAgICAgIGlmIChmaXJzdCA9PSAweDIxZGEpIHsgdGhpcy5yZXNldCgpOyByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIik7IH1cbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgdGhlIHBhcnQgb2YgdGhlIGlucHV0IHRoYXQgaXMgYWN0dWFsbHkgbmV3XG4gICAgICB2YXIgc2FtZSA9IDAsIGwgPSBNYXRoLm1pbihwcmV2SW5wdXQubGVuZ3RoLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSArK3NhbWU7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHBseVRleHRJbnB1dChjbSwgdGV4dC5zbGljZShzYW1lKSwgcHJldklucHV0Lmxlbmd0aCAtIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHNlbGYuY29tcG9zaW5nID8gXCIqY29tcG9zZVwiIDogbnVsbCk7XG5cbiAgICAgICAgLy8gRG9uJ3QgbGVhdmUgbG9uZyB0ZXh0IGluIHRoZSB0ZXh0YXJlYSwgc2luY2UgaXQgbWFrZXMgZnVydGhlciBwb2xsaW5nIHNsb3dcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgaW5wdXQudmFsdWUgPSBzZWxmLnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICAgIGVsc2Ugc2VsZi5wcmV2SW5wdXQgPSB0ZXh0O1xuXG4gICAgICAgIGlmIChzZWxmLmNvbXBvc2luZykge1xuICAgICAgICAgIHNlbGYuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgICAgc2VsZi5jb21wb3NpbmcucmFuZ2UgPSBjbS5tYXJrVGV4dChzZWxmLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZW5zdXJlUG9sbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0ICYmIHRoaXMucG9sbCgpKSB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG9uS2V5UHJlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgdGhpcy5mYXN0UG9sbCgpO1xuICAgIH0sXG5cbiAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcbiAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgIGlmICghcG9zIHx8IHByZXN0bykgcmV0dXJuOyAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXG5cbiAgICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXG4gICAgICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudTtcbiAgICAgIGlmIChyZXNldCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPT0gLTEpXG4gICAgICAgIG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICAgIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0O1xuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDsgdG9wOiBcIiArIChlLmNsaWVudFkgLSA1KSArXG4gICAgICAgIFwicHg7IGxlZnQ6IFwiICsgKGUuY2xpZW50WCAtIDUpICsgXCJweDsgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgK1xuICAgICAgICAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArXG4gICAgICAgIFwiOyBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO1xuICAgICAgaWYgKHdlYmtpdCkgdmFyIG9sZFNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTsgLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcbiAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIGlmICh3ZWJraXQpIHdpbmRvdy5zY3JvbGxUbyhudWxsLCBvbGRTY3JvbGxZKTtcbiAgICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgIC8vIEFkZHMgXCJTZWxlY3QgYWxsXCIgdG8gY29udGV4dCBtZW51IGluIEZGXG4gICAgICBpZiAoIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHRlLnZhbHVlID0gaW5wdXQucHJldklucHV0ID0gXCIgXCI7XG4gICAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSB0cnVlO1xuICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG4gICAgICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpO1xuXG4gICAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xuICAgICAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXG4gICAgICAvLyBpdCBnb3Qgc2VsZWN0ZWQuXG4gICAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcbiAgICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBjbS5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICAgIHZhciBleHR2YWwgPSBcIlxcdTIwMGJcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXCJcIik7XG4gICAgICAgICAgdGUudmFsdWUgPSBcIlxcdTIxZGFcIjsgLy8gVXNlZCB0byBjYXRjaCBjb250ZXh0LW1lbnUgdW5kb1xuICAgICAgICAgIHRlLnZhbHVlID0gZXh0dmFsO1xuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwYlwiO1xuICAgICAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aDtcbiAgICAgICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcbiAgICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWhpZGUoKSB7XG4gICAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBzY3JvbGxQb3MpO1xuXG4gICAgICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxuICAgICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTtcbiAgICAgICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgdGUuc2VsZWN0aW9uU3RhcnQgPT0gMCAmJlxuICAgICAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwYlwiKVxuICAgICAgICAgICAgICBvcGVyYXRpb24oY20sIGNvbW1hbmRzLnNlbGVjdEFsbCkoY20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaSsrIDwgMTApIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApO1xuICAgICAgICAgICAgZWxzZSBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSBwcmVwYXJlU2VsZWN0QWxsSGFjaygpO1xuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7XG4gICAgICAgIGVfc3RvcChlKTtcbiAgICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvZmYod2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcbiAgICAgICAgfTtcbiAgICAgICAgb24od2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRVbmVkaXRhYmxlOiBub3RoaW5nLFxuXG4gICAgbmVlZHNDb250ZW50QXR0cmlidXRlOiBmYWxzZVxuICB9LCBUZXh0YXJlYUlucHV0LnByb3RvdHlwZSk7XG5cbiAgLy8gQ09OVEVOVEVESVRBQkxFIElOUFVUIFNUWUxFXG5cbiAgZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlSW5wdXQoY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcbiAgfVxuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZSA9IGNvcHlPYmooe1xuICAgIGluaXQ6IGZ1bmN0aW9uKGRpc3BsYXkpIHtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY207XG4gICAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xuICAgICAgZGl2LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgICAgZGlzYWJsZUJyb3dzZXJNYWdpYyhkaXYpO1xuXG4gICAgICBvbihkaXYsIFwicGFzdGVcIiwgZnVuY3Rpb24oZSkgeyBoYW5kbGVQYXN0ZShlLCBjbSk7IH0pXG5cbiAgICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZyA9IHtzZWw6IGNtLmRvYy5zZWwsIGRhdGE6IGRhdGEsIHN0YXJ0RGF0YTogZGF0YX07XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgICB2YXIgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUocHJpbS5oZWFkLmxpbmUpO1xuICAgICAgICB2YXIgZm91bmQgPSBsaW5lLmluZGV4T2YoZGF0YSwgTWF0aC5tYXgoMCwgcHJpbS5oZWFkLmNoIC0gZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgZm91bmQgPD0gcHJpbS5oZWFkLmNoKVxuICAgICAgICAgIGlucHV0LmNvbXBvc2luZy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oUG9zKHByaW0uaGVhZC5saW5lLCBmb3VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MocHJpbS5oZWFkLmxpbmUsIGZvdW5kICsgZGF0YS5sZW5ndGgpKTtcbiAgICAgIH0pO1xuICAgICAgb24oZGl2LCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLmRhdGEgPSBlLmRhdGE7XG4gICAgICB9KTtcbiAgICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBvdXJzID0gaW5wdXQuY29tcG9zaW5nO1xuICAgICAgICBpZiAoIW91cnMpIHJldHVybjtcbiAgICAgICAgaWYgKGUuZGF0YSAhPSBvdXJzLnN0YXJ0RGF0YSAmJiAhL1xcdTIwMGIvLnRlc3QoZS5kYXRhKSlcbiAgICAgICAgICBvdXJzLmRhdGEgPSBlLmRhdGE7XG4gICAgICAgIC8vIE5lZWQgYSBzbWFsbCBkZWxheSB0byBwcmV2ZW50IG90aGVyIGNvZGUgKGlucHV0IGV2ZW50LFxuICAgICAgICAvLyBzZWxlY3Rpb24gcG9sbGluZykgZnJvbSBkb2luZyBkYW1hZ2Ugd2hlbiBmaXJlZCByaWdodCBhZnRlclxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIW91cnMuaGFuZGxlZClcbiAgICAgICAgICAgIGlucHV0LmFwcGx5Q29tcG9zaXRpb24ob3Vycyk7XG4gICAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZyA9PSBvdXJzKVxuICAgICAgICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgfSwgNTApO1xuICAgICAgfSk7XG5cbiAgICAgIG9uKGRpdiwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dC5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gICAgICB9KTtcblxuICAgICAgb24oZGl2LCBcImlucHV0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSByZXR1cm47XG4gICAgICAgIGlmICghaW5wdXQucG9sbENvbnRlbnQoKSlcbiAgICAgICAgICBydW5Jbk9wKGlucHV0LmNtLCBmdW5jdGlvbigpIHtyZWdDaGFuZ2UoY20pO30pO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XG4gICAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgbGFzdENvcGllZCA9IGNtLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgICAgbGFzdENvcGllZCA9IHJhbmdlcy50ZXh0O1xuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIDAsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpT1MgZXhwb3NlcyB0aGUgY2xpcGJvYXJkIEFQSSwgYnV0IHNlZW1zIHRvIGRpc2NhcmQgY29udGVudCBpbnNlcnRlZCBpbnRvIGl0XG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEgJiYgIWlvcykge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGxhc3RDb3BpZWQuam9pbihcIlxcblwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xuICAgICAgICAgIHZhciBrbHVkZ2UgPSBoaWRkZW5UZXh0YXJlYSgpLCB0ZSA9IGtsdWRnZS5maXJzdENoaWxkO1xuICAgICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHZhciBoYWRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO1xuICAgICAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uKGRpdiwgXCJjb3B5XCIsIG9uQ29weUN1dCk7XG4gICAgICBvbihkaXYsIFwiY3V0XCIsIG9uQ29weUN1dCk7XG4gICAgfSxcblxuICAgIHByZXBhcmVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24odGhpcy5jbSwgZmFsc2UpO1xuICAgICAgcmVzdWx0LmZvY3VzID0gdGhpcy5jbS5zdGF0ZS5mb2N1c2VkO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHJldHVybjtcbiAgICAgIGlmIChpbmZvLmZvY3VzKSB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbyk7XG4gICAgfSxcblxuICAgIHNob3dQcmltYXJ5U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHByaW0gPSB0aGlzLmNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHZhciBjdXJGb2N1cyA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcbiAgICAgICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLmZyb20oKSkgPT0gMCAmJlxuICAgICAgICAgIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHByaW0udG8oKSkgPT0gMClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhcnQgPSBwb3NUb0RPTSh0aGlzLmNtLCBwcmltLmZyb20oKSk7XG4gICAgICB2YXIgZW5kID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS50bygpKTtcbiAgICAgIGlmICghc3RhcnQgJiYgIWVuZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgdmlldyA9IHRoaXMuY20uZGlzcGxheS52aWV3O1xuICAgICAgdmFyIG9sZCA9IHNlbC5yYW5nZUNvdW50ICYmIHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xuICAgICAgfSBlbHNlIGlmICghZW5kKSB7IC8vIEZJWE1FIGRhbmdlcm91c2x5IGhhY2t5XG4gICAgICAgIHZhciBtZWFzdXJlID0gdmlld1t2aWV3Lmxlbmd0aCAtIDFdLm1lYXN1cmU7XG4gICAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XG4gICAgICAgIGVuZCA9IHtub2RlOiBtYXBbbWFwLmxlbmd0aCAtIDFdLCBvZmZzZXQ6IG1hcFttYXAubGVuZ3RoIC0gMl0gLSBtYXBbbWFwLmxlbmd0aCAtIDNdfTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHsgdmFyIHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpOyB9XG4gICAgICBjYXRjaChlKSB7fSAvLyBPdXIgbW9kZWwgb2YgdGhlIERPTSBtaWdodCBiZSBvdXRkYXRlZCwgaW4gd2hpY2ggY2FzZSB0aGUgcmFuZ2Ugd2UgdHJ5IHRvIHNldCBjYW4gYmUgaW1wb3NzaWJsZVxuICAgICAgaWYgKHJuZykge1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShybmcpO1xuICAgICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHNlbC5hZGRSYW5nZShvbGQpO1xuICAgICAgICBlbHNlIGlmIChnZWNrbykgdGhpcy5zdGFydEdyYWNlUGVyaW9kKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIHN0YXJ0R3JhY2VQZXJpb2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKTtcbiAgICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dC5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5wdXQuc2VsZWN0aW9uQ2hhbmdlZCgpKVxuICAgICAgICAgIGlucHV0LmNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHsgaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pO1xuICAgICAgfSwgMjApO1xuICAgIH0sXG5cbiAgICBzaG93TXVsdGlwbGVTZWxlY3Rpb25zOiBmdW5jdGlvbihpbmZvKSB7XG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xuICAgIH0sXG5cbiAgICByZW1lbWJlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfSxcblxuICAgIHNlbGVjdGlvbkluRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuZGl2LCBub2RlKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIpIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfSxcbiAgICBibHVyOiBmdW5jdGlvbigpIHsgdGhpcy5kaXYuYmx1cigpOyB9LFxuICAgIGdldEZpZWxkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGl2OyB9LFxuXG4gICAgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuXG4gICAgcmVjZWl2ZWRGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcbiAgICAgICAgdGhpcy5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24oKSB7IGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KTtcblxuICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICAgIH0sXG5cbiAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxuICAgICAgICBzZWwuZm9jdXNOb2RlICE9IHRoaXMubGFzdEZvY3VzTm9kZSB8fCBzZWwuZm9jdXNPZmZzZXQgIT0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQ7XG4gICAgfSxcblxuICAgIHBvbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXBvc2luZyAmJiAhdGhpcy5ncmFjZVBlcmlvZCAmJiB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XG4gICAgICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIHZhciBoZWFkID0gZG9tVG9Qb3MoY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgICBpZiAoYW5jaG9yLmJhZCB8fCBoZWFkLmJhZCkgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2xsQ29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICB2YXIgZnJvbSA9IHNlbC5mcm9tKCksIHRvID0gc2VsLnRvKCk7XG4gICAgICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBmcm9tSW5kZXg7XG4gICAgICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcbiAgICAgICAgdmFyIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1swXS5saW5lKTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gZGlzcGxheS52aWV3WzBdLm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XG4gICAgICAgIHZhciBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1tmcm9tSW5kZXggLSAxXS5ub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHRvSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCB0by5saW5lKTtcbiAgICAgIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciB0b0xpbmUgPSBkaXNwbGF5LnZpZXdUbyAtIDE7XG4gICAgICAgIHZhciB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMTtcbiAgICAgICAgdmFyIHRvTm9kZSA9IGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdUZXh0ID0gc3BsaXRMaW5lcyhkb21UZXh0QmV0d2VlbihjbSwgZnJvbU5vZGUsIHRvTm9kZSwgZnJvbUxpbmUsIHRvTGluZSkpO1xuICAgICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcbiAgICAgIHdoaWxlIChuZXdUZXh0Lmxlbmd0aCA+IDEgJiYgb2xkVGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tOyB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwO1xuICAgICAgdmFyIG5ld1RvcCA9IG5ld1RleHRbMF0sIG9sZFRvcCA9IG9sZFRleHRbMF0sIG1heEN1dEZyb250ID0gTWF0aC5taW4obmV3VG9wLmxlbmd0aCwgb2xkVG9wLmxlbmd0aCk7XG4gICAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxuICAgICAgICArK2N1dEZyb250O1xuICAgICAgdmFyIG5ld0JvdCA9IGxzdChuZXdUZXh0KSwgb2xkQm90ID0gbHN0KG9sZFRleHQpO1xuICAgICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQm90Lmxlbmd0aCAtIChvbGRUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSk7XG4gICAgICB3aGlsZSAoY3V0RW5kIDwgbWF4Q3V0RW5kICYmXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcbiAgICAgICAgKytjdXRFbmQ7XG5cbiAgICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKTtcbiAgICAgIG5ld1RleHRbMF0gPSBuZXdUZXh0WzBdLnNsaWNlKGN1dEZyb250KTtcblxuICAgICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xuICAgICAgdmFyIGNoVG8gPSBQb3ModG9MaW5lLCBvbGRUZXh0Lmxlbmd0aCA/IGxzdChvbGRUZXh0KS5sZW5ndGggLSBjdXRFbmQgOiAwKTtcbiAgICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA+IDEgfHwgbmV3VGV4dFswXSB8fCBjbXAoY2hGcm9tLCBjaFRvKSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFwiK2lucHV0XCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5zdXJlUG9sbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gICAgfSxcbiAgICBmb3JjZUNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb3NpbmcgfHwgdGhpcy5jb21wb3NpbmcuaGFuZGxlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5hcHBseUNvbXBvc2l0aW9uKHRoaXMuY29tcG9zaW5nKTtcbiAgICAgIHRoaXMuY29tcG9zaW5nLmhhbmRsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kaXYuYmx1cigpO1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9LFxuICAgIGFwcGx5Q29tcG9zaXRpb246IGZ1bmN0aW9uKGNvbXBvc2luZykge1xuICAgICAgaWYgKGNvbXBvc2luZy5kYXRhICYmIGNvbXBvc2luZy5kYXRhICE9IGNvbXBvc2luZy5zdGFydERhdGEpXG4gICAgICAgIG9wZXJhdGlvbih0aGlzLmNtLCBhcHBseVRleHRJbnB1dCkodGhpcy5jbSwgY29tcG9zaW5nLmRhdGEsIDAsIGNvbXBvc2luZy5zZWwpO1xuICAgIH0sXG5cbiAgICBzZXRVbmVkaXRhYmxlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xuICAgIH0sXG5cbiAgICBvbktleVByZXNzOiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApO1xuICAgIH0sXG5cbiAgICBvbkNvbnRleHRNZW51OiBub3RoaW5nLFxuICAgIHJlc2V0UG9zaXRpb246IG5vdGhpbmcsXG5cbiAgICBuZWVkc0NvbnRlbnRBdHRyaWJ1dGU6IHRydWVcbiAgfSwgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKTtcbiAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHJldHVybiBudWxsO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKSwgc2lkZSA9IFwibGVmdFwiO1xuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpO1xuICAgICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xuICAgIHJlc3VsdC5vZmZzZXQgPSByZXN1bHQuY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gYmFkUG9zKHBvcywgYmFkKSB7IGlmIChiYWQpIHBvcy5iYWQgPSB0cnVlOyByZXR1cm4gcG9zOyB9XG5cbiAgZnVuY3Rpb24gZG9tVG9Qb3MoY20sIG5vZGUsIG9mZnNldCkge1xuICAgIHZhciBsaW5lTm9kZTtcbiAgICBpZiAobm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHtcbiAgICAgIGxpbmVOb2RlID0gY20uZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmICghbGluZU5vZGUpIHJldHVybiBiYWRQb3MoY20uY2xpcFBvcyhQb3MoY20uZGlzcGxheS52aWV3VG8gLSAxKSksIHRydWUpO1xuICAgICAgbm9kZSA9IG51bGw7IG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGluZU5vZGUgPSBub2RlOzsgbGluZU5vZGUgPSBsaW5lTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudE5vZGUgJiYgbGluZU5vZGUucGFyZW50Tm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gY20uZGlzcGxheS52aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZU5vZGUpXG4gICAgICAgIHJldHVybiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlO1xuICAgIGlmICghbm9kZSB8fCAhY29udGFpbnMod3JhcHBlciwgbm9kZSkpIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lVmlldy5saW5lKSwgMCksIHRydWUpO1xuICAgIGlmIChub2RlID09IHdyYXBwZXIpIHtcbiAgICAgIGJhZCA9IHRydWU7XG4gICAgICBub2RlID0gd3JhcHBlci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZVZpZXcucmVzdCA/IGxzdChsaW5lVmlldy5yZXN0KSA6IGxpbmVWaWV3LmxpbmU7XG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlO1xuICAgIGlmICghdGV4dE5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChvZmZzZXQpIG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gd3JhcHBlcikgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XG5cbiAgICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgIHZhciBtYXAgPSBpIDwgMCA/IG1lYXN1cmUubWFwIDogbWFwc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqICs9IDMpIHtcbiAgICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl07XG4gICAgICAgICAgaWYgKGN1ck5vZGUgPT0gdGV4dE5vZGUgfHwgY3VyTm9kZSA9PSB0b3BOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcbiAgICAgICAgICAgIHZhciBjaCA9IG1hcFtqXSArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIGNoID0gbWFwW2ogKyAob2Zmc2V0ID8gMSA6IDApXTtcbiAgICAgICAgICAgIHJldHVybiBQb3MobGluZSwgY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm91bmQgPSBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpO1xuICAgIGlmIChmb3VuZCkgcmV0dXJuIGJhZFBvcyhmb3VuZCwgYmFkKTtcblxuICAgIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXG4gICAgZm9yICh2YXIgYWZ0ZXIgPSB0b3BOb2RlLm5leHRTaWJsaW5nLCBkaXN0ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gb2Zmc2V0IDogMDsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMCk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCk7XG4gICAgICBlbHNlXG4gICAgICAgIGRpc3QgKz0gYWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCA9IG9mZnNldDsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QpLCBiYWQpO1xuICAgICAgZWxzZVxuICAgICAgICBkaXN0ICs9IGFmdGVyLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb21UZXh0QmV0d2VlbihjbSwgZnJvbSwgdG8sIGZyb21MaW5lLCB0b0xpbmUpIHtcbiAgICB2YXIgdGV4dCA9IFwiXCIsIGNsb3NpbmcgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZWNvZ25pemVNYXJrZXIoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9OyB9XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIHZhciBjbVRleHQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLXRleHRcIik7XG4gICAgICAgIGlmIChjbVRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjbVRleHQgPT0gXCJcIikgY21UZXh0ID0gbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHUyMDBiL2csIFwiXCIpO1xuICAgICAgICAgIHRleHQgKz0gY21UZXh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiKSwgcmFuZ2U7XG4gICAgICAgIGlmIChtYXJrZXJJRCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGNtLmZpbmRNYXJrcyhQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lICsgMSwgMCksIHJlY29nbml6ZU1hcmtlcigrbWFya2VySUQpKTtcbiAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZSA9IGZvdW5kWzBdLmZpbmQoKSkpXG4gICAgICAgICAgICB0ZXh0ICs9IGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihcIlxcblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09IFwiZmFsc2VcIikgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB3YWxrKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIGlmICgvXihwcmV8ZGl2fHApJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgY2xvc2luZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICB2YXIgdmFsID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGlmICghdmFsKSByZXR1cm47XG4gICAgICAgIGlmIChjbG9zaW5nKSB7XG4gICAgICAgICAgdGV4dCArPSBcIlxcblwiO1xuICAgICAgICAgIGNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgd2Fsayhmcm9tKTtcbiAgICAgIGlmIChmcm9tID09IHRvKSBicmVhaztcbiAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIENvZGVNaXJyb3IuaW5wdXRTdHlsZXMgPSB7XCJ0ZXh0YXJlYVwiOiBUZXh0YXJlYUlucHV0LCBcImNvbnRlbnRlZGl0YWJsZVwiOiBDb250ZW50RWRpdGFibGVJbnB1dH07XG5cbiAgLy8gU0VMRUNUSU9OIC8gQ1VSU09SXG5cbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuICAvLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbiAgZnVuY3Rpb24gU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gIH1cblxuICBTZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdOyB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciA9PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV07XG4gICAgICAgIGlmIChjbXAoaGVyZS5hbmNob3IsIHRoZXJlLmFuY2hvcikgIT0gMCB8fCBjbXAoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlZXBDb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG91dCA9IFtdLCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzLnJhbmdlc1tpXS5hbmNob3IpLCBjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmhlYWQpKTtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgdGhpcy5wcmltSW5kZXgpO1xuICAgIH0sXG4gICAgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lbXB0eSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihwb3MsIGVuZCkge1xuICAgICAgaWYgKCFlbmQpIGVuZCA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XG4gICAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XG4gIH1cblxuICBSYW5nZS5wcm90b3R5cGUgPSB7XG4gICAgZnJvbTogZnVuY3Rpb24oKSB7IHJldHVybiBtaW5Qb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7IH0sXG4gICAgdG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpOyB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXG4gIC8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xuICAvLyBpdCkuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gY21wKGEuZnJvbSgpLCBiLmZyb20oKSk7IH0pO1xuICAgIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICBpZiAoY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSkgPj0gMCkge1xuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZDtcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSAtLXByaW1JbmRleDtcbiAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApO1xuICB9XG5cbiAgLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKTt9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSByZXR1cm4gUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsIGxpbmVsZW4pIHtcbiAgICB2YXIgY2ggPSBwb3MuY2g7XG4gICAgaWYgKGNoID09IG51bGwgfHwgY2ggPiBsaW5lbGVuKSByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKTtcbiAgICBlbHNlIGlmIChjaCA8IDApIHJldHVybiBQb3MocG9zLmxpbmUsIDApO1xuICAgIGVsc2UgcmV0dXJuIHBvcztcbiAgfVxuICBmdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZTt9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgb3V0ID0gW10sIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIG91dFtpXSA9IGNsaXBQb3MoZG9jLCBhcnJheVtpXSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8vIFNFTEVDVElPTiBVUERBVEVTXG5cbiAgLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXG4gIC8vIHRoZSBuZXcgY3Vyc29yIHBvc2l0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXJcbiAgLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXG5cbiAgLy8gSWYgc2hpZnQgaXMgaGVsZCBvciB0aGUgZXh0ZW5kIGZsYWcgaXMgc2V0LCBleHRlbmRzIGEgcmFuZ2UgdG9cbiAgLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXG4gIC8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgLy8gVXNlZCBmb3IgY3Vyc29yIG1vdGlvbiBhbmQgc3VjaC5cbiAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UoZG9jLCByYW5nZSwgaGVhZCwgb3RoZXIpIHtcbiAgICBpZiAoZG9jLmNtICYmIGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpIHtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMDtcbiAgICAgICAgaWYgKHBvc0JlZm9yZSAhPSAoY21wKG90aGVyLCBhbmNob3IpIDwgMCkpIHtcbiAgICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NCZWZvcmUgIT0gKGNtcChoZWFkLCBvdGhlcikgPCAwKSkge1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIpXSwgMCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxuICAvLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xuICAgIGZvciAodmFyIG91dCA9IFtdLCBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwpO1xuICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgIHJhbmdlc1tpXSA9IHJhbmdlO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgdGhpcy5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uaGVhZCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcbiAgICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSk7XG4gICAgZWxzZSByZXR1cm4gc2VsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcbiAgICAgIGRvbmVbZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKVxuICAgICAgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsKTtcblxuICAgIHZhciBiaWFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmJpYXMgfHxcbiAgICAgIChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpO1xuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XG5cbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtKVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcbiAgICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkgcmV0dXJuO1xuXG4gICAgZG9jLnNlbCA9IHNlbDtcblxuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIHJhbmdlcy5cbiAgZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIHZhciBuZXdIZWFkID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShuZXdBbmNob3IsIG5ld0hlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0ID8gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWw7XG4gIH1cblxuICAvLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgYmlhcywgbWF5Q2xlYXIpIHtcbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlLCBjdXJQb3MgPSBwb3M7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICBkb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICBzZWFyY2g6IGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGN1clBvcy5saW5lKTtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKG0uaW5jbHVzaXZlTGVmdCA/IHNwLmZyb20gPD0gY3VyUG9zLmNoIDogc3AuZnJvbSA8IGN1clBvcy5jaCkpICYmXG4gICAgICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChtLmluY2x1c2l2ZVJpZ2h0ID8gc3AudG8gPj0gY3VyUG9zLmNoIDogc3AudG8gPiBjdXJQb3MuY2gpKSkge1xuICAgICAgICAgICAgaWYgKG1heUNsZWFyKSB7XG4gICAgICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICghbGluZS5tYXJrZWRTcGFucykgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZTt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbS5hdG9taWMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIG5ld1BvcyA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGlmIChjbXAobmV3UG9zLCBjdXJQb3MpID09IDApIHtcbiAgICAgICAgICAgICAgbmV3UG9zLmNoICs9IGRpcjtcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvcy5jaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zLmxpbmUgPiBkb2MuZmlyc3QpIG5ld1BvcyA9IGNsaXBQb3MoZG9jLCBQb3MobmV3UG9zLmxpbmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBuZXdQb3MgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Bvcy5jaCA+IGxpbmUudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIG5ld1BvcyA9IFBvcyhuZXdQb3MubGluZSArIDEsIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgbmV3UG9zID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW5ld1Bvcykge1xuICAgICAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBEcml2ZW4gaW4gYSBjb3JuZXIgLS0gbm8gdmFsaWQgY3Vyc29yIHBvc2l0aW9uIGZvdW5kIGF0IGFsbFxuICAgICAgICAgICAgICAgICAgLy8gLS0gdHJ5IGFnYWluICp3aXRoKiBjbGVhcmluZywgaWYgd2UgZGlkbid0IGFscmVhZHlcbiAgICAgICAgICAgICAgICAgIGlmICghbWF5Q2xlYXIpIHJldHVybiBza2lwQXRvbWljKGRvYywgcG9zLCBiaWFzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHVybiBvZmYgZWRpdGluZyB1bnRpbCBmdXJ0aGVyIG5vdGljZSwgYW5kIHJldHVybiB0aGUgc3RhcnQgb2YgdGhlIGRvY1xuICAgICAgICAgICAgICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxpcHBlZCA9IHRydWU7IG5ld1BvcyA9IHBvczsgZGlyID0gLWRpcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1clBvcztcbiAgICB9XG4gIH1cblxuICAvLyBTRUxFQ1RJT04gRFJBV0lOR1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgcmVzdWx0ID0ge307XG4gICAgdmFyIGN1ckZyYWdtZW50ID0gcmVzdWx0LmN1cnNvcnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIHNlbEZyYWdtZW50ID0gcmVzdWx0LnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcmltYXJ5ID09PSBmYWxzZSAmJiBpID09IGRvYy5zZWwucHJpbUluZGV4KSBjb250aW51ZTtcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KCk7XG4gICAgICBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpXG4gICAgICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLCBjdXJGcmFnbWVudCk7XG4gICAgICBpZiAoIWNvbGxhcHNlZClcbiAgICAgICAgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRHJhd3MgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiByYW5nZVxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgcmFuZ2UuaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAocG9zLm90aGVyKSB7XG4gICAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcbiAgICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcIikpO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICAvLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0O1xuICAgIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcblxuICAgIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcbiAgICAgIGlmICh0b3AgPCAwKSB0b3AgPSAwO1xuICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgKyBsZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInB4OyB0b3A6IFwiICsgdG9wICsgXCJweDsgd2lkdGg6IFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInB4OyBoZWlnaHQ6IFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcInB4XCIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XG4gICAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xuICAgICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXCJkaXZcIiwgbGluZU9iaiwgYmlhcyk7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMoZ2V0T3JkZXIobGluZU9iaiksIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24oZnJvbSwgdG8sIGRpcikge1xuICAgICAgICB2YXIgbGVmdFBvcyA9IGNvb3Jkcyhmcm9tLCBcImxlZnRcIiksIHJpZ2h0UG9zLCBsZWZ0LCByaWdodDtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICByaWdodFBvcyA9IGxlZnRQb3M7XG4gICAgICAgICAgbGVmdCA9IHJpZ2h0ID0gbGVmdFBvcy5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJpZ2h0UG9zID0gY29vcmRzKHRvIC0gMSwgXCJyaWdodFwiKTtcbiAgICAgICAgICBpZiAoZGlyID09IFwicnRsXCIpIHsgdmFyIHRtcCA9IGxlZnRQb3M7IGxlZnRQb3MgPSByaWdodFBvczsgcmlnaHRQb3MgPSB0bXA7IH1cbiAgICAgICAgICBsZWZ0ID0gbGVmdFBvcy5sZWZ0O1xuICAgICAgICAgIHJpZ2h0ID0gcmlnaHRQb3MucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDApIGxlZnQgPSBsZWZ0U2lkZTtcbiAgICAgICAgaWYgKHJpZ2h0UG9zLnRvcCAtIGxlZnRQb3MudG9wID4gMykgeyAvLyBEaWZmZXJlbnQgbGluZXMsIGRyYXcgdG9wIHBhcnRcbiAgICAgICAgICBhZGQobGVmdCwgbGVmdFBvcy50b3AsIG51bGwsIGxlZnRQb3MuYm90dG9tKTtcbiAgICAgICAgICBsZWZ0ID0gbGVmdFNpZGU7XG4gICAgICAgICAgaWYgKGxlZnRQb3MuYm90dG9tIDwgcmlnaHRQb3MudG9wKSBhZGQobGVmdCwgbGVmdFBvcy5ib3R0b20sIG51bGwsIHJpZ2h0UG9zLnRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbikgcmlnaHQgPSByaWdodFNpZGU7XG4gICAgICAgIGlmICghc3RhcnQgfHwgbGVmdFBvcy50b3AgPCBzdGFydC50b3AgfHwgbGVmdFBvcy50b3AgPT0gc3RhcnQudG9wICYmIGxlZnRQb3MubGVmdCA8IHN0YXJ0LmxlZnQpXG4gICAgICAgICAgc3RhcnQgPSBsZWZ0UG9zO1xuICAgICAgICBpZiAoIWVuZCB8fCByaWdodFBvcy5ib3R0b20gPiBlbmQuYm90dG9tIHx8IHJpZ2h0UG9zLmJvdHRvbSA9PSBlbmQuYm90dG9tICYmIHJpZ2h0UG9zLnJpZ2h0ID4gZW5kLnJpZ2h0KVxuICAgICAgICAgIGVuZCA9IHJpZ2h0UG9zO1xuICAgICAgICBpZiAobGVmdCA8IGxlZnRTaWRlICsgMSkgbGVmdCA9IGxlZnRTaWRlO1xuICAgICAgICBhZGQobGVmdCwgcmlnaHRQb3MudG9wLCByaWdodCAtIGxlZnQsIHJpZ2h0UG9zLmJvdHRvbSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XG4gICAgfVxuXG4gICAgdmFyIHNGcm9tID0gcmFuZ2UuZnJvbSgpLCBzVG8gPSByYW5nZS50bygpO1xuICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XG4gICAgICBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc1RvLmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xuICAgICAgdmFyIHNpbmdsZVZMaW5lID0gdmlzdWFsTGluZShmcm9tTGluZSkgPT0gdmlzdWFsTGluZSh0b0xpbmUpO1xuICAgICAgdmFyIGxlZnRFbmQgPSBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc2luZ2xlVkxpbmUgPyBmcm9tTGluZS50ZXh0Lmxlbmd0aCArIDEgOiBudWxsKS5lbmQ7XG4gICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xuICAgICAgaWYgKHNpbmdsZVZMaW5lKSB7XG4gICAgICAgIGlmIChsZWZ0RW5kLnRvcCA8IHJpZ2h0U3RhcnQudG9wIC0gMikge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICAgIGFkZChsZWZ0U2lkZSwgcmlnaHRTdGFydC50b3AsIHJpZ2h0U3RhcnQubGVmdCwgcmlnaHRTdGFydC5ib3R0b20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcbiAgICAgICAgYWRkKGxlZnRTaWRlLCBsZWZ0RW5kLmJvdHRvbSwgbnVsbCwgcmlnaHRTdGFydC50b3ApO1xuICAgIH1cblxuICAgIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICAvLyBDdXJzb3ItYmxpbmtpbmdcbiAgZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSByZXR1cm47XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGNsZWFySW50ZXJ2YWwoZGlzcGxheS5ibGlua2VyKTtcbiAgICB2YXIgb24gPSB0cnVlO1xuICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXG4gICAgICBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IChvbiA9ICFvbikgPyBcIlwiIDogXCJoaWRkZW5cIjtcbiAgICAgIH0sIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKTtcbiAgICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXG4gICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgfVxuXG4gIC8vIEhJR0hMSUdIVCBXT1JLRVJcblxuICBmdW5jdGlvbiBzdGFydFdvcmtlcihjbSwgdGltZSkge1xuICAgIGlmIChjbS5kb2MubW9kZS5zdGFydFN0YXRlICYmIGNtLmRvYy5mcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodFdvcmtlcihjbSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2M7XG4gICAgaWYgKGRvYy5mcm9udGllciA8IGRvYy5maXJzdCkgZG9jLmZyb250aWVyID0gZG9jLmZpcnN0O1xuICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHJldHVybjtcbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICB2YXIgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIGdldFN0YXRlQmVmb3JlKGNtLCBkb2MuZnJvbnRpZXIpKTtcbiAgICB2YXIgY2hhbmdlZExpbmVzID0gW107XG5cbiAgICBkb2MuaXRlcihkb2MuZnJvbnRpZXIsIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCBjbS5kaXNwbGF5LnZpZXdUbyArIDUwMCksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXG4gICAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcztcbiAgICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIHRydWUpO1xuICAgICAgICBsaW5lLnN0eWxlcyA9IGhpZ2hsaWdodGVkLnN0eWxlcztcbiAgICAgICAgdmFyIG9sZENscyA9IGxpbmUuc3R5bGVDbGFzc2VzLCBuZXdDbHMgPSBoaWdobGlnaHRlZC5jbGFzc2VzO1xuICAgICAgICBpZiAobmV3Q2xzKSBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NscztcbiAgICAgICAgZWxzZSBpZiAob2xkQ2xzKSBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7XG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcbiAgICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTtcbiAgICAgICAgaWYgKGlzY2hhbmdlKSBjaGFuZ2VkTGluZXMucHVzaChkb2MuZnJvbnRpZXIpO1xuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKTtcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gZG9jLmZyb250aWVyICUgNSA9PSAwID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xuICAgICAgfVxuICAgICAgKytkb2MuZnJvbnRpZXI7XG4gICAgICBpZiAoK25ldyBEYXRlID4gZW5kKSB7XG4gICAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkTGluZXMubGVuZ3RoKSBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlZExpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFwidGV4dFwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgcmV0dXJuIGRvYy5maXJzdDtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpO1xuICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoIDw9IGRvYy5mcm9udGllcikpIHJldHVybiBzZWFyY2g7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGF0ZUJlZm9yZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmICghZG9jLm1vZGUuc3RhcnRTdGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHBvcyA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpLCBzdGF0ZSA9IHBvcyA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgcG9zLTEpLnN0YXRlQWZ0ZXI7XG4gICAgaWYgKCFzdGF0ZSkgc3RhdGUgPSBzdGFydFN0YXRlKGRvYy5tb2RlKTtcbiAgICBlbHNlIHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSk7XG4gICAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSk7XG4gICAgICB2YXIgc2F2ZSA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG87XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBzYXZlID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xuICAgICAgKytwb3M7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIGRvYy5mcm9udGllciA9IHBvcztcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A7fVxuICBmdW5jdGlvbiBwYWRkaW5nVmVydChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0O31cbiAgZnVuY3Rpb24gcGFkZGluZ0goZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSDtcbiAgICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFwicHJlXCIsIFwieFwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGg7IH1cbiAgZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aDtcbiAgfVxuICBmdW5jdGlvbiBkaXNwbGF5SGVpZ2h0KGNtKSB7XG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlaWdodHMucHVzaChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSBtYXAgKG1hcHBpbmcgY2hhcmFjdGVyIG9mZnNldHMgdG8gdGV4dCBub2RlcykgYW5kIGFcbiAgLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XG4gIC8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcbiAgZnVuY3Rpb24gbWFwRnJvbUxpbmVWaWV3KGxpbmVWaWV3LCBsaW5lLCBsaW5lTikge1xuICAgIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpXG4gICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV19O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChsaW5lTm8obGluZVZpZXcucmVzdFtpXSkgPiBsaW5lTilcbiAgICAgICAgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldLCBiZWZvcmU6IHRydWV9O1xuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3O1xuICB9XG5cbiAgLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxuICAvLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xuICAgIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcyk7XG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSB2aWV3IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgbGluZU4gPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXTtcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICByZXR1cm4gZXh0O1xuICB9XG5cbiAgLy8gTWVhc3VyZW1lbnQgY2FuIGJlIHNwbGl0IGluIHR3byBzdGVwcywgdGhlIHNldC11cCB3b3JrIHRoYXRcbiAgLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXG4gIC8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXG4gIC8vIG1lYXN1cmVtZW50cyBpbiBhIHJvdywgY2FuIHRodXMgZW5zdXJlIHRoYXQgdGhlIHNldC11cCB3b3JrIGlzXG4gIC8vIG9ubHkgZG9uZSBvbmNlLlxuICBmdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICBpZiAodmlldyAmJiAhdmlldy50ZXh0KVxuICAgICAgdmlldyA9IG51bGw7XG4gICAgZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpXG4gICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKTtcbiAgICBpZiAoIXZpZXcpXG4gICAgICB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSk7XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIC8vIEdpdmVuIGEgcHJlcGFyZWQgbWVhc3VyZW1lbnQgb2JqZWN0LCBtZWFzdXJlcyB0aGUgcG9zaXRpb24gb2YgYW5cbiAgLy8gYWN0dWFsIGNoYXJhY3RlciAob3IgZmV0Y2hlcyBpdCBmcm9tIHRoZSBjYWNoZSkuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XG4gICAgaWYgKHByZXBhcmVkLmJlZm9yZSkgY2ggPSAtMTtcbiAgICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcIlwiKSwgZm91bmQ7XG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGZvdW5kID0gcHJlcGFyZWQuY2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxuICAgICAgICBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKCFwcmVwYXJlZC5oYXNIZWlnaHRzKSB7XG4gICAgICAgIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBwcmVwYXJlZC52aWV3LCBwcmVwYXJlZC5yZWN0KTtcbiAgICAgICAgcHJlcGFyZWQuaGFzSGVpZ2h0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcyk7XG4gICAgICBpZiAoIWZvdW5kLmJvZ3VzKSBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQ7XG4gICAgfVxuICAgIHJldHVybiB7bGVmdDogZm91bmQubGVmdCwgcmlnaHQ6IGZvdW5kLnJpZ2h0LFxuICAgICAgICAgICAgdG9wOiB2YXJIZWlnaHQgPyBmb3VuZC5ydG9wIDogZm91bmQudG9wLFxuICAgICAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tfTtcbiAgfVxuXG4gIHZhciBudWxsUmVjdCA9IHtsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDB9O1xuXG4gIGZ1bmN0aW9uIG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAobWFwLCBjaCwgYmlhcykge1xuICAgIHZhciBub2RlLCBzdGFydCwgZW5kLCBjb2xsYXBzZTtcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxuICAgIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB2YXIgbVN0YXJ0ID0gbWFwW2ldLCBtRW5kID0gbWFwW2kgKyAxXTtcbiAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xuICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xuICAgICAgICBpZiAoY2ggPj0gbUVuZCkgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbWFwW2kgKyAyXTtcbiAgICAgICAgaWYgKG1TdGFydCA9PSBtRW5kICYmIGJpYXMgPT0gKG5vZGUuaW5zZXJ0TGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKSlcbiAgICAgICAgICBjb2xsYXBzZSA9IGJpYXM7XG4gICAgICAgIGlmIChiaWFzID09IFwibGVmdFwiICYmIHN0YXJ0ID09IDApXG4gICAgICAgICAgd2hpbGUgKGkgJiYgbWFwW2kgLSAyXSA9PSBtYXBbaSAtIDNdICYmIG1hcFtpIC0gMV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSAtPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcImxlZnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxuICAgICAgICAgIHdoaWxlIChpIDwgbWFwLmxlbmd0aCAtIDMgJiYgbWFwW2kgKyAzXSA9PSBtYXBbaSArIDRdICYmICFtYXBbaSArIDVdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgKz0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XG4gICAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2U7XG5cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgLS1zdGFydDtcbiAgICAgICAgd2hpbGUgKHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQgPCBwbGFjZS5jb3ZlckVuZCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kKSkpICsrZW5kO1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KSB7XG4gICAgICAgICAgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZSAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgIHZhciByZWN0cyA9IHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tiaWFzID09IFwicmlnaHRcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZWN0ID0gbnVsbFJlY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdCA9IHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGxSZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSBicmVhaztcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHJlY3QgPSBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKGNtLmRpc3BsYXkubWVhc3VyZSwgcmVjdCk7XG4gICAgfSBlbHNlIHsgLy8gSWYgaXQgaXMgYSB3aWRnZXQsIHNpbXBseSBnZXQgdGhlIGJveCBmb3IgdGhlIHdob2xlIHdpZGdldC5cbiAgICAgIGlmIChzdGFydCA+IDApIGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjtcbiAgICAgIHZhciByZWN0cztcbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAocmVjdHMgPSBub2RlLmdldENsaWVudFJlY3RzKCkpLmxlbmd0aCA+IDEpXG4gICAgICAgIHJlY3QgPSByZWN0c1tiaWFzID09IFwicmlnaHRcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XG4gICAgICB2YXIgclNwYW4gPSBub2RlLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgIGlmIChyU3BhbilcbiAgICAgICAgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVjdCA9IG51bGxSZWN0O1xuICAgIH1cblxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xuICAgIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHRzLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgIGlmIChtaWQgPCBoZWlnaHRzW2ldKSBicmVhaztcbiAgICB2YXIgdG9wID0gaSA/IGhlaWdodHNbaSAtIDFdIDogMCwgYm90ID0gaGVpZ2h0c1tpXTtcbiAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogdG9wLCBib3R0b206IGJvdH07XG4gICAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHJlc3VsdC5ib2d1cyA9IHRydWU7XG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBwcm9ibGVtIHdpdGggYm91bmRpbmcgY2xpZW50IHJlY3RzIG9uIHJhbmdlcyBiZWluZ1xuICAvLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XG4gICAgaWYgKCF3aW5kb3cuc2NyZWVuIHx8IHNjcmVlbi5sb2dpY2FsWERQSSA9PSBudWxsIHx8XG4gICAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB2YXIgc2NhbGVYID0gc2NyZWVuLmxvZ2ljYWxYRFBJIC8gc2NyZWVuLmRldmljZVhEUEk7XG4gICAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xuICAgIHJldHVybiB7bGVmdDogcmVjdC5sZWZ0ICogc2NhbGVYLCByaWdodDogcmVjdC5yaWdodCAqIHNjYWxlWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihsaW5lVmlldykge1xuICAgIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBudWxsO1xuICAgICAgaWYgKGxpbmVWaWV3LnJlc3QpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0gPSB7fTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKSB7XG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxuICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJDYWNoZXMoY20pIHtcbiAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKTtcbiAgICBjbS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IGNtLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGNtLmRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgIGNtLmRpc3BsYXkubGluZU51bUNoYXJzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxYKCkgeyByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdDsgfVxuICBmdW5jdGlvbiBwYWdlU2Nyb2xsWSgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcDsgfVxuXG4gIC8vIENvbnZlcnRzIGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IGZyb20gbGluZS1sb2NhbFxuICAvLyBjb29yZGluYXRlcyBpbnRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uIENvbnRleHQgbWF5IGJlIG9uZSBvZlxuICAvLyBcImxpbmVcIiwgXCJkaXZcIiAoZGlzcGxheS5saW5lRGl2KSwgXCJsb2NhbFwiL251bGwgKGVkaXRvciksIFwid2luZG93XCIsXG4gIC8vIG9yIFwicGFnZVwiLlxuICBmdW5jdGlvbiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIHJlY3QsIGNvbnRleHQpIHtcbiAgICBpZiAobGluZU9iai53aWRnZXRzKSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVPYmoud2lkZ2V0cy5sZW5ndGg7ICsraSkgaWYgKGxpbmVPYmoud2lkZ2V0c1tpXS5hYm92ZSkge1xuICAgICAgdmFyIHNpemUgPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTtcbiAgICAgIHJlY3QudG9wICs9IHNpemU7IHJlY3QuYm90dG9tICs9IHNpemU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IFwibGluZVwiKSByZXR1cm4gcmVjdDtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBcImxvY2FsXCI7XG4gICAgdmFyIHlPZmYgPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgaWYgKGNvbnRleHQgPT0gXCJsb2NhbFwiKSB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7XG4gICAgZWxzZSB5T2ZmIC09IGNtLmRpc3BsYXkudmlld09mZnNldDtcbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIiB8fCBjb250ZXh0ID09IFwid2luZG93XCIpIHtcbiAgICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcbiAgICAgIHJlY3QubGVmdCArPSB4T2ZmOyByZWN0LnJpZ2h0ICs9IHhPZmY7XG4gICAgfVxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cblxuICAvLyBDb3ZlcnRzIGEgYm94IGZyb20gXCJkaXZcIiBjb29yZHMgdG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS5cbiAgLy8gQ29udGV4dCBtYXkgYmUgXCJ3aW5kb3dcIiwgXCJwYWdlXCIsIFwiZGl2XCIsIG9yIFwibG9jYWxcIi9udWxsLlxuICBmdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09IFwiZGl2XCIpIHJldHVybiBjb29yZHM7XG4gICAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcDtcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIikge1xuICAgICAgbGVmdCAtPSBwYWdlU2Nyb2xsWCgpO1xuICAgICAgdG9wIC09IHBhZ2VTY3JvbGxZKCk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcbiAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBiaWFzKSB7XG4gICAgaWYgKCFsaW5lT2JqKSBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cbiAgLy8gJ290aGVyJyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kYXJ5IGN1cnNvclxuICAvLyBvbiBhIGJpZGkgYm91bmRhcnkuXG4gIGZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xuICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgZnVuY3Rpb24gZ2V0KGNoLCByaWdodCkge1xuICAgICAgdmFyIG0gPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoLCByaWdodCA/IFwicmlnaHRcIiA6IFwibGVmdFwiLCB2YXJIZWlnaHQpO1xuICAgICAgaWYgKHJpZ2h0KSBtLmxlZnQgPSBtLnJpZ2h0OyBlbHNlIG0ucmlnaHQgPSBtLmxlZnQ7XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcykge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsICUgMjtcbiAgICAgIGlmIChjaCA9PSBiaWRpTGVmdChwYXJ0KSAmJiBwYXJ0UG9zICYmIHBhcnQubGV2ZWwgPCBvcmRlcltwYXJ0UG9zIC0gMV0ubGV2ZWwpIHtcbiAgICAgICAgcGFydCA9IG9yZGVyWy0tcGFydFBvc107XG4gICAgICAgIGNoID0gYmlkaVJpZ2h0KHBhcnQpIC0gKHBhcnQubGV2ZWwgJSAyID8gMCA6IDEpO1xuICAgICAgICByaWdodCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IGJpZGlSaWdodChwYXJ0KSAmJiBwYXJ0UG9zIDwgb3JkZXIubGVuZ3RoIC0gMSAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyArIDFdLmxldmVsKSB7XG4gICAgICAgIHBhcnQgPSBvcmRlclsrK3BhcnRQb3NdO1xuICAgICAgICBjaCA9IGJpZGlMZWZ0KHBhcnQpIC0gcGFydC5sZXZlbCAlIDI7XG4gICAgICAgIHJpZ2h0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgJiYgY2ggPT0gcGFydC50byAmJiBjaCA+IHBhcnQuZnJvbSkgcmV0dXJuIGdldChjaCAtIDEpO1xuICAgICAgcmV0dXJuIGdldChjaCwgcmlnaHQpO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqKSwgY2ggPSBwb3MuY2g7XG4gICAgaWYgKCFvcmRlcikgcmV0dXJuIGdldChjaCk7XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCk7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MpO1xuICAgIGlmIChiaWRpT3RoZXIgIT0gbnVsbCkgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgYmlkaU90aGVyKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwLCBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBsZWZ0ID0gY2hhcldpZHRoKGNtLmRpc3BsYXkpICogcG9zLmNoO1xuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH07XG4gIH1cblxuICAvLyBQb3NpdGlvbnMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhciBjb250YWluIHNvbWUgZXh0cmEgaW5mb3JtYXRpb24uXG4gIC8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXG4gIC8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xuICAvLyB0aGUgcmlnaHQgb2YgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiwgZm9yIGV4YW1wbGUpLiBXaGVuIG91dHNpZGVcbiAgLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xuICAvLyB2ZXJ0aWNhbCByYW5nZS5cbiAgZnVuY3Rpb24gUG9zV2l0aEluZm8obGluZSwgY2gsIG91dHNpZGUsIHhSZWwpIHtcbiAgICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoKTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHBvcy5vdXRzaWRlID0gdHJ1ZTtcbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwgMCwgdHJ1ZSwgLTEpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChsaW5lTiA+IGxhc3QpXG4gICAgICByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIHRydWUsIDEpO1xuICAgIGlmICh4IDwgMCkgeCA9IDA7XG5cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTik7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGZvdW5kID0gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTiwgeCwgeSk7XG4gICAgICB2YXIgbWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmVPYmopO1xuICAgICAgdmFyIG1lcmdlZFBvcyA9IG1lcmdlZCAmJiBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGlmIChtZXJnZWQgJiYgKGZvdW5kLmNoID4gbWVyZ2VkUG9zLmZyb20uY2ggfHwgZm91bmQuY2ggPT0gbWVyZ2VkUG9zLmZyb20uY2ggJiYgZm91bmQueFJlbCA+IDApKVxuICAgICAgICBsaW5lTiA9IGxpbmVObyhsaW5lT2JqID0gbWVyZ2VkUG9zLnRvLmxpbmUpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTm8sIHgsIHkpIHtcbiAgICB2YXIgaW5uZXJPZmYgPSB5IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIHZhciB3cm9uZ0xpbmUgPSBmYWxzZSwgYWRqdXN0ID0gMiAqIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB2YXIgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTtcblxuICAgIGZ1bmN0aW9uIGdldFgoY2gpIHtcbiAgICAgIHZhciBzcCA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgY2gpLCBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgIHdyb25nTGluZSA9IHRydWU7XG4gICAgICBpZiAoaW5uZXJPZmYgPiBzcC5ib3R0b20pIHJldHVybiBzcC5sZWZ0IC0gYWRqdXN0O1xuICAgICAgZWxzZSBpZiAoaW5uZXJPZmYgPCBzcC50b3ApIHJldHVybiBzcC5sZWZ0ICsgYWRqdXN0O1xuICAgICAgZWxzZSB3cm9uZ0xpbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBzcC5sZWZ0O1xuICAgIH1cblxuICAgIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZU9iaiksIGRpc3QgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBmcm9tID0gbGluZUxlZnQobGluZU9iaiksIHRvID0gbGluZVJpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBmcm9tWCA9IGdldFgoZnJvbSksIGZyb21PdXRzaWRlID0gd3JvbmdMaW5lLCB0b1ggPSBnZXRYKHRvKSwgdG9PdXRzaWRlID0gd3JvbmdMaW5lO1xuXG4gICAgaWYgKHggPiB0b1gpIHJldHVybiBQb3NXaXRoSW5mbyhsaW5lTm8sIHRvLCB0b091dHNpZGUsIDEpO1xuICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBiZXR3ZWVuIHRoZXNlIGJvdW5kcy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAoYmlkaSA/IHRvID09IGZyb20gfHwgdG8gPT0gbW92ZVZpc3VhbGx5KGxpbmVPYmosIGZyb20sIDEpIDogdG8gLSBmcm9tIDw9IDEpIHtcbiAgICAgICAgdmFyIGNoID0geCA8IGZyb21YIHx8IHggLSBmcm9tWCA8PSB0b1ggLSB4ID8gZnJvbSA6IHRvO1xuICAgICAgICB2YXIgeERpZmYgPSB4IC0gKGNoID09IGZyb20gPyBmcm9tWCA6IHRvWCk7XG4gICAgICAgIHdoaWxlIChpc0V4dGVuZGluZ0NoYXIobGluZU9iai50ZXh0LmNoYXJBdChjaCkpKSArK2NoO1xuICAgICAgICB2YXIgcG9zID0gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgY2ggPT0gZnJvbSA/IGZyb21PdXRzaWRlIDogdG9PdXRzaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeERpZmYgPCAtMSA/IC0xIDogeERpZmYgPiAxID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoZGlzdCAvIDIpLCBtaWRkbGUgPSBmcm9tICsgc3RlcDtcbiAgICAgIGlmIChiaWRpKSB7XG4gICAgICAgIG1pZGRsZSA9IGZyb207XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgKytpKSBtaWRkbGUgPSBtb3ZlVmlzdWFsbHkobGluZU9iaiwgbWlkZGxlLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaWRkbGVYID0gZ2V0WChtaWRkbGUpO1xuICAgICAgaWYgKG1pZGRsZVggPiB4KSB7dG8gPSBtaWRkbGU7IHRvWCA9IG1pZGRsZVg7IGlmICh0b091dHNpZGUgPSB3cm9uZ0xpbmUpIHRvWCArPSAxMDAwOyBkaXN0ID0gc3RlcDt9XG4gICAgICBlbHNlIHtmcm9tID0gbWlkZGxlOyBmcm9tWCA9IG1pZGRsZVg7IGZyb21PdXRzaWRlID0gd3JvbmdMaW5lOyBkaXN0IC09IHN0ZXA7fVxuICAgIH1cbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiKTtcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxuICAgICAgLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OTsgKytpKSB7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcImJyXCIpKTtcbiAgICAgIH1cbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgbWVhc3VyZVRleHQpO1xuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcbiAgICBpZiAoaGVpZ2h0ID4gMykgZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXG4gIGZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHJldHVybiBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aDtcbiAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XG4gICAgdmFyIHByZSA9IGVsdChcInByZVwiLCBbYW5jaG9yXSk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpO1xuICAgIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwO1xuICAgIGlmICh3aWR0aCA+IDIpIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHdpZHRoIHx8IDEwO1xuICB9XG5cbiAgLy8gT1BFUkFUSU9OU1xuXG4gIC8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuICAvLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcbiAgLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXG5cbiAgdmFyIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcblxuICB2YXIgbmV4dE9wSWQgPSAwO1xuICAvLyBTdGFydCBhIG5ldyBvcGVyYXRpb24uXG4gIGZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XG4gICAgY20uY3VyT3AgPSB7XG4gICAgICBjbTogY20sXG4gICAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAgICAgIC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcbiAgICAgIHVwZGF0ZUlucHV0OiBudWxsLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXG4gICAgICBjaGFuZ2VPYmpzOiBudWxsLCAgICAgICAgLy8gQWNjdW11bGF0ZWQgY2hhbmdlcywgZm9yIGZpcmluZyBjaGFuZ2UgZXZlbnRzXG4gICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XG4gICAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgZm9jdXM6IGZhbHNlLFxuICAgICAgaWQ6ICsrbmV4dE9wSWQgICAgICAgICAgIC8vIFVuaXF1ZSBJRFxuICAgIH07XG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICBvcGVyYXRpb25Hcm91cC5vcHMucHVzaChjbS5jdXJPcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNtLmN1ck9wLm93bnNHcm91cCA9IG9wZXJhdGlvbkdyb3VwID0ge1xuICAgICAgICBvcHM6IFtjbS5jdXJPcF0sXG4gICAgICAgIGRlbGF5ZWRDYWxsYmFja3M6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApIHtcbiAgICAvLyBDYWxscyBkZWxheWVkIGNhbGxiYWNrcyBhbmQgY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgdW50aWwgbm9cbiAgICAvLyBuZXcgb25lcyBhcHBlYXJcbiAgICB2YXIgY2FsbGJhY2tzID0gZ3JvdXAuZGVsYXllZENhbGxiYWNrcywgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgZm9yICg7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIGNhbGxiYWNrc1tpXSgpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xuICAgICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgICAgICB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aClcbiAgICAgICAgICAgIG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnNbb3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10ob3AuY20pO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIEZpbmlzaCBhbiBvcGVyYXRpb24sIHVwZGF0aW5nIHRoZSBkaXNwbGF5IGFuZCBzaWduYWxsaW5nIGRlbGF5ZWQgZXZlbnRzXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbihjbSkge1xuICAgIHZhciBvcCA9IGNtLmN1ck9wLCBncm91cCA9IG9wLm93bnNHcm91cDtcbiAgICBpZiAoIWdyb3VwKSByZXR1cm47XG5cbiAgICB0cnkgeyBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5vcHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7XG4gICAgICBlbmRPcGVyYXRpb25zKGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25zKGdyb3VwKSB7XG4gICAgdmFyIG9wcyA9IGdyb3VwLm9wcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cbiAgICAgIGVuZE9wZXJhdGlvbl9SMShvcHNbaV0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSAvLyBXcml0ZSBET00gKG1heWJlKVxuICAgICAgZW5kT3BlcmF0aW9uX1cxKG9wc1tpXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXG4gICAgICBlbmRPcGVyYXRpb25fUjIob3BzW2ldKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcbiAgICAgIGVuZE9wZXJhdGlvbl9XMihvcHNbaV0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSAvLyBSZWFkIERPTVxuICAgICAgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pO1xuICAgIGlmIChvcC51cGRhdGVNYXhMaW5lKSBmaW5kTWF4TGluZShjbSk7XG5cbiAgICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2Nyb2xsVG9Qb3MudG8ubGluZSA+PSBkaXNwbGF5LnZpZXdUbykgfHxcbiAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxuICAgICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKSB7XG4gICAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcblxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG5cbiAgICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXG4gICAgLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcbiAgICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbztcbiAgICAgIG9wLmJhck1lYXN1cmUuc2Nyb2xsV2lkdGggPVxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xuICAgICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcbiAgICB9XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc2VsZWN0aW9uQ2hhbmdlZClcbiAgICAgIG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzIob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbTtcblxuICAgIGlmIChvcC5hZGp1c3RXaWR0aFRvICE9IG51bGwpIHtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvICsgXCJweFwiO1xuICAgICAgaWYgKG9wLm1heFNjcm9sbExlZnQgPCBjbS5kb2Muc2Nyb2xsTGVmdClcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7XG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKG9wLnByZXBhcmVkU2VsZWN0aW9uKTtcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpXG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSk7XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBvcC5iYXJNZWFzdXJlKTtcblxuICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSByZXN0YXJ0QmxpbmsoY20pO1xuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7XG4gICAgaWYgKG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpKSBlbnN1cmVGb2N1cyhvcC5jbSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCBvcC51cGRhdGUpO1xuXG4gICAgLy8gQWJvcnQgbW91c2Ugd2hlZWwgZGVsdGEgbWVhc3VyZW1lbnQsIHdoZW4gc2Nyb2xsaW5nIGV4cGxpY2l0bHlcbiAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCAhPSBudWxsICYmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fCBvcC5zY3JvbGxMZWZ0ICE9IG51bGwgfHwgb3Auc2Nyb2xsVG9Qb3MpKVxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsO1xuXG4gICAgLy8gUHJvcGFnYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIGFjdHVhbCBET00gc2Nyb2xsZXJcbiAgICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IG9wLnNjcm9sbFRvcCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCBvcC5zY3JvbGxUb3ApKTtcbiAgICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZG9jLnNjcm9sbFRvcCk7XG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IGRvYy5zY3JvbGxUb3A7XG4gICAgfVxuICAgIGlmIChvcC5zY3JvbGxMZWZ0ICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSBvcC5zY3JvbGxMZWZ0IHx8IG9wLmZvcmNlU2Nyb2xsKSkge1xuICAgICAgZG9jLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZGlzcGxheVdpZHRoKGNtKSwgb3Auc2Nyb2xsTGVmdCkpO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoZG9jLnNjcm9sbExlZnQpO1xuICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gZG9jLnNjcm9sbExlZnQ7XG4gICAgICBhbGlnbkhvcml6b250YWxseShjbSk7XG4gICAgfVxuICAgIC8vIElmIHdlIG5lZWQgdG8gc2Nyb2xsIGEgc3BlY2lmaWMgcG9zaXRpb24gaW50byB2aWV3LCBkbyBzby5cbiAgICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcbiAgICAgIHZhciBjb29yZHMgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbik7XG4gICAgICBpZiAob3Auc2Nyb2xsVG9Qb3MuaXNDdXJzb3IgJiYgY20uc3RhdGUuZm9jdXNlZCkgbWF5YmVTY3JvbGxXaW5kb3coY20sIGNvb3Jkcyk7XG4gICAgfVxuXG4gICAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxuICAgIC8vIHVuZG9pbmdcbiAgICB2YXIgaGlkZGVuID0gb3AubWF5YmVIaWRkZW5NYXJrZXJzLCB1bmhpZGRlbiA9IG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzO1xuICAgIGlmIChoaWRkZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSBzaWduYWwoaGlkZGVuW2ldLCBcImhpZGVcIik7XG4gICAgaWYgKHVuaGlkZGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKHVuaGlkZGVuW2ldLmxpbmVzLmxlbmd0aCkgc2lnbmFsKHVuaGlkZGVuW2ldLCBcInVuaGlkZVwiKTtcblxuICAgIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KVxuICAgICAgZG9jLnNjcm9sbFRvcCA9IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuXG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgc2lnbmFsKGNtLCBcImNoYW5nZXNcIiwgY20sIG9wLmNoYW5nZU9ianMpO1xuICAgIGlmIChvcC51cGRhdGUpXG4gICAgICBvcC51cGRhdGUuZmluaXNoKCk7XG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvblxuICBmdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XG4gICAgaWYgKGNtLmN1ck9wKSByZXR1cm4gZigpO1xuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICB0cnkgeyByZXR1cm4gZigpOyB9XG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgfVxuICAvLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gb3BlcmF0aW9uKGNtLCBmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNtLmN1ck9wKSByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKTtcbiAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH07XG4gIH1cbiAgLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cbiAgLy8gb3BlcmF0aW9ucy5cbiAgZnVuY3Rpb24gbWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1ck9wKSByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKHRoaXMpOyB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH07XG4gIH1cblxuICAvLyBWSUVXIFRSQUNLSU5HXG5cbiAgLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxuICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxO1xuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cbiAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgZnJvbSA9IGNtLmRvYy5maXJzdDtcbiAgICBpZiAodG8gPT0gbnVsbCkgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTtcbiAgICBpZiAoIWxlbmRpZmYpIGxlbmRpZmYgPSAwO1xuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gZnJvbTtcblxuICAgIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pIDwgZGlzcGxheS52aWV3VG8pXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBUb3Agb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIGlmIChjdXQpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dC5pbmRleCk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0LmxpbmVOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBHYXAgaW4gdGhlIG1pZGRsZVxuICAgICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIHZhciBjdXRCb3QgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgIGlmIChjdXRUb3AgJiYgY3V0Qm90KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXRUb3AuaW5kZXgpXG4gICAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxuICAgICAgICAgIC5jb25jYXQoZGlzcGxheS52aWV3LnNsaWNlKGN1dEJvdC5pbmRleCkpO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQpIHtcbiAgICAgIGlmICh0byA8IGV4dC5saW5lTilcbiAgICAgICAgZXh0LmxpbmVOICs9IGxlbmRpZmY7XG4gICAgICBlbHNlIGlmIChmcm9tIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICAgIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuXG4gICAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHJldHVybjtcbiAgICB2YXIgbGluZVZpZXcgPSBkaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZSldO1xuICAgIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgYXJyID0gbGluZVZpZXcuY2hhbmdlcyB8fCAobGluZVZpZXcuY2hhbmdlcyA9IFtdKTtcbiAgICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSBhcnIucHVzaCh0eXBlKTtcbiAgfVxuXG4gIC8vIENsZWFyIHRoZSB2aWV3LlxuICBmdW5jdGlvbiByZXNldFZpZXcoY20pIHtcbiAgICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgY20uZGlzcGxheS52aWV3ID0gW107XG4gICAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcbiAgLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxuICBmdW5jdGlvbiBmaW5kVmlld0luZGV4KGNtLCBuKSB7XG4gICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHJldHVybiBudWxsO1xuICAgIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICBpZiAobiA8IDApIHJldHVybiBudWxsO1xuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgbiAtPSB2aWV3W2ldLnNpemU7XG4gICAgICBpZiAobiA8IDApIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xuICAgIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcbiAgICAgIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn07XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgIG4gKz0gdmlld1tpXS5zaXplO1xuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHJldHVybiBudWxsO1xuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSByZXR1cm4gbnVsbDtcbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059O1xuICB9XG5cbiAgLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxuICAvLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICh2aWV3Lmxlbmd0aCA9PSAwIHx8IGZyb20gPj0gZGlzcGxheS52aWV3VG8gfHwgdG8gPD0gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KTtcbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgICBpZiAoZGlzcGxheS52aWV3VG8gPCB0bylcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgZmluZFZpZXdJbmRleChjbSwgdG8pKTtcbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpICsrZGlydHk7XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eTtcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMRVJTXG5cbiAgLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgd2hlbiBpbml0aWFsaXppbmcgdGhlIGVkaXRvclxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50SGFuZGxlcnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbk1vdXNlRG93bikpO1xuICAgIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSlcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcbiAgICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSk7XG4gICAgICAgIGlmICghcG9zIHx8IGNsaWNrSW5HdXR0ZXIoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHJldHVybjtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgdmFyIHdvcmQgPSBjbS5maW5kV29yZEF0KHBvcyk7XG4gICAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHdvcmQuYW5jaG9yLCB3b3JkLmhlYWQpO1xuICAgICAgfSkpO1xuICAgIGVsc2VcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oZSkgeyBzaWduYWxET01FdmVudChjbSwgZSkgfHwgZV9wcmV2ZW50RGVmYXVsdChlKTsgfSk7XG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGNvbnRleHRtZW51ICphZnRlciogb3BlbmluZyB0aGUgbWVudSwgYXRcbiAgICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXG4gICAgLy8gaGFuZGxlZCBpbiBvbk1vdXNlRG93biBmb3IgdGhlc2UgYnJvd3NlcnMuXG4gICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgb24oZC5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbihlKSB7b25Db250ZXh0TWVudShjbSwgZSk7fSk7XG5cbiAgICAvLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXG4gICAgdmFyIHRvdWNoRmluaXNoZWQsIHByZXZUb3VjaCA9IHtlbmQ6IDB9O1xuICAgIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHtcbiAgICAgICAgdG91Y2hGaW5pc2hlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZC5hY3RpdmVUb3VjaCA9IG51bGw7fSwgMTAwMCk7XG4gICAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICAgIHByZXZUb3VjaC5lbmQgPSArbmV3IERhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIHRvdWNoLnJhZGl1c1ggPD0gMSAmJiB0b3VjaC5yYWRpdXNZIDw9IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhckF3YXkodG91Y2gsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIubGVmdCA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjA7XG4gICAgfVxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodG91Y2hGaW5pc2hlZCk7XG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgICAgIGQuYWN0aXZlVG91Y2ggPSB7c3RhcnQ6IG5vdywgbW92ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHByZXY6IG5vdyAtIHByZXZUb3VjaC5lbmQgPD0gMzAwID8gcHJldlRvdWNoIDogbnVsbH07XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoLmxlZnQgPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC50b3AgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkLmFjdGl2ZVRvdWNoKSBkLmFjdGl2ZVRvdWNoLm1vdmVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0b3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmXG4gICAgICAgICAgIXRvdWNoLm1vdmVkICYmIG5ldyBEYXRlIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoZC5hY3RpdmVUb3VjaCwgXCJwYWdlXCIpLCByYW5nZTtcbiAgICAgICAgaWYgKCF0b3VjaC5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYpKSAvLyBTaW5nbGUgdGFwXG4gICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgICBlbHNlIGlmICghdG91Y2gucHJldi5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYucHJldikpIC8vIERvdWJsZSB0YXBcbiAgICAgICAgICByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXG4gICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSk7XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihyYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQpO1xuICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgfVxuICAgICAgZmluaXNoVG91Y2goKTtcbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoY2FuY2VsXCIsIGZpbmlzaFRvdWNoKTtcblxuICAgIC8vIFN5bmMgc2Nyb2xsaW5nIGJldHdlZW4gZmFrZSBzY3JvbGxiYXJzIGFuZCByZWFsIHNjcm9sbGFibGVcbiAgICAvLyBhcmVhLCBlbnN1cmUgdmlld3BvcnQgaXMgdXBkYXRlZCB3aGVuIHNjcm9sbGluZy5cbiAgICBvbihkLnNjcm9sbGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkLnNjcm9sbGVyLmNsaWVudEhlaWdodCkge1xuICAgICAgICBzZXRTY3JvbGxUb3AoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsVG9wKTtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgZC5zY3JvbGxlci5zY3JvbGxMZWZ0LCB0cnVlKTtcbiAgICAgICAgc2lnbmFsKGNtLCBcInNjcm9sbFwiLCBjbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gd2hlZWwgZXZlbnRzIGluIG9yZGVyIHRvIHRyeSBhbmQgdXBkYXRlIHRoZSB2aWV3cG9ydCBvbiB0aW1lLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbihlKXtvblNjcm9sbFdoZWVsKGNtLCBlKTt9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIkRPTU1vdXNlU2Nyb2xsXCIsIGZ1bmN0aW9uKGUpe29uU2Nyb2xsV2hlZWwoY20sIGUpO30pO1xuXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkgeyBkLndyYXBwZXIuc2Nyb2xsVG9wID0gZC53cmFwcGVyLnNjcm9sbExlZnQgPSAwOyB9KTtcblxuICAgIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcbiAgICAgIHNpbXBsZTogZnVuY3Rpb24oZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSBlX3N0b3AoZSk7fSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbihlKXtvbkRyYWdTdGFydChjbSwgZSk7fSxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKVxuICAgIH07XG5cbiAgICB2YXIgaW5wID0gZC5pbnB1dC5nZXRGaWVsZCgpO1xuICAgIG9uKGlucCwgXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7IG9uS2V5VXAuY2FsbChjbSwgZSk7IH0pO1xuICAgIG9uKGlucCwgXCJrZXlkb3duXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSk7XG4gICAgb24oaW5wLCBcImtleXByZXNzXCIsIG9wZXJhdGlvbihjbSwgb25LZXlQcmVzcykpO1xuICAgIG9uKGlucCwgXCJmb2N1c1wiLCBiaW5kKG9uRm9jdXMsIGNtKSk7XG4gICAgb24oaW5wLCBcImJsdXJcIiwgYmluZChvbkJsdXIsIGNtKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnRHJvcENoYW5nZWQoY20sIHZhbHVlLCBvbGQpIHtcbiAgICB2YXIgd2FzT24gPSBvbGQgJiYgb2xkICE9IENvZGVNaXJyb3IuSW5pdDtcbiAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xuICAgICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2VudGVyXCIsIGZ1bmNzLnNpbXBsZSk7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnb3ZlclwiLCBmdW5jcy5zaW1wbGUpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBmdW5jcy5kcm9wKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbiAgZnVuY3Rpb24gb25SZXNpemUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKGQubGFzdFdyYXBIZWlnaHQgPT0gZC53cmFwcGVyLmNsaWVudEhlaWdodCAmJiBkLmxhc3RXcmFwV2lkdGggPT0gZC53cmFwcGVyLmNsaWVudFdpZHRoKVxuICAgICAgcmV0dXJuO1xuICAgIC8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXG4gICAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2U7XG4gICAgY20uc2V0U2l6ZSgpO1xuICB9XG5cbiAgLy8gTU9VU0UgRVZFTlRTXG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IChuLm5vZGVUeXBlID09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIpID09IFwidHJ1ZVwiKSB8fFxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlbiBhIG1vdXNlIGV2ZW50LCBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uLiBJZiBsaWJlcmFsXG4gIC8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXG4gIC8vIGFuZCByZXR1cm5zIG51bGwgaWYgaXQgd2FzLiBmb3JSZWN0IGlzIHVzZWQgYnkgcmVjdGFuZ3VsYXJcbiAgLy8gc2VsZWN0aW9ucywgYW5kIHRyaWVzIHRvIGVzdGltYXRlIGEgY2hhcmFjdGVyIHBvc2l0aW9uIGV2ZW4gZm9yXG4gIC8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXG4gIGZ1bmN0aW9uIHBvc0Zyb21Nb3VzZShjbSwgZSwgbGliZXJhbCwgZm9yUmVjdCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIikgPT0gXCJ0cnVlXCIpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHgsIHksIHNwYWNlID0gZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gRmFpbHMgdW5wcmVkaWN0YWJseSBvbiBJRVs2N10gd2hlbiBtb3VzZSBpcyBkcmFnZ2VkIGFyb3VuZCBxdWlja2x5LlxuICAgIHRyeSB7IHggPSBlLmNsaWVudFggLSBzcGFjZS5sZWZ0OyB5ID0gZS5jbGllbnRZIC0gc3BhY2UudG9wOyB9XG4gICAgY2F0Y2ggKGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmU7XG4gICAgaWYgKGZvclJlY3QgJiYgY29vcmRzLnhSZWwgPT0gMSAmJiAobGluZSA9IGdldExpbmUoY20uZG9jLCBjb29yZHMubGluZSkudGV4dCkubGVuZ3RoID09IGNvb3Jkcy5jaCkge1xuICAgICAgdmFyIGNvbERpZmYgPSBjb3VudENvbHVtbihsaW5lLCBsaW5lLmxlbmd0aCwgY20ub3B0aW9ucy50YWJTaXplKSAtIGxpbmUubGVuZ3RoO1xuICAgICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG5cbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcbiAgLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoZGlzcGxheS5hY3RpdmVUb3VjaCAmJiBkaXNwbGF5LmlucHV0LnN1cHBvcnRzVG91Y2goKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcbiAgICBkaXNwbGF5LnNoaWZ0ID0gZS5zaGlmdEtleTtcblxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XG4gICAgICBpZiAoIXdlYmtpdCkge1xuICAgICAgICAvLyBCcmllZmx5IHR1cm4gb2ZmIGRyYWdnYWJpbGl0eSwgdG8gYWxsb3cgd2lkZ2V0cyB0byBkb1xuICAgICAgICAvLyBub3JtYWwgZHJhZ2dpbmcgdGhpbmdzLlxuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO30sIDEwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgcmV0dXJuO1xuICAgIHZhciBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSk7XG4gICAgd2luZG93LmZvY3VzKCk7XG5cbiAgICBzd2l0Y2ggKGVfYnV0dG9uKGUpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKHN0YXJ0KVxuICAgICAgICBsZWZ0QnV0dG9uRG93bihjbSwgZSwgc3RhcnQpO1xuICAgICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcilcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGlmICh3ZWJraXQpIGNtLnN0YXRlLmxhc3RNaWRkbGVEb3duID0gK25ldyBEYXRlO1xuICAgICAgaWYgKHN0YXJ0KSBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBzdGFydCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2Rpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSBvbkNvbnRleHRNZW51KGNtLCBlKTtcbiAgICAgIGVsc2UgZGVsYXlCbHVyRXZlbnQoY20pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhc3RDbGljaywgbGFzdERvdWJsZUNsaWNrO1xuICBmdW5jdGlvbiBsZWZ0QnV0dG9uRG93bihjbSwgZSwgc3RhcnQpIHtcbiAgICBpZiAoaWUpIHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTtcbiAgICBlbHNlIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG5cbiAgICB2YXIgbm93ID0gK25ldyBEYXRlLCB0eXBlO1xuICAgIGlmIChsYXN0RG91YmxlQ2xpY2sgJiYgbGFzdERvdWJsZUNsaWNrLnRpbWUgPiBub3cgLSA0MDAgJiYgY21wKGxhc3REb3VibGVDbGljay5wb3MsIHN0YXJ0KSA9PSAwKSB7XG4gICAgICB0eXBlID0gXCJ0cmlwbGVcIjtcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdENsaWNrLnBvcywgc3RhcnQpID09IDApIHtcbiAgICAgIHR5cGUgPSBcImRvdWJsZVwiO1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0ge3RpbWU6IG5vdywgcG9zOiBzdGFydH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBcInNpbmdsZVwiO1xuICAgICAgbGFzdENsaWNrID0ge3RpbWU6IG5vdywgcG9zOiBzdGFydH07XG4gICAgfVxuXG4gICAgdmFyIHNlbCA9IGNtLmRvYy5zZWwsIG1vZGlmaWVyID0gbWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5LCBjb250YWluZWQ7XG4gICAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWlzUmVhZE9ubHkoY20pICYmXG4gICAgICAgIHR5cGUgPT0gXCJzaW5nbGVcIiAmJiAoY29udGFpbmVkID0gc2VsLmNvbnRhaW5zKHN0YXJ0KSkgPiAtMSAmJlxuICAgICAgICAoY21wKChjb250YWluZWQgPSBzZWwucmFuZ2VzW2NvbnRhaW5lZF0pLmZyb20oKSwgc3RhcnQpIDwgMCB8fCBzdGFydC54UmVsID4gMCkgJiZcbiAgICAgICAgKGNtcChjb250YWluZWQudG8oKSwgc3RhcnQpID4gMCB8fCBzdGFydC54UmVsIDwgMCkpXG4gICAgICBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpO1xuICAgIGVsc2VcbiAgICAgIGxlZnRCdXR0b25TZWxlY3QoY20sIGUsIHN0YXJ0LCB0eXBlLCBtb2RpZmllcik7XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oZTIpIHtcbiAgICAgIGlmICh3ZWJraXQpIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBmYWxzZTtcbiAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmIChNYXRoLmFicyhlLmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGUuY2xpZW50WSAtIGUyLmNsaWVudFkpIDwgMTApIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlMik7XG4gICAgICAgIGlmICghbW9kaWZpZXIgJiYgK25ldyBEYXRlIC0gMjAwIDwgc3RhcnRUaW1lKVxuICAgICAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTtcbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxuICAgICAgICBpZiAod2Via2l0IHx8IGllICYmIGllX3ZlcnNpb24gPT0gOSlcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2RvY3VtZW50LmJvZHkuZm9jdXMoKTsgZGlzcGxheS5pbnB1dC5mb2N1cygpO30sIDIwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cbiAgICBpZiAod2Via2l0KSBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZHJhZ0VuZDtcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxuICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSBkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKCk7XG4gICAgb24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG4gIH1cblxuICAvLyBOb3JtYWwgc2VsZWN0aW9uLCBhcyBvcHBvc2VkIHRvIHRleHQgZHJhZ2dpbmcuXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25TZWxlY3QoY20sIGUsIHN0YXJ0LCB0eXBlLCBhZGROZXcpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XG4gICAgaWYgKGFkZE5ldyAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcbiAgICAgIGlmIChvdXJJbmRleCA+IC0xKVxuICAgICAgICBvdXJSYW5nZSA9IHJhbmdlc1tvdXJJbmRleF07XG4gICAgICBlbHNlXG4gICAgICAgIG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91clJhbmdlID0gZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwucHJpbUluZGV4O1xuICAgIH1cblxuICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgdHlwZSA9IFwicmVjdFwiO1xuICAgICAgaWYgKCFhZGROZXcpIG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7XG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBvdXJJbmRleCA9IC0xO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImRvdWJsZVwiKSB7XG4gICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQoc3RhcnQpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZClcbiAgICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcbiAgICAgIGVsc2VcbiAgICAgICAgb3VyUmFuZ2UgPSB3b3JkO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInRyaXBsZVwiKSB7XG4gICAgICB2YXIgbGluZSA9IG5ldyBSYW5nZShQb3Moc3RhcnQubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3Moc3RhcnQubGluZSArIDEsIDApKSk7XG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxuICAgICAgICBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKGRvYywgb3VyUmFuZ2UsIGxpbmUuYW5jaG9yLCBsaW5lLmhlYWQpO1xuICAgICAgZWxzZVxuICAgICAgICBvdXJSYW5nZSA9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghYWRkTmV3KSB7XG4gICAgICBvdXJJbmRleCA9IDA7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sIDApLCBzZWxfbW91c2UpO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSBpZiAob3VySW5kZXggPT0gLTEpIHtcbiAgICAgIG91ckluZGV4ID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VzLmxlbmd0aCA+IDEgJiYgcmFuZ2VzW291ckluZGV4XS5lbXB0eSgpICYmIHR5cGUgPT0gXCJzaW5nbGVcIiAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCkpO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgcmV0dXJuO1xuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKHR5cGUgPT0gXCJyZWN0XCIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgc3RhcnQubGluZSkudGV4dCwgc3RhcnQuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xuICAgICAgICBmb3IgKHZhciBsaW5lID0gTWF0aC5taW4oc3RhcnQubGluZSwgcG9zLmxpbmUpLCBlbmQgPSBNYXRoLm1pbihjbS5sYXN0TGluZSgpLCBNYXRoLm1heChzdGFydC5saW5lLCBwb3MubGluZSkpO1xuICAgICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcbiAgICAgICAgICBpZiAobGVmdCA9PSByaWdodClcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpO1xuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBmaW5kQ29sdW1uKHRleHQsIHJpZ2h0LCB0YWJTaXplKSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFwiKm1vdXNlXCIsIHNjcm9sbDogZmFsc2V9KTtcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkID0gcG9zO1xuICAgICAgICBpZiAodHlwZSAhPSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJkb3VibGVcIilcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhkb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSk7XG4gICAgICAgICAgaWYgKGNtcChyYW5nZS5hbmNob3IsIGFuY2hvcikgPiAwKSB7XG4gICAgICAgICAgICBoZWFkID0gcmFuZ2UuaGVhZDtcbiAgICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZS5hbmNob3I7XG4gICAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICAgIHJhbmdlc1tvdXJJbmRleF0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIGFuY2hvciksIGhlYWQpO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCBvdXJJbmRleCksIHNlbF9tb3VzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcbiAgICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XG4gICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCB0eXBlID09IFwicmVjdFwiKTtcbiAgICAgIGlmICghY3VyKSByZXR1cm47XG4gICAgICBpZiAoY21wKGN1ciwgbGFzdFBvcykgIT0gMCkge1xuICAgICAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgICBleHRlbmRUbyhjdXIpO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MpO1xuICAgICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcbiAgICAgICAgICBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKXtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgZXh0ZW5kKGUpO30pLCAxNTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwO1xuICAgICAgICBpZiAob3V0c2lkZSkgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSByZXR1cm47XG4gICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcbiAgICAgICAgICBleHRlbmQoZSk7XG4gICAgICAgIH0pLCA1MCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZShlKSB7XG4gICAgICBjb3VudGVyID0gSW5maW5pdHk7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWVfYnV0dG9uKGUpKSBkb25lKGUpO1xuICAgICAgZWxzZSBleHRlbmQoZSk7XG4gICAgfSk7XG4gICAgdmFyIHVwID0gb3BlcmF0aW9uKGNtLCBkb25lKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgb24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxuICAvLyBoYW5kbGVycyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gIGZ1bmN0aW9uIGd1dHRlckV2ZW50KGNtLCBlLCB0eXBlLCBwcmV2ZW50LCBzaWduYWxmbikge1xuICAgIHRyeSB7IHZhciBtWCA9IGUuY2xpZW50WCwgbVkgPSBlLmNsaWVudFk7IH1cbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJldmVudCkgZV9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgbGluZUJveCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChtWSA+IGxpbmVCb3guYm90dG9tIHx8ICFoYXNIYW5kbGVyKGNtLCB0eXBlKSkgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcbiAgICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZyA9IGRpc3BsYXkuZ3V0dGVycy5jaGlsZE5vZGVzW2ldO1xuICAgICAgaWYgKGcgJiYgZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCA+PSBtWCkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKTtcbiAgICAgICAgdmFyIGd1dHRlciA9IGNtLm9wdGlvbnMuZ3V0dGVyc1tpXTtcbiAgICAgICAgc2lnbmFsZm4oY20sIHR5cGUsIGNtLCBsaW5lLCBndXR0ZXIsIGUpO1xuICAgICAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ2xpY2tcIiwgdHJ1ZSwgc2lnbmFsTGF0ZXIpO1xuICB9XG5cbiAgLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIHN0cmFuZ2UgSUUgYmVoYXZpb3Igd2hlcmUgaXQnbGwgc29tZXRpbWVzXG4gIC8vIHJlLWZpcmUgYSBzZXJpZXMgb2YgZHJhZy1yZWxhdGVkIGV2ZW50cyByaWdodCBhZnRlciB0aGUgZHJvcCAoIzE1NTEpXG4gIHZhciBsYXN0RHJvcCA9IDA7XG5cbiAgZnVuY3Rpb24gb25Ecm9wKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSlcbiAgICAgIHJldHVybjtcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIGlmIChpZSkgbGFzdERyb3AgPSArbmV3IERhdGU7XG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSksIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKCFwb3MgfHwgaXNSZWFkT25seShjbSkpIHJldHVybjtcbiAgICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDA7XG4gICAgICB2YXIgbG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBpKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgaWYgKCsrcmVhZCA9PSBuKSB7XG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLCB0ZXh0OiBzcGxpdExpbmVzKHRleHQuam9pbihcIlxcblwiKSksIG9yaWdpbjogXCJwYXN0ZVwifTtcbiAgICAgICAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2UpO1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBjaGFuZ2VFbmQoY2hhbmdlKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsb2FkRmlsZShmaWxlc1tpXSwgaSk7XG4gICAgfSBlbHNlIHsgLy8gTm9ybWFsIGRyb3BcbiAgICAgIC8vIERvbid0IGRvIGEgcmVwbGFjZSBpZiB0aGUgZHJvcCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHNlbGVjdGVkIHRleHQuXG4gICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA+IC0xKSB7XG4gICAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dChlKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBlZGl0b3IgaXMgcmUtZm9jdXNlZFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2NtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiAhKG1hYyA/IGUuYWx0S2V5IDogZS5jdHJsS2V5KSlcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgcG9zKSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkKSBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwgc2VsZWN0ZWRbaV0uYW5jaG9yLCBzZWxlY3RlZFtpXS5oZWFkLCBcImRyYWdcIik7XG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0LCBcImFyb3VuZFwiLCBcInBhc3RlXCIpO1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybjsgfVxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgcmV0dXJuO1xuXG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgY20uZ2V0U2VsZWN0aW9uKCkpO1xuXG4gICAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XG4gICAgICB2YXIgaW1nID0gZWx0KFwiaW1nXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XCIpO1xuICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDE7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXG4gICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgaWYgKHByZXN0bykgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTtcbiAgICB9XG4gIH1cblxuICAvLyBTQ1JPTEwgRVZFTlRTXG5cbiAgLy8gU3luYyB0aGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBzY3JvbGxiYXJzLCBlbnN1cmUgdGhlIHZpZXdwb3J0XG4gIC8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCkge1xuICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gdmFsKSA8IDIpIHJldHVybjtcbiAgICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsO1xuICAgIGlmICghZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gdmFsO1xuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodmFsKTtcbiAgICBpZiAoZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pO1xuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICB9XG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXG4gIC8vIGFsaWduZWQuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlcikge1xuICAgIGlmIChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgcmV0dXJuO1xuICAgIHZhbCA9IE1hdGgubWluKHZhbCwgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpO1xuICAgIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IHZhbCkgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7XG4gIH1cblxuICAvLyBTaW5jZSB0aGUgZGVsdGEgdmFsdWVzIHJlcG9ydGVkIG9uIG1vdXNlIHdoZWVsIGV2ZW50cyBhcmVcbiAgLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcbiAgLy8gZ2VuZXJhbGx5IGhvcnJpYmx5IHVucHJlZGljdGFibGUsIHRoaXMgY29kZSBzdGFydHMgYnkgbWVhc3VyaW5nXG4gIC8vIHRoZSBzY3JvbGwgZWZmZWN0IHRoYXQgdGhlIGZpcnN0IGZldyBtb3VzZSB3aGVlbCBldmVudHMgaGF2ZSxcbiAgLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcbiAgLy8gb2Zmc2V0cyBhZnRlcndhcmRzLlxuICAvL1xuICAvLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcbiAgLy8gaXMgdGhhdCBpdCBnaXZlcyB1cyBhIGNoYW5jZSB0byB1cGRhdGUgdGhlIGRpc3BsYXkgYmVmb3JlIHRoZVxuICAvLyBhY3R1YWwgc2Nyb2xsaW5nIGhhcHBlbnMsIHJlZHVjaW5nIGZsaWNrZXJpbmcuXG5cbiAgdmFyIHdoZWVsU2FtcGxlcyA9IDAsIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IG51bGw7XG4gIC8vIEZpbGwgaW4gYSBicm93c2VyLWRldGVjdGVkIHN0YXJ0aW5nIHZhbHVlIG9uIGJyb3dzZXJzIHdoZXJlIHdlXG4gIC8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxuICAvLyBiZWluZyB3cm9uZyB3b3VsZCBqdXN0IGJlIGEgc2xpZ2h0IGZsaWNrZXIgb24gdGhlIGZpcnN0IHdoZWVsXG4gIC8vIHNjcm9sbCAoaWYgaXQgaXMgbGFyZ2UgZW5vdWdoKS5cbiAgaWYgKGllKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjUzO1xuICBlbHNlIGlmIChnZWNrbykgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTU7XG4gIGVsc2UgaWYgKGNocm9tZSkgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43O1xuICBlbHNlIGlmIChzYWZhcmkpIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0xLzM7XG5cbiAgdmFyIHdoZWVsRXZlbnREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSBkeCA9IGUuZGV0YWlsO1xuICAgIGlmIChkeSA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMpIGR5ID0gZS5kZXRhaWw7XG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgZHkgPSBlLndoZWVsRGVsdGE7XG4gICAgcmV0dXJuIHt4OiBkeCwgeTogZHl9O1xuICB9O1xuICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xuICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIHJldHVybiBkZWx0YTtcbiAgfTtcblxuICBmdW5jdGlvbiBvblNjcm9sbFdoZWVsKGNtLCBlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpLCBkeCA9IGRlbHRhLngsIGR5ID0gZGVsdGEueTtcblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlcjtcbiAgICAvLyBRdWl0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzY3JvbGwgaGVyZVxuICAgIGlmICghKGR4ICYmIHNjcm9sbC5zY3JvbGxXaWR0aCA+IHNjcm9sbC5jbGllbnRXaWR0aCB8fFxuICAgICAgICAgIGR5ICYmIHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0KSkgcmV0dXJuO1xuXG4gICAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcbiAgICAvLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXG4gICAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cbiAgICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xuICAgICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodmlld1tpXS5ub2RlID09IGN1cikge1xuICAgICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXI7XG4gICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIGJyb3dzZXJzLCBob3Jpem9udGFsIHNjcm9sbGluZyB3aWxsIGNhdXNlIHJlZHJhd3MgdG9cbiAgICAvLyBoYXBwZW4gYmVmb3JlIHRoZSBndXR0ZXIgaGFzIGJlZW4gcmVhbGlnbmVkLCBjYXVzaW5nIGl0IHRvXG4gICAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gZXN0aW1hdGVkIHBpeGVscy9kZWx0YSB2YWx1ZSwgd2UganVzdCBoYW5kbGUgaG9yaXpvbnRhbFxuICAgIC8vIHNjcm9sbGluZyBlbnRpcmVseSBoZXJlLiBJdCdsbCBiZSBzbGlnaHRseSBvZmYgZnJvbSBuYXRpdmUsIGJ1dFxuICAgIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXG4gICAgaWYgKGR4ICYmICFnZWNrbyAmJiAhcHJlc3RvICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICBpZiAoZHkpXG4gICAgICAgIHNldFNjcm9sbFRvcChjbSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsLnNjcm9sbFRvcCArIGR5ICogd2hlZWxQaXhlbHNQZXJVbml0LCBzY3JvbGwuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsLmNsaWVudEhlaWdodCkpKTtcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxMZWZ0ICsgZHggKiB3aGVlbFBpeGVsc1BlclVuaXQsIHNjcm9sbC5zY3JvbGxXaWR0aCAtIHNjcm9sbC5jbGllbnRXaWR0aCkpKTtcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbDsgLy8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcbiAgICAvLyBzY3JvbGxlZCBpbnRvIHZpZXcgKGlmIHdlIGtub3cgZW5vdWdoIHRvIGVzdGltYXRlIGl0KS5cbiAgICBpZiAoZHkgJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKHBpeGVscyA8IDApIHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKTtcbiAgICAgIGVsc2UgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApO1xuICAgICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdG9wLCBib3R0b206IGJvdH0pO1xuICAgIH1cblxuICAgIGlmICh3aGVlbFNhbXBsZXMgPCAyMCkge1xuICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7IGRpc3BsYXkud2hlZWxTdGFydFkgPSBzY3JvbGwuc2Nyb2xsVG9wO1xuICAgICAgICBkaXNwbGF5LndoZWVsRFggPSBkeDsgZGlzcGxheS53aGVlbERZID0gZHk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBtb3ZlZFggPSBzY3JvbGwuc2Nyb2xsTGVmdCAtIGRpc3BsYXkud2hlZWxTdGFydFg7XG4gICAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZO1xuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XG4gICAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpO1xuICAgICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgcmV0dXJuO1xuICAgICAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9ICh3aGVlbFBpeGVsc1BlclVuaXQgKiB3aGVlbFNhbXBsZXMgKyBzYW1wbGUpIC8gKHdoZWVsU2FtcGxlcyArIDEpO1xuICAgICAgICAgICsrd2hlZWxTYW1wbGVzO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gS0VZIEVWRU5UU1xuXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXG4gIGZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xuICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XG4gICAgICBpZiAoIWJvdW5kKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxuICAgIC8vIGNvbnNpc3RlbnQgdmlldyBvZiB0aGUgZG9jdW1lbnRcbiAgICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1JlYWRPbmx5KGNtKSkgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7XG4gICAgICBpZiAoZHJvcFNoaWZ0KSBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkobmFtZSwgY20uc3RhdGUua2V5TWFwc1tpXSwgaGFuZGxlLCBjbSk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gKGNtLm9wdGlvbnMuZXh0cmFLZXlzICYmIGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmV4dHJhS2V5cywgaGFuZGxlLCBjbSkpXG4gICAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pO1xuICB9XG5cbiAgdmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZDtcbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xuICAgIHZhciBzZXEgPSBjbS5zdGF0ZS5rZXlTZXE7XG4gICAgaWYgKHNlcSkge1xuICAgICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHJldHVybiBcImhhbmRsZWRcIjtcbiAgICAgIHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcbiAgICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsO1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuYW1lID0gc2VxICsgXCIgXCIgKyBuYW1lO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBcIm11bHRpXCIpXG4gICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lO1xuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIpXG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJrZXlIYW5kbGVkXCIsIGNtLCBuYW1lLCBlKTtcblxuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIgfHwgcmVzdWx0ID09IFwibXVsdGlcIikge1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcSAmJiAhcmVzdWx0ICYmIC9cXCckLy50ZXN0KG5hbWUpKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlkb3duIGV2ZW50LlxuICBmdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlc29sdmUgZnVsbCBuYW1lIChpbmNsdWRpbmcgJ1NoaWZ0LScpLiBGYWlsaW5nXG4gICAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcbiAgICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiU2hpZnQtXCIgKyBuYW1lLCBlLCBmdW5jdGlvbihiKSB7cmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7fSlcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgPyAvXmdvW0EtWl0vLnRlc3QoYikgOiBiLm1vdGlvbilcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7XG4gICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKTsgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXCInXCIgKyBjaCArIFwiJ1wiLCBlLFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KTtcbiAgfVxuXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcbiAgICAvLyBJRSBkb2VzIHN0cmFuZ2UgdGhpbmdzIHdpdGggZXNjYXBlLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEgJiYgZS5rZXlDb2RlID09IDI3KSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgdmFyIGNvZGUgPSBlLmtleUNvZGU7XG4gICAgY20uZGlzcGxheS5zaGlmdCA9IGNvZGUgPT0gMTYgfHwgZS5zaGlmdEtleTtcbiAgICB2YXIgaGFuZGxlZCA9IGhhbmRsZUtleUJpbmRpbmcoY20sIGUpO1xuICAgIGlmIChwcmVzdG8pIHtcbiAgICAgIGxhc3RTdG9wcGVkS2V5ID0gaGFuZGxlZCA/IGNvZGUgOiBudWxsO1xuICAgICAgLy8gT3BlcmEgaGFzIG5vIGN1dCBldmVudC4uLiB3ZSB0cnkgdG8gYXQgbGVhc3QgY2F0Y2ggdGhlIGtleSBjb21ib1xuICAgICAgaWYgKCFoYW5kbGVkICYmIGNvZGUgPT0gODggJiYgIWhhc0NvcHlFdmVudCAmJiAobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcbiAgICB9XG5cbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxuICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXG4gICAgICBzaG93Q3Jvc3NIYWlyKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pIHtcbiAgICB2YXIgbGluZURpdiA9IGNtLmRpc3BsYXkubGluZURpdjtcbiAgICBhZGRDbGFzcyhsaW5lRGl2LCBcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpO1xuXG4gICAgZnVuY3Rpb24gdXAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PSAxOCB8fCAhZS5hbHRLZXkpIHtcbiAgICAgICAgcm1DbGFzcyhsaW5lRGl2LCBcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xuICAgICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb24oZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xuICAgIG9uKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVVwKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09IDE2KSB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTtcbiAgICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgcmV0dXJuO1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XG4gICAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm47fVxuICAgIGlmICgocHJlc3RvICYmICghZS53aGljaCB8fCBlLndoaWNoIDwgMTApKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgcmV0dXJuO1xuICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSk7XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHJldHVybjtcbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XG4gIH1cblxuICAvLyBGT0NVUy9CTFVSIEVWRU5UU1xuXG4gIGZ1bmN0aW9uIGRlbGF5Qmx1ckV2ZW50KGNtKSB7XG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgb25CbHVyKGNtKTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1cyhjbSkge1xuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcblxuICAgIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ID09IFwibm9jdXJzb3JcIikgcmV0dXJuO1xuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImZvY3VzXCIsIGNtKTtcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgIC8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XG4gICAgICAvLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXG4gICAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxuICAgICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ICE9IGNtLmRvYy5zZWwpIHtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBpZiAod2Via2l0KSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IC8vIElzc3VlICMxNzMwXG4gICAgICB9XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKTtcbiAgICB9XG4gICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgfVxuICBmdW5jdGlvbiBvbkJsdXIoY20pIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHJldHVybjtcblxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICBzaWduYWwoY20sIFwiYmx1clwiLCBjbSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2lmICghY20uc3RhdGUuZm9jdXNlZCkgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlO30sIDE1MCk7XG4gIH1cblxuICAvLyBDT05URVhUIE1FTlUgSEFORExJTkdcblxuICAvLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcbiAgLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxuICAvLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSByZXR1cm47XG4gICAgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkge1xuICAgIGlmICghaGFzSGFuZGxlcihjbSwgXCJndXR0ZXJDb250ZXh0TWVudVwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDb250ZXh0TWVudVwiLCBmYWxzZSwgc2lnbmFsKTtcbiAgfVxuXG4gIC8vIFVQREFUSU5HXG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcbiAgLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXG4gIHZhciBjaGFuZ2VFbmQgPSBDb2RlTWlycm9yLmNoYW5nZUVuZCA9IGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgIGlmICghY2hhbmdlLnRleHQpIHJldHVybiBjaGFuZ2UudG87XG4gICAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSk7XG4gIH07XG5cbiAgLy8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxuICAvLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cbiAgZnVuY3Rpb24gYWRqdXN0Rm9yQ2hhbmdlKHBvcywgY2hhbmdlKSB7XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS5mcm9tKSA8IDApIHJldHVybiBwb3M7XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpO1xuXG4gICAgdmFyIGxpbmUgPSBwb3MubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpIC0gMSwgY2ggPSBwb3MuY2g7XG4gICAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDtcbiAgICByZXR1cm4gUG9zKGxpbmUsIGNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIG91dC5wdXNoKG5ldyBSYW5nZShhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuYW5jaG9yLCBjaGFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLCBjaGFuZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XG4gICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKVxuICAgICAgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpO1xuICB9XG5cbiAgLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcInN0YXJ0XCIgb3IgXCJhcm91bmRcIi5cbiAgZnVuY3Rpb24gY29tcHV0ZVJlcGxhY2VkU2VsKGRvYywgY2hhbmdlcywgaGludCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXRQb3MoY2hhbmdlLmZyb20sIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIG9sZFByZXYgPSBjaGFuZ2UudG87XG4gICAgICBuZXdQcmV2ID0gdG87XG4gICAgICBpZiAoaGludCA9PSBcImFyb3VuZFwiKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDA7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICB9XG5cbiAgLy8gQWxsb3cgXCJiZWZvcmVDaGFuZ2VcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcbiAgZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICB0bzogY2hhbmdlLnRvLFxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkgeyB0aGlzLmNhbmNlbGVkID0gdHJ1ZTsgfVxuICAgIH07XG4gICAgaWYgKHVwZGF0ZSkgb2JqLnVwZGF0ZSA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcbiAgICAgIGlmIChmcm9tKSB0aGlzLmZyb20gPSBjbGlwUG9zKGRvYywgZnJvbSk7XG4gICAgICBpZiAodG8pIHRoaXMudG8gPSBjbGlwUG9zKGRvYywgdG8pO1xuICAgICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIH07XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcblxuICAgIGlmIChvYmouY2FuY2VsZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7ZnJvbTogb2JqLmZyb20sIHRvOiBvYmoudG8sIHRleHQ6IG9iai50ZXh0LCBvcmlnaW46IG9iai5vcmlnaW59O1xuICB9XG5cbiAgLy8gQXBwbHkgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCwgYW5kIGFkZCBpdCB0byB0aGUgZG9jdW1lbnQnc1xuICAvLyBoaXN0b3J5LCBhbmQgcHJvcGFnYXRpbmcgaXQgdG8gYWxsIGxpbmtlZCBkb2N1bWVudHMuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2UoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB7XG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgaWYgKCFkb2MuY20uY3VyT3ApIHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpO1xuICAgICAgaWYgKGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZUNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlQ2hhbmdlXCIpKSB7XG4gICAgICBjaGFuZ2UgPSBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHRydWUpO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQb3NzaWJseSBzcGxpdCBvciBzdXBwcmVzcyB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwcmVzZW5jZVxuICAgIC8vIG9mIHJlYWQtb25seSBzcGFucyBpbiBpdHMgcmFuZ2UuXG4gICAgdmFyIHNwbGl0ID0gc2F3UmVhZE9ubHlTcGFucyAmJiAhaWdub3JlUmVhZE9ubHkgJiYgcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICBpZiAoc3BsaXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzcGxpdC5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcIlwiXSA6IGNoYW5nZS50ZXh0fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS50ZXh0WzBdID09IFwiXCIgJiYgY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDApIHJldHVybjtcbiAgICB2YXIgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTik7XG5cbiAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgIHZhciByZWJhc2VkID0gW107XG5cbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24oZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgIH1cbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xuICAgIGlmIChkb2MuY20gJiYgZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHJldHVybjtcblxuICAgIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIGV2ZW50LCBzZWxBZnRlciA9IGRvYy5zZWw7XG4gICAgdmFyIHNvdXJjZSA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LmRvbmUgOiBoaXN0LnVuZG9uZSwgZGVzdCA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZTtcblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGEgdXNlYWJsZSBldmVudCAoc28gdGhhdCBjdHJsLXogd29uJ3RcbiAgICAvLyBuZWVkbGVzc2x5IGNsZWFyIHNlbGVjdGlvbiBldmVudHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gc291cmNlW2ldO1xuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHJldHVybjtcbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgZXZlbnQgPSBzb3VyY2UucG9wKCk7XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xuICAgICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwge2NsZWFyUmVkbzogZmFsc2V9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsQWZ0ZXIgPSBldmVudDtcbiAgICAgIH1cbiAgICAgIGVsc2UgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XG4gICAgLy8gc3RhY2sgKHJlZG8gd2hlbiB1bmRvaW5nLCBhbmQgdmljZSB2ZXJzYSkuXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XG4gICAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSk7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcblxuICAgIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKTtcblxuICAgIGZvciAodmFyIGkgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY2hhbmdlID0gZXZlbnQuY2hhbmdlc1tpXTtcbiAgICAgIGNoYW5nZS5vcmlnaW4gPSB0eXBlO1xuICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCBmYWxzZSkpIHtcbiAgICAgICAgc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIGlmICghaSAmJiBkb2MuY20pIGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pO1xuICAgICAgdmFyIHJlYmFzZWQgPSBbXTtcblxuICAgICAgLy8gUHJvcGFnYXRlIHRvIHRoZSBsaW5rZWQgZG9jdW1lbnRzXG4gICAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24oZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcbiAgLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XG4gICAgaWYgKGRpc3RhbmNlID09IDApIHJldHVybjtcbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKSk7XG4gICAgfSksIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICBpZiAoZG9jLmNtKSB7XG4gICAgICByZWdDaGFuZ2UoZG9jLmNtLCBkb2MuZmlyc3QsIGRvYy5maXJzdCAtIGRpc3RhbmNlLCBkaXN0YW5jZSk7XG4gICAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKylcbiAgICAgICAgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XG4gIC8vIChub3QgbGlua2VkIG9uZXMpLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApXG4gICAgICByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZVNpbmdsZURvYykoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucyk7XG5cbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPiBkb2MubGFzdExpbmUoKSkgcmV0dXJuO1xuXG4gICAgLy8gQ2xpcCB0aGUgY2hhbmdlIHRvIHRoZSBzaXplIG9mIHRoaXMgZG9jXG4gICAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgIHZhciBzaGlmdCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoZG9jLmZpcnN0IC0gY2hhbmdlLmZyb20ubGluZSk7XG4gICAgICBzaGlmdERvYyhkb2MsIHNoaWZ0KTtcbiAgICAgIGNoYW5nZSA9IHtmcm9tOiBQb3MoZG9jLmZpcnN0LCAwKSwgdG86IFBvcyhjaGFuZ2UudG8ubGluZSArIHNoaWZ0LCBjaGFuZ2UudG8uY2gpLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtsc3QoY2hhbmdlLnRleHQpXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSBkb2MubGFzdExpbmUoKTtcbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPiBsYXN0KSB7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbY2hhbmdlLnRleHRbMF1dLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59O1xuICAgIH1cblxuICAgIGNoYW5nZS5yZW1vdmVkID0gZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuXG4gICAgaWYgKCFzZWxBZnRlcikgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGlmIChkb2MuY20pIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihkb2MuY20sIGNoYW5nZSwgc3BhbnMpO1xuICAgIGVsc2UgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucyk7XG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsQWZ0ZXIsIHNlbF9kb250U2Nyb2xsKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSB0aGUgaW50ZXJhY3Rpb24gb2YgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSBlZGl0b3JcbiAgLy8gdGhhdCB0aGlzIGRvY3VtZW50IGlzIHBhcnQgb2YuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihjbSwgY2hhbmdlLCBzcGFucykge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvO1xuXG4gICAgdmFyIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlLCBjaGVja1dpZHRoU3RhcnQgPSBmcm9tLmxpbmU7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgY2hlY2tXaWR0aFN0YXJ0ID0gbGluZU5vKHZpc3VhbExpbmUoZ2V0TGluZShkb2MsIGZyb20ubGluZSkpKTtcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XG4gICAgICAgICAgcmVjb21wdXRlTWF4TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRvYy5zZWwuY29udGFpbnMoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPiAtMSlcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTtcblxuICAgIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KGNtKSk7XG5cbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkanVzdCBmcm9udGllciwgc2NoZWR1bGUgd29ya2VyXG4gICAgZG9jLmZyb250aWVyID0gTWF0aC5taW4oZG9jLmZyb250aWVyLCBmcm9tLmxpbmUpO1xuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XG4gICAgaWYgKGNoYW5nZS5mdWxsKVxuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBlbHNlIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxuICAgICAgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7XG4gICAgZWxzZVxuICAgICAgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBsZW5kaWZmKTtcblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHNpZ25hbExhdGVyKGNtLCBcImNoYW5nZVwiLCBjbSwgb2JqKTtcbiAgICAgIGlmIChjaGFuZ2VzSGFuZGxlcikgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTtcbiAgICB9XG4gICAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgaWYgKCF0bykgdG8gPSBmcm9tO1xuICAgIGlmIChjbXAodG8sIGZyb20pIDwgMCkgeyB2YXIgdG1wID0gdG87IHRvID0gZnJvbTsgZnJvbSA9IHRtcDsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSBjb2RlID0gc3BsaXRMaW5lcyhjb2RlKTtcbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcbiAgfVxuXG4gIC8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXG5cbiAgLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XG4gIC8vIHNjcm9sbGVkIG91dCBvZiB2aWV3LCB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUuXG4gIGZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIHtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcIikpIHJldHVybjtcblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgYm94ID0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9TY3JvbGwgPSBudWxsO1xuICAgIGlmIChjb29yZHMudG9wICsgYm94LnRvcCA8IDApIGRvU2Nyb2xsID0gdHJ1ZTtcbiAgICBlbHNlIGlmIChjb29yZHMuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIGRvU2Nyb2xsID0gZmFsc2U7XG4gICAgaWYgKGRvU2Nyb2xsICE9IG51bGwgJiYgIXBoYW50b20pIHtcbiAgICAgIHZhciBzY3JvbGxOb2RlID0gZWx0KFwiZGl2XCIsIFwiXFx1MjAwYlwiLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY29vcmRzLnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXCJweDsgaGVpZ2h0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY29vcmRzLmJvdHRvbSAtIGNvb3Jkcy50b3AgKyBzY3JvbGxHYXAoY20pICsgZGlzcGxheS5iYXJIZWlnaHQpICsgXCJweDsgbGVmdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgKyBcInB4OyB3aWR0aDogMnB4O1wiKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xuICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChzY3JvbGxOb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBwb3NpdGlvbiBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KSwgdmVyaWZ5aW5nIHRoYXRcbiAgLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxuICAvLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXG4gIGZ1bmN0aW9uIHNjcm9sbFBvc0ludG9WaWV3KGNtLCBwb3MsIGVuZCwgbWFyZ2luKSB7XG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSBtYXJnaW4gPSAwO1xuICAgIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlLCBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcyk7XG4gICAgICB2YXIgZW5kQ29vcmRzID0gIWVuZCB8fCBlbmQgPT0gcG9zID8gY29vcmRzIDogY3Vyc29yQ29vcmRzKGNtLCBlbmQpO1xuICAgICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5ib3R0b20sIGVuZENvb3Jkcy5ib3R0b20pICsgbWFyZ2luKTtcbiAgICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHN0YXJ0VG9wKSA+IDEpIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNoYW5nZWQpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG5cbiAgLy8gU2Nyb2xsIGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLlxuICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjbSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTtcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBuZWVkZWQgdG8gc2Nyb2xsIHRoZSBnaXZlblxuICAvLyByZWN0YW5nbGUgaW50byB2aWV3LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHNjcm9sbFRvcCBhbmRcbiAgLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxuICAvLyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHBvc2l0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRqdXN0ZWQuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpO1xuICAgIGlmICh5MSA8IDApIHkxID0gMDtcbiAgICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB2YXIgc2NyZWVuID0gZGlzcGxheUhlaWdodChjbSksIHJlc3VsdCA9IHt9O1xuICAgIGlmICh5MiAtIHkxID4gc2NyZWVuKSB5MiA9IHkxICsgc2NyZWVuO1xuICAgIHZhciBkb2NCb3R0b20gPSBjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoZGlzcGxheSk7XG4gICAgdmFyIGF0VG9wID0geTEgPCBzbmFwTWFyZ2luLCBhdEJvdHRvbSA9IHkyID4gZG9jQm90dG9tIC0gc25hcE1hcmdpbjtcbiAgICBpZiAoeTEgPCBzY3JlZW50b3ApIHtcbiAgICAgIHJlc3VsdC5zY3JvbGxUb3AgPSBhdFRvcCA/IDAgOiB5MTtcbiAgICB9IGVsc2UgaWYgKHkyID4gc2NyZWVudG9wICsgc2NyZWVuKSB7XG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4oeTEsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHkyKSAtIHNjcmVlbik7XG4gICAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgcmVzdWx0LnNjcm9sbFRvcCA9IG5ld1RvcDtcbiAgICB9XG5cbiAgICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQ7XG4gICAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggOiAwKTtcbiAgICB2YXIgdG9vV2lkZSA9IHgyIC0geDEgPiBzY3JlZW53O1xuICAgIGlmICh0b29XaWRlKSB4MiA9IHgxICsgc2NyZWVudztcbiAgICBpZiAoeDEgPCAxMClcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0gMDtcbiAgICBlbHNlIGlmICh4MSA8IHNjcmVlbmxlZnQpXG4gICAgICByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHgxIC0gKHRvb1dpZGUgPyAwIDogMTApKTtcbiAgICBlbHNlIGlmICh4MiA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0geDIgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBTdG9yZSBhIHJlbGF0aXZlIGFkanVzdG1lbnQgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICAvLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cbiAgZnVuY3Rpb24gYWRkVG9TY3JvbGxQb3MoY20sIGxlZnQsIHRvcCkge1xuICAgIGlmIChsZWZ0ICE9IG51bGwgfHwgdG9wICE9IG51bGwpIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgaWYgKGxlZnQgIT0gbnVsbClcbiAgICAgIGNtLmN1ck9wLnNjcm9sbExlZnQgPSAoY20uY3VyT3Auc2Nyb2xsTGVmdCA9PSBudWxsID8gY20uZG9jLnNjcm9sbExlZnQgOiBjbS5jdXJPcC5zY3JvbGxMZWZ0KSArIGxlZnQ7XG4gICAgaWYgKHRvcCAhPSBudWxsKVxuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3A7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXG4gIC8vIHNob3duLlxuICBmdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCksIGZyb20gPSBjdXIsIHRvID0gY3VyO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGZyb20gPSBjdXIuY2ggPyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpIDogY3VyO1xuICAgICAgdG8gPSBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgIH1cbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4sIGlzQ3Vyc29yOiB0cnVlfTtcbiAgfVxuXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xuICAvLyAnc2ltdWxhdGVzJyBzY3JvbGxpbmcgdGhhdCBwb3NpdGlvbiBpbnRvIHZpZXcgaW4gYSBjaGVhcCB3YXksIHNvXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5jdXJPcC5zY3JvbGxUb1BvcztcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50byk7XG4gICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gcmFuZ2UubWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5yaWdodCwgdG8ucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xuICAgICAgY20uc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQVBJIFVUSUxJVElFU1xuXG4gIC8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFwic21hcnRcIixcbiAgLy8gXCJhZGRcIi9udWxsLCBcInN1YnRyYWN0XCIsIG9yIFwicHJldlwiLiBXaGVuIGFnZ3Jlc3NpdmUgaXMgZmFsc2VcbiAgLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxuICAvLyBsaW5lcyBhcmUgbm90IGluZGVudGVkLCBhbmQgcGxhY2VzIHdoZXJlIHRoZSBtb2RlIHJldHVybnMgUGFzc1xuICAvLyBhcmUgbGVmdCBhbG9uZS5cbiAgZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgc3RhdGU7XG4gICAgaWYgKGhvdyA9PSBudWxsKSBob3cgPSBcImFkZFwiO1xuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSBob3cgPSBcInByZXZcIjtcbiAgICAgIGVsc2Ugc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbik7XG4gICAgfVxuXG4gICAgdmFyIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgIHZhciBjdXJTcGFjZVN0cmluZyA9IGxpbmUudGV4dC5tYXRjaCgvXlxccyovKVswXSwgaW5kZW50YXRpb247XG4gICAgaWYgKCFhZ2dyZXNzaXZlICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dCkpIHtcbiAgICAgIGluZGVudGF0aW9uID0gMDtcbiAgICAgIGhvdyA9IFwibm90XCI7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dCk7XG4gICAgICBpZiAoaW5kZW50YXRpb24gPT0gUGFzcyB8fCBpbmRlbnRhdGlvbiA+IDE1MCkge1xuICAgICAgICBpZiAoIWFnZ3Jlc3NpdmUpIHJldHVybjtcbiAgICAgICAgaG93ID0gXCJwcmV2XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChob3cgPT0gXCJwcmV2XCIpIHtcbiAgICAgIGlmIChuID4gZG9jLmZpcnN0KSBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpO1xuICAgICAgZWxzZSBpbmRlbnRhdGlvbiA9IDA7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJhZGRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInN1YnRyYWN0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBob3c7XG4gICAgfVxuICAgIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xuXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXG4gICAgICBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fVxuICAgIGlmIChwb3MgPCBpbmRlbnRhdGlvbikgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTtcblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwb3MgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgbmV3IFJhbmdlKHBvcywgcG9zKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IGZvciBhcHBseWluZyBhIGNoYW5nZSB0byBhIGxpbmUgYnkgaGFuZGxlIG9yIG51bWJlcixcbiAgLy8gcmV0dXJuaW5nIHRoZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXJpbmcgdGhlIGxpbmUgYXNcbiAgLy8gY2hhbmdlZC5cbiAgZnVuY3Rpb24gY2hhbmdlTGluZShkb2MsIGhhbmRsZSwgY2hhbmdlVHlwZSwgb3ApIHtcbiAgICB2YXIgbm8gPSBoYW5kbGUsIGxpbmUgPSBoYW5kbGU7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgPT0gXCJudW1iZXJcIikgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpO1xuICAgIGVsc2Ugbm8gPSBsaW5lTm8oaGFuZGxlKTtcbiAgICBpZiAobm8gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBubywgY2hhbmdlVHlwZSk7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cblxuICAvLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cbiAgZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgY29tcHV0ZSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdO1xuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXG4gICAgLy8gcmFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xuICAgICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGtpbGwucG9wKCk7XG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xuICAgICAgICAgIHRvS2lsbC5mcm9tID0gcmVwbGFjZWQuZnJvbTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2lsbC5wdXNoKHRvS2lsbCk7XG4gICAgfVxuICAgIC8vIE5leHQsIHJlbW92ZSB0aG9zZSBhY3R1YWwgcmFuZ2VzLlxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIFwiXCIsIGtpbGxbaV0uZnJvbSwga2lsbFtpXS50bywgXCIrZGVsZXRlXCIpO1xuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXQgZG9lc24ndFxuICAvLyBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcIndvcmRcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yIFwiZ3JvdXBcIiAodG9cbiAgLy8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvciBub24td29yZC1ub24td2hpdGVzcGFjZVxuICAvLyBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9scyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0XG4gIC8vIHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkcyB0aGUgbmV4dCBpbmRleCBpbiB0aGVcbiAgLy8gc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG4gIC8vIHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxuICAvLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgIHZhciBsaW5lID0gcG9zLmxpbmUsIGNoID0gcG9zLmNoLCBvcmlnRGlyID0gZGlyO1xuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpO1xuICAgIHZhciBwb3NzaWJsZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xuICAgICAgdmFyIGwgPSBsaW5lICsgZGlyO1xuICAgICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgcmV0dXJuIChwb3NzaWJsZSA9IGZhbHNlKTtcbiAgICAgIGxpbmUgPSBsO1xuICAgICAgcmV0dXJuIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XG4gICAgICB2YXIgbmV4dCA9ICh2aXN1YWxseSA/IG1vdmVWaXN1YWxseSA6IG1vdmVMb2dpY2FsbHkpKGxpbmVPYmosIGNoLCBkaXIsIHRydWUpO1xuICAgICAgaWYgKG5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWJvdW5kVG9MaW5lICYmIGZpbmROZXh0TGluZSgpKSB7XG4gICAgICAgICAgaWYgKHZpc3VhbGx5KSBjaCA9IChkaXIgPCAwID8gbGluZVJpZ2h0IDogbGluZUxlZnQpKGxpbmVPYmopO1xuICAgICAgICAgIGVsc2UgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gKHBvc3NpYmxlID0gZmFsc2UpO1xuICAgICAgfSBlbHNlIGNoID0gbmV4dDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh1bml0ID09IFwiY2hhclwiKSBtb3ZlT25jZSgpO1xuICAgIGVsc2UgaWYgKHVuaXQgPT0gXCJjb2x1bW5cIikgbW92ZU9uY2UodHJ1ZSk7XG4gICAgZWxzZSBpZiAodW5pdCA9PSBcIndvcmRcIiB8fCB1bml0ID09IFwiZ3JvdXBcIikge1xuICAgICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXCJncm91cFwiO1xuICAgICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSBicmVhaztcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVPYmoudGV4dC5jaGFyQXQoY2gpIHx8IFwiXFxuXCI7XG4gICAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcIndcIlxuICAgICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFwiXFxuXCIgPyBcIm5cIlxuICAgICAgICAgIDogIWdyb3VwIHx8IC9cXHMvLnRlc3QoY3VyKSA/IG51bGxcbiAgICAgICAgICA6IFwicFwiO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB0eXBlID0gXCJzXCI7XG4gICAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xuICAgICAgICAgIGlmIChkaXIgPCAwKSB7ZGlyID0gMTsgbW92ZU9uY2UoKTt9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSkgc2F3VHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBQb3MobGluZSwgY2gpLCBvcmlnRGlyLCB0cnVlKTtcbiAgICBpZiAoIXBvc3NpYmxlKSByZXN1bHQuaGl0U2lkZSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuICAvLyBcInBhZ2VcIiBvciBcImxpbmVcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5O1xuICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB5ID0gcG9zLnRvcCArIGRpciAqIChwYWdlU2l6ZSAtIChkaXIgPCAwID8gMS41IDogLjUpICogdGV4dEhlaWdodChjbS5kaXNwbGF5KSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwibGluZVwiKSB7XG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcbiAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIGJyZWFrO1xuICAgICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhazsgfVxuICAgICAgeSArPSBkaXIgKiA1O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLy8gRURJVE9SIE1FVEhPRFNcblxuICAvLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xuICAvLyAnd3JhcCBmIGluIGFuIG9wZXJhdGlvbiwgcGVyZm9ybWVkIG9uIGl0cyBgdGhpc2AgcGFyYW1ldGVyJy5cblxuICAvLyBUaGlzIGlzIG5vdCB0aGUgY29tcGxldGUgc2V0IG9mIGVkaXRvciBtZXRob2RzLiBNb3N0IG9mIHRoZVxuICAvLyBtZXRob2RzIGRlZmluZWQgb24gdGhlIERvYyB0eXBlIGFyZSBhbHNvIGluamVjdGVkIGludG9cbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcbiAgLy8gY29udmVuaWVuY2UuXG5cbiAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvZGVNaXJyb3IsXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCl7d2luZG93LmZvY3VzKCk7IHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpO30sXG5cbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLCBvbGQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcIm1vZGVcIikgcmV0dXJuO1xuICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG4gICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcbiAgICAgICAgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpO1xuICAgIH0sXG5cbiAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXTt9LFxuICAgIGdldERvYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jO30sXG5cbiAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uKG1hcCwgYm90dG9tKSB7XG4gICAgICB0aGlzLnN0YXRlLmtleU1hcHNbYm90dG9tID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oZ2V0S2V5TWFwKG1hcCkpO1xuICAgIH0sXG4gICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcbiAgICAgIHZhciBtYXBzID0gdGhpcy5zdGF0ZS5rZXlNYXBzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xuICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlID0gc3BlYy50b2tlbiA/IHNwZWMgOiBDb2RlTWlycm9yLmdldE1vZGUodGhpcy5vcHRpb25zLCBzcGVjKTtcbiAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpO1xuICAgICAgdGhpcy5zdGF0ZS5vdmVybGF5cy5wdXNoKHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlfSk7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICB9KSxcbiAgICByZW1vdmVPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjKSB7XG4gICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY3VyID0gb3ZlcmxheXNbaV0ubW9kZVNwZWM7XG4gICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcbiAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuXG4gICAgaW5kZW50TGluZTogbWV0aG9kT3AoZnVuY3Rpb24obiwgZGlyLCBhZ2dyZXNzaXZlKSB7XG4gICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoZGlyID09IG51bGwpIGRpciA9IHRoaXMub3B0aW9ucy5zbWFydEluZGVudCA/IFwic21hcnRcIiA6IFwicHJldlwiO1xuICAgICAgICBlbHNlIGRpciA9IGRpciA/IFwiYWRkXCIgOiBcInN1YnRyYWN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpO1xuICAgIH0pLFxuICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpO1xuICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxO1xuICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgKytqKVxuICAgICAgICAgICAgaW5kZW50TGluZSh0aGlzLCBqLCBob3cpO1xuICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzO1xuICAgICAgICAgIGlmIChmcm9tLmNoID09IDAgJiYgcmFuZ2VzLmxlbmd0aCA9PSBuZXdSYW5nZXMubGVuZ3RoICYmIG5ld1Jhbmdlc1tpXS5mcm9tKCkuY2ggPiAwKVxuICAgICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmhlYWQubGluZSA+IGVuZCkge1xuICAgICAgICAgIGluZGVudExpbmUodGhpcywgcmFuZ2UuaGVhZC5saW5lLCBob3csIHRydWUpO1xuICAgICAgICAgIGVuZCA9IHJhbmdlLmhlYWQubGluZTtcbiAgICAgICAgICBpZiAoaSA9PSB0aGlzLmRvYy5zZWwucHJpbUluZGV4KSBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG5cbiAgICAvLyBGZXRjaCB0aGUgcGFyc2VyIHRva2VuIGZvciBhIGdpdmVuIGNoYXJhY3Rlci4gVXNlZnVsIGZvciBoYWNrc1xuICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cbiAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbihwb3MsIHByZWNpc2UpIHtcbiAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKTtcbiAgICB9LFxuXG4gICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpO1xuICAgIH0sXG5cbiAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpO1xuICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKTtcbiAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgaWYgKGNoID09IDApIHR5cGUgPSBzdHlsZXNbMl07XG4gICAgICBlbHNlIGZvciAoOzspIHtcbiAgICAgICAgdmFyIG1pZCA9IChiZWZvcmUgKyBhZnRlcikgPj4gMTtcbiAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIGFmdGVyID0gbWlkO1xuICAgICAgICBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIGJlZm9yZSA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgeyB0eXBlID0gc3R5bGVzW21pZCAqIDIgKyAyXTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFwiY20tb3ZlcmxheSBcIikgOiAtMTtcbiAgICAgIHJldHVybiBjdXQgPCAwID8gdHlwZSA6IGN1dCA9PSAwID8gbnVsbCA6IHR5cGUuc2xpY2UoMCwgY3V0IC0gMSk7XG4gICAgfSxcblxuICAgIGdldE1vZGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGU7XG4gICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSByZXR1cm4gbW9kZTtcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCB0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZTtcbiAgICB9LFxuXG4gICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXTtcbiAgICB9LFxuXG4gICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XG4gICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGZvdW5kO1xuICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pO1xuICAgICAgfSBlbHNlIGlmIChtb2RlW3R5cGVdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVt0eXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dO1xuICAgICAgICAgIGlmICh2YWwpIGZvdW5kLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb2RlLmhlbHBlclR5cGUgJiYgaGVscFttb2RlLmhlbHBlclR5cGVdKSB7XG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVscFttb2RlLm5hbWVdKSB7XG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXIgPSBoZWxwLl9nbG9iYWxbaV07XG4gICAgICAgIGlmIChjdXIucHJlZChtb2RlLCB0aGlzKSAmJiBpbmRleE9mKGZvdW5kLCBjdXIudmFsKSA9PSAtMSlcbiAgICAgICAgICBmb3VuZC5wdXNoKGN1ci52YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2M7XG4gICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpO1xuICAgICAgcmV0dXJuIGdldFN0YXRlQmVmb3JlKHRoaXMsIGxpbmUgKyAxLCBwcmVjaXNlKTtcbiAgICB9LFxuXG4gICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xuICAgICAgdmFyIHBvcywgcmFuZ2UgPSB0aGlzLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHBvcyA9IHJhbmdlLmhlYWQ7XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXCJvYmplY3RcIikgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgc3RhcnQpO1xuICAgICAgZWxzZSBwb3MgPSBzdGFydCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XG4gICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgfSxcblxuICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xuICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgfSxcblxuICAgIGNvb3Jkc0NoYXI6IGZ1bmN0aW9uKGNvb3JkcywgbW9kZSkge1xuICAgICAgY29vcmRzID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIGNvb3JkcywgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgfSxcblxuICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XG4gICAgICBoZWlnaHQgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywge3RvcDogaGVpZ2h0LCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wO1xuICAgICAgcmV0dXJuIGxpbmVBdEhlaWdodCh0aGlzLmRvYywgaGVpZ2h0ICsgdGhpcy5kaXNwbGF5LnZpZXdPZmZzZXQpO1xuICAgIH0sXG4gICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlKSB7XG4gICAgICB2YXIgZW5kID0gZmFsc2UsIGxpbmVPYmo7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDE7XG4gICAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIGxpbmUgPSB0aGlzLmRvYy5maXJzdDtcbiAgICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cbiAgICAgICAgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZU9iaiA9IGxpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKHRoaXMsIGxpbmVPYmosIHt0b3A6IDAsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiKS50b3AgK1xuICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMCk7XG4gICAgfSxcblxuICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KTsgfSxcbiAgICBkZWZhdWx0Q2hhcldpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJXaWR0aCh0aGlzLmRpc3BsYXkpOyB9LFxuXG4gICAgc2V0R3V0dGVyTWFya2VyOiBtZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMuZG9jLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGNsZWFyR3V0dGVyOiBtZXRob2RPcChmdW5jdGlvbihndXR0ZXJJRCkge1xuICAgICAgdmFyIGNtID0gdGhpcywgZG9jID0gY20uZG9jLCBpID0gZG9jLmZpcnN0O1xuICAgICAgZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcImd1dHRlclwiKTtcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgICsraTtcbiAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgbGluZUluZm86IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMuZG9jLCBsaW5lKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBuID0gbGluZTtcbiAgICAgICAgbGluZSA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICBpZiAoIWxpbmUpIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c307XG4gICAgfSxcblxuICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfTt9LFxuXG4gICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcbiAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5O1xuICAgICAgcG9zID0gY3Vyc29yQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcykpO1xuICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICBkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgaWYgKHZlcnQgPT0gXCJvdmVyXCIpIHtcbiAgICAgICAgdG9wID0gcG9zLnRvcDtcbiAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcImFib3ZlXCIgfHwgdmVydCA9PSBcIm5lYXJcIikge1xuICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xuICAgICAgICAvLyBEZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGFib3ZlIChpZiBzcGVjaWZpZWQgYW5kIHBvc3NpYmxlKTsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gcG9zaXRpb25pbmcgYmVsb3dcbiAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBlbHNlIGlmIChwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPD0gdnNwYWNlKVxuICAgICAgICAgIHRvcCA9IHBvcy5ib3R0b207XG4gICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcbiAgICAgICAgICBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaG9yaXogPT0gXCJsZWZ0XCIpIGxlZnQgPSAwO1xuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDI7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLCBsZWZ0LCB0b3AsIGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCB0b3AgKyBub2RlLm9mZnNldEhlaWdodCk7XG4gICAgfSxcblxuICAgIHRyaWdnZXJPbktleURvd246IG1ldGhvZE9wKG9uS2V5RG93biksXG4gICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxuICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxuXG4gICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXG4gICAgICAgIHJldHVybiBjb21tYW5kc1tjbWRdKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0cmlnZ2VyRWxlY3RyaWM6IG1ldGhvZE9wKGZ1bmN0aW9uKHRleHQpIHsgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpOyB9KSxcblxuICAgIGZpbmRQb3NIOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIHZpc3VhbGx5KSB7XG4gICAgICB2YXIgZGlyID0gMTtcbiAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzLmRvYywgY3VyLCBkaXIsIHVuaXQsIHZpc3VhbGx5KTtcbiAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXI7XG4gICAgfSxcblxuICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgIHZhciBjbSA9IHRoaXM7XG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgY20uZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxuICAgICAgICAgIHJldHVybiBmaW5kUG9zSChjbS5kb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgY20ub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpO1xuICAgICAgfSwgc2VsX21vdmUpO1xuICAgIH0pLFxuXG4gICAgZGVsZXRlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvYztcbiAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCIrZGVsZXRlXCIpO1xuICAgICAgZWxzZVxuICAgICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn07XG4gICAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgZmluZFBvc1Y6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xuICAgICAgdmFyIGRpciA9IDEsIHggPSBnb2FsQ29sdW1uO1xuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHModGhpcywgY3VyLCBcImRpdlwiKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkgeCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgICBlbHNlIGNvb3Jkcy5sZWZ0ID0geDtcbiAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcywgY29vcmRzLCBkaXIsIHVuaXQpO1xuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9LFxuXG4gICAgbW92ZVY6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgdmFyIGNtID0gdGhpcywgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW107XG4gICAgICB2YXIgY29sbGFwc2UgPSAhY20uZGlzcGxheS5zaGlmdCAmJiAhZG9jLmV4dGVuZCAmJiBkb2Muc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICBkb2MuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChjb2xsYXBzZSlcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XG4gICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCByYW5nZS5oZWFkLCBcImRpdlwiKTtcbiAgICAgICAgaWYgKHJhbmdlLmdvYWxDb2x1bW4gIT0gbnVsbCkgaGVhZFBvcy5sZWZ0ID0gcmFuZ2UuZ29hbENvbHVtbjtcbiAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpO1xuICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YoY20sIGhlYWRQb3MsIGRpciwgdW5pdCk7XG4gICAgICAgIGlmICh1bml0ID09IFwicGFnZVwiICYmIHJhbmdlID09IGRvYy5zZWwucHJpbWFyeSgpKVxuICAgICAgICAgIGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBjaGFyQ29vcmRzKGNtLCBwb3MsIFwiZGl2XCIpLnRvcCAtIGhlYWRQb3MudG9wKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgIGlmIChnb2Fscy5sZW5ndGgpIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTtcbiAgICB9KSxcblxuICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cbiAgICBmaW5kV29yZEF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcbiAgICAgIHZhciBzdGFydCA9IHBvcy5jaCwgZW5kID0gcG9zLmNoO1xuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgIGlmICgocG9zLnhSZWwgPCAwIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIC0tc3RhcnQ7IGVsc2UgKytlbmQ7XG4gICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XG4gICAgICAgIHZhciBjaGVjayA9IGlzV29yZENoYXIoc3RhcnRDaGFyLCBoZWxwZXIpXG4gICAgICAgICAgPyBmdW5jdGlvbihjaCkgeyByZXR1cm4gaXNXb3JkQ2hhcihjaCwgaGVscGVyKTsgfVxuICAgICAgICAgIDogL1xccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24oY2gpIHtyZXR1cm4gL1xccy8udGVzdChjaCk7fVxuICAgICAgICAgIDogZnVuY3Rpb24oY2gpIHtyZXR1cm4gIS9cXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKTt9O1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSAtLXN0YXJ0O1xuICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpICsrZW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpO1xuXG4gICAgICBzaWduYWwodGhpcywgXCJvdmVyd3JpdGVUb2dnbGVcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xuICAgIH0sXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gYWN0aXZlRWx0KCk7IH0sXG5cbiAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKTtcbiAgICAgIGlmICh4ICE9IG51bGwpIHRoaXMuY3VyT3Auc2Nyb2xsTGVmdCA9IHg7XG4gICAgICBpZiAoeSAhPSBudWxsKSB0aGlzLmN1ck9wLnNjcm9sbFRvcCA9IHk7XG4gICAgfSksXG4gICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgICByZXR1cm4ge2xlZnQ6IHNjcm9sbGVyLnNjcm9sbExlZnQsIHRvcDogc2Nyb2xsZXIuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxlci5zY3JvbGxXaWR0aCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJXaWR0aCxcbiAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBkaXNwbGF5SGVpZ2h0KHRoaXMpLCBjbGllbnRXaWR0aDogZGlzcGxheVdpZHRoKHRoaXMpfTtcbiAgICB9LFxuXG4gICAgc2Nyb2xsSW50b1ZpZXc6IG1ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4pIHtcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9O1xuICAgICAgICBpZiAobWFyZ2luID09IG51bGwpIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IHJhbmdlLCB0bzogbnVsbH07XG4gICAgICB9XG4gICAgICBpZiAoIXJhbmdlLnRvKSByYW5nZS50byA9IHJhbmdlLmZyb207XG4gICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMDtcblxuICAgICAgaWYgKHJhbmdlLmZyb20ubGluZSAhPSBudWxsKSB7XG4gICAgICAgIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3ModGhpcywgTWF0aC5taW4ocmFuZ2UuZnJvbS5sZWZ0LCByYW5nZS50by5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocmFuZ2UuZnJvbS50b3AsIHJhbmdlLnRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJhbmdlLmZyb20ucmlnaHQsIHJhbmdlLnRvLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocmFuZ2UuZnJvbS5ib3R0b20sIHJhbmdlLnRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgc2V0U2l6ZTogbWV0aG9kT3AoZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNtID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGludGVycHJldCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIiB8fCAvXlxcZCskLy50ZXN0KFN0cmluZyh2YWwpKSA/IHZhbCArIFwicHhcIiA6IHZhbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCAhPSBudWxsKSBjbS5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGggPSBpbnRlcnByZXQod2lkdGgpO1xuICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSBjbS5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcyk7XG4gICAgICB2YXIgbGluZU5vID0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICAgIGNtLmRvYy5pdGVyKGxpbmVObywgY20uZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKGxpbmUud2lkZ2V0c1tpXS5ub0hTY3JvbGwpIHsgcmVnTGluZUNoYW5nZShjbSwgbGluZU5vLCBcIndpZGdldFwiKTsgYnJlYWs7IH1cbiAgICAgICAgKytsaW5lTm87XG4gICAgICB9KTtcbiAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHNpZ25hbChjbSwgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgIH0pLFxuXG4gICAgb3BlcmF0aW9uOiBmdW5jdGlvbihmKXtyZXR1cm4gcnVuSW5PcCh0aGlzLCBmKTt9LFxuXG4gICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApO1xuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UodGhpcyk7XG4gICAgICBpZiAob2xkSGVpZ2h0ID09IG51bGwgfHwgTWF0aC5hYnMob2xkSGVpZ2h0IC0gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKSA+IC41KVxuICAgICAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpO1xuICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICB9KSxcblxuICAgIHN3YXBEb2M6IG1ldGhvZE9wKGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgb2xkLmNtID0gbnVsbDtcbiAgICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgIHRoaXMuc2Nyb2xsVG8oZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApO1xuICAgICAgdGhpcy5jdXJPcC5mb3JjZVNjcm9sbCA9IHRydWU7XG4gICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgIHJldHVybiBvbGQ7XG4gICAgfSksXG5cbiAgICBnZXRJbnB1dEZpZWxkOiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKTt9LFxuICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcjt9LFxuICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyO30sXG4gICAgZ2V0R3V0dGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnM7fVxuICB9O1xuICBldmVudE1peGluKENvZGVNaXJyb3IpO1xuXG4gIC8vIE9QVElPTiBERUZBVUxUU1xuXG4gIC8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgdmFyIGRlZmF1bHRzID0gQ29kZU1pcnJvci5kZWZhdWx0cyA9IHt9O1xuICAvLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcbiAgICBDb2RlTWlycm9yLmRlZmF1bHRzW25hbWVdID0gZGVmbHQ7XG4gICAgaWYgKGhhbmRsZSkgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxuICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSBoYW5kbGUoY20sIHZhbCwgb2xkKTt9IDogaGFuZGxlO1xuICB9XG5cbiAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cbiAgdmFyIEluaXQgPSBDb2RlTWlycm9yLkluaXQgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5Jbml0XCI7fX07XG5cbiAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxuICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXG4gIG9wdGlvbihcInZhbHVlXCIsIFwiXCIsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBjbS5zZXRWYWx1ZSh2YWwpO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwibW9kZVwiLCBudWxsLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWw7XG4gICAgbG9hZE1vZGUoY20pO1xuICB9LCB0cnVlKTtcblxuICBvcHRpb24oXCJpbmRlbnRVbml0XCIsIDIsIGxvYWRNb2RlLCB0cnVlKTtcbiAgb3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIiwgZmFsc2UpO1xuICBvcHRpb24oXCJzbWFydEluZGVudFwiLCB0cnVlKTtcbiAgb3B0aW9uKFwidGFiU2l6ZVwiLCA0LCBmdW5jdGlvbihjbSkge1xuICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgICBjbGVhckNhY2hlcyhjbSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgfSwgdHJ1ZSk7XG4gIG9wdGlvbihcInNwZWNpYWxDaGFyc1wiLCAvW1xcdFxcdTAwMDAtXFx1MDAxOVxcdTAwYWRcXHUyMDBiLVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZdL2csIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xuICAgIGNtLnN0YXRlLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAodmFsLnNvdXJjZSArICh2YWwudGVzdChcIlxcdFwiKSA/IFwiXCIgOiBcInxcXHRcIiksIFwiZ1wiKTtcbiAgICBpZiAob2xkICE9IENvZGVNaXJyb3IuSW5pdCkgY20ucmVmcmVzaCgpO1xuICB9KTtcbiAgb3B0aW9uKFwic3BlY2lhbENoYXJQbGFjZWhvbGRlclwiLCBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlciwgZnVuY3Rpb24oY20pIHtjbS5yZWZyZXNoKCk7fSwgdHJ1ZSk7XG4gIG9wdGlvbihcImVsZWN0cmljQ2hhcnNcIiwgdHJ1ZSk7XG4gIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKTsgLy8gRklYTUVcbiAgfSwgdHJ1ZSk7XG4gIG9wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCAhd2luZG93cyk7XG4gIG9wdGlvbihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCB0cnVlKTtcblxuICBvcHRpb24oXCJ0aGVtZVwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oY20pIHtcbiAgICB0aGVtZUNoYW5nZWQoY20pO1xuICAgIGd1dHRlcnNDaGFuZ2VkKGNtKTtcbiAgfSwgdHJ1ZSk7XG4gIG9wdGlvbihcImtleU1hcFwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgdmFyIG5leHQgPSBnZXRLZXlNYXAodmFsKTtcbiAgICB2YXIgcHJldiA9IG9sZCAhPSBDb2RlTWlycm9yLkluaXQgJiYgZ2V0S2V5TWFwKG9sZCk7XG4gICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHByZXYuZGV0YWNoKGNtLCBuZXh0KTtcbiAgICBpZiAobmV4dC5hdHRhY2gpIG5leHQuYXR0YWNoKGNtLCBwcmV2IHx8IG51bGwpO1xuICB9KTtcbiAgb3B0aW9uKFwiZXh0cmFLZXlzXCIsIG51bGwpO1xuXG4gIG9wdGlvbihcImxpbmVXcmFwcGluZ1wiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKTtcbiAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24oY20pIHtcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucyk7XG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwiZml4ZWRHdXR0ZXJcIiwgdHJ1ZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcInB4XCIgOiBcIjBcIjtcbiAgICBjbS5yZWZyZXNoKCk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclwiLCBmYWxzZSwgZnVuY3Rpb24oY20pIHt1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LCB0cnVlKTtcbiAgb3B0aW9uKFwic2Nyb2xsYmFyU3R5bGVcIiwgXCJuYXRpdmVcIiwgZnVuY3Rpb24oY20pIHtcbiAgICBpbml0U2Nyb2xsYmFycyhjbSk7XG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSk7XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjbS5kb2Muc2Nyb2xsTGVmdCk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24oY20pIHtcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucyk7XG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwiZmlyc3RMaW5lTnVtYmVyXCIsIDEsIGd1dHRlcnNDaGFuZ2VkLCB0cnVlKTtcbiAgb3B0aW9uKFwibGluZU51bWJlckZvcm1hdHRlclwiLCBmdW5jdGlvbihpbnRlZ2VyKSB7cmV0dXJuIGludGVnZXI7fSwgZ3V0dGVyc0NoYW5nZWQsIHRydWUpO1xuICBvcHRpb24oXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcblxuICBvcHRpb24oXCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnVcIiwgdHJ1ZSk7XG4gIG9wdGlvbihcImxpbmVXaXNlQ29weUN1dFwiLCB0cnVlKTtcblxuICBvcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGlmICh2YWwgPT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBvbkJsdXIoY20pO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY20uZGlzcGxheS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF2YWwpIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICB9XG4gIH0pO1xuICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtpZiAoIXZhbCkgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO30sIHRydWUpO1xuICBvcHRpb24oXCJkcmFnRHJvcFwiLCB0cnVlLCBkcmFnRHJvcENoYW5nZWQpO1xuXG4gIG9wdGlvbihcImN1cnNvckJsaW5rUmF0ZVwiLCA1MzApO1xuICBvcHRpb24oXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwgMCk7XG4gIG9wdGlvbihcImN1cnNvckhlaWdodFwiLCAxLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICBvcHRpb24oXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gIG9wdGlvbihcIndvcmtUaW1lXCIsIDEwMCk7XG4gIG9wdGlvbihcIndvcmtEZWxheVwiLCAxMDApO1xuICBvcHRpb24oXCJmbGF0dGVuU3BhbnNcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICBvcHRpb24oXCJhZGRNb2RlQ2xhc3NcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgb3B0aW9uKFwicG9sbEludGVydmFsXCIsIDEwMCk7XG4gIG9wdGlvbihcInVuZG9EZXB0aFwiLCAyMDAsIGZ1bmN0aW9uKGNtLCB2YWwpe2NtLmRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHZhbDt9KTtcbiAgb3B0aW9uKFwiaGlzdG9yeUV2ZW50RGVsYXlcIiwgMTI1MCk7XG4gIG9wdGlvbihcInZpZXdwb3J0TWFyZ2luXCIsIDEwLCBmdW5jdGlvbihjbSl7Y20ucmVmcmVzaCgpO30sIHRydWUpO1xuICBvcHRpb24oXCJtYXhIaWdobGlnaHRMZW5ndGhcIiwgMTAwMDAsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgb3B0aW9uKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCB0cnVlLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgaWYgKCF2YWwpIGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpO1xuICB9KTtcblxuICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7XG4gIH0pO1xuICBvcHRpb24oXCJhdXRvZm9jdXNcIiwgbnVsbCk7XG5cbiAgLy8gTU9ERSBERUZJTklUSU9OIEFORCBRVUVSWUlOR1xuXG4gIC8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXG4gIHZhciBtb2RlcyA9IENvZGVNaXJyb3IubW9kZXMgPSB7fSwgbWltZU1vZGVzID0gQ29kZU1pcnJvci5taW1lTW9kZXMgPSB7fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICAgIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXCJudWxsXCIpIENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIG1vZGVzW25hbWVdID0gbW9kZTtcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUgPSBmdW5jdGlvbihtaW1lLCBzcGVjKSB7XG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgfTtcblxuICAvLyBHaXZlbiBhIE1JTUUgdHlwZSwgYSB7bmFtZSwgLi4ub3B0aW9uc30gY29uZmlnIG9iamVjdCwgb3IgYSBuYW1lXG4gIC8vIHN0cmluZywgcmV0dXJuIGEgbW9kZSBjb25maWcgb2JqZWN0LlxuICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xuICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcbiAgICB9IGVsc2UgaWYgKHNwZWMgJiYgdHlwZW9mIHNwZWMubmFtZSA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXCJzdHJpbmdcIikgZm91bmQgPSB7bmFtZTogZm91bmR9O1xuICAgICAgc3BlYyA9IGNyZWF0ZU9iaihmb3VuZCwgc3BlYyk7XG4gICAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiAvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLnJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHtuYW1lOiBzcGVjfTtcbiAgICBlbHNlIHJldHVybiBzcGVjIHx8IHtuYW1lOiBcIm51bGxcIn07XG4gIH07XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIHNwZWMgKGFueXRoaW5nIHRoYXQgcmVzb2x2ZU1vZGUgYWNjZXB0cyksIGZpbmQgYW5kXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuICBDb2RlTWlycm9yLmdldE1vZGUgPSBmdW5jdGlvbihvcHRpb25zLCBzcGVjKSB7XG4gICAgdmFyIHNwZWMgPSBDb2RlTWlycm9yLnJlc29sdmVNb2RlKHNwZWMpO1xuICAgIHZhciBtZmFjdG9yeSA9IG1vZGVzW3NwZWMubmFtZV07XG4gICAgaWYgKCFtZmFjdG9yeSkgcmV0dXJuIENvZGVNaXJyb3IuZ2V0TW9kZShvcHRpb25zLCBcInRleHQvcGxhaW5cIik7XG4gICAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSBtb2RlT2JqW1wiX1wiICsgcHJvcF0gPSBtb2RlT2JqW3Byb3BdO1xuICAgICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZU9iai5uYW1lID0gc3BlYy5uYW1lO1xuICAgIGlmIChzcGVjLmhlbHBlclR5cGUpIG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTtcbiAgICBpZiAoc3BlYy5tb2RlUHJvcHMpIGZvciAodmFyIHByb3AgaW4gc3BlYy5tb2RlUHJvcHMpXG4gICAgICBtb2RlT2JqW3Byb3BdID0gc3BlYy5tb2RlUHJvcHNbcHJvcF07XG5cbiAgICByZXR1cm4gbW9kZU9iajtcbiAgfTtcblxuICAvLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibnVsbFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3Rva2VuOiBmdW5jdGlvbihzdHJlYW0pIHtzdHJlYW0uc2tpcFRvRW5kKCk7fX07XG4gIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3BsYWluXCIsIFwibnVsbFwiKTtcblxuICAvLyBUaGlzIGNhbiBiZSB1c2VkIHRvIGF0dGFjaCBwcm9wZXJ0aWVzIHRvIG1vZGUgb2JqZWN0cyBmcm9tXG4gIC8vIG91dHNpZGUgdGhlIGFjdHVhbCBtb2RlIGRlZmluaXRpb24uXG4gIHZhciBtb2RlRXh0ZW5zaW9ucyA9IENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSB7fTtcbiAgQ29kZU1pcnJvci5leHRlbmRNb2RlID0gZnVuY3Rpb24obW9kZSwgcHJvcGVydGllcykge1xuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICB9O1xuXG4gIC8vIEVYVEVOU0lPTlNcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG4gIENvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbiA9IG9wdGlvbjtcblxuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbihmKSB7aW5pdEhvb2tzLnB1c2goZik7fTtcblxuICB2YXIgaGVscGVycyA9IENvZGVNaXJyb3IuaGVscGVycyA9IHt9O1xuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTtcbiAgICBoZWxwZXJzW3R5cGVdW25hbWVdID0gdmFsdWU7XG4gIH07XG4gIENvZGVNaXJyb3IucmVnaXN0ZXJHbG9iYWxIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBwcmVkaWNhdGUsIHZhbHVlKSB7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcih0eXBlLCBuYW1lLCB2YWx1ZSk7XG4gICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xuICB9O1xuXG4gIC8vIE1PREUgU1RBVEUgSEFORExJTkdcblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIHN0YXRlLiBFeHBvcnRlZCBiZWNhdXNlIG5lc3RlZFxuICAvLyBtb2RlcyBuZWVkIHRvIGRvIHRoaXMgZm9yIHRoZWlyIGlubmVyIG1vZGVzLlxuXG4gIHZhciBjb3B5U3RhdGUgPSBDb2RlTWlycm9yLmNvcHlTdGF0ZSA9IGZ1bmN0aW9uKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSByZXR1cm4gc3RhdGU7XG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpO1xuICAgIHZhciBuc3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHZhbCA9IHZhbC5jb25jYXQoW10pO1xuICAgICAgbnN0YXRlW25dID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbnN0YXRlO1xuICB9O1xuXG4gIHZhciBzdGFydFN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlID0gZnVuY3Rpb24obW9kZSwgYTEsIGEyKSB7XG4gICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZTtcbiAgfTtcblxuICAvLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxuICAvLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxuICBDb2RlTWlycm9yLmlubmVyTW9kZSA9IGZ1bmN0aW9uKG1vZGUsIHN0YXRlKSB7XG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICB2YXIgaW5mbyA9IG1vZGUuaW5uZXJNb2RlKHN0YXRlKTtcbiAgICAgIGlmICghaW5mbyB8fCBpbmZvLm1vZGUgPT0gbW9kZSkgYnJlYWs7XG4gICAgICBzdGF0ZSA9IGluZm8uc3RhdGU7XG4gICAgICBtb2RlID0gaW5mby5tb2RlO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfTtcbiAgfTtcblxuICAvLyBTVEFOREFSRCBDT01NQU5EU1xuXG4gIC8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxuICAvLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cbiAgdmFyIGNvbW1hbmRzID0gQ29kZU1pcnJvci5jb21tYW5kcyA9IHtcbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKGNtKSB7Y20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO30sXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcImFuY2hvclwiKSwgY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgc2VsX2RvbnRTY3JvbGwpO1xuICAgIH0sXG4gICAga2lsbExpbmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgIHZhciBsZW4gPSBnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbihjbSkge1xuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLFxuICAgICAgICAgICAgICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApKX07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLCB0bzogcmFuZ2UuZnJvbSgpfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsV3JhcHBlZExpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgICByZXR1cm4ge2Zyb206IGxlZnRQb3MsIHRvOiByYW5nZS5mcm9tKCl9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbihjbSkge1xuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJpZ2h0UG9zIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVuZG86IGZ1bmN0aW9uKGNtKSB7Y20udW5kbygpO30sXG4gICAgcmVkbzogZnVuY3Rpb24oY20pIHtjbS5yZWRvKCk7fSxcbiAgICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge2NtLnVuZG9TZWxlY3Rpb24oKTt9LFxuICAgIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uKGNtKSB7Y20ucmVkb1NlbGVjdGlvbigpO30sXG4gICAgZ29Eb2NTdGFydDogZnVuY3Rpb24oY20pIHtjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7fSxcbiAgICBnb0RvY0VuZDogZnVuY3Rpb24oY20pIHtjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmxhc3RMaW5lKCkpKTt9LFxuICAgIGdvTGluZVN0YXJ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfSk7XG4gICAgfSxcbiAgICBnb0xpbmVTdGFydFNtYXJ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7XG4gICAgICB9LCB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDF9KTtcbiAgICB9LFxuICAgIGdvTGluZUVuZDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IC0xfSk7XG4gICAgfSxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgfSwgc2VsX21vdmUpO1xuICAgIH0sXG4gICAgZ29MaW5lTGVmdDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICB9LFxuICAgIGdvTGluZUxlZnRTbWFydDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9LCBzZWxfbW92ZSk7XG4gICAgfSxcbiAgICBnb0xpbmVVcDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigtMSwgXCJsaW5lXCIpO30sXG4gICAgZ29MaW5lRG93bjogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigxLCBcImxpbmVcIik7fSxcbiAgICBnb1BhZ2VVcDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigtMSwgXCJwYWdlXCIpO30sXG4gICAgZ29QYWdlRG93bjogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigxLCBcInBhZ2VcIik7fSxcbiAgICBnb0NoYXJMZWZ0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKC0xLCBcImNoYXJcIik7fSxcbiAgICBnb0NoYXJSaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcImNoYXJcIik7fSxcbiAgICBnb0NvbHVtbkxlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFwiY29sdW1uXCIpO30sXG4gICAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcImNvbHVtblwiKTt9LFxuICAgIGdvV29yZExlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFwid29yZFwiKTt9LFxuICAgIGdvR3JvdXBSaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcImdyb3VwXCIpO30sXG4gICAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFwiZ3JvdXBcIik7fSxcbiAgICBnb1dvcmRSaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcIndvcmRcIik7fSxcbiAgICBkZWxDaGFyQmVmb3JlOiBmdW5jdGlvbihjbSkge2NtLmRlbGV0ZUgoLTEsIFwiY2hhclwiKTt9LFxuICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKDEsIFwiY2hhclwiKTt9LFxuICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXCJ3b3JkXCIpO30sXG4gICAgZGVsV29yZEFmdGVyOiBmdW5jdGlvbihjbSkge2NtLmRlbGV0ZUgoMSwgXCJ3b3JkXCIpO30sXG4gICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXCJncm91cFwiKTt9LFxuICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgxLCBcImdyb3VwXCIpO30sXG4gICAgaW5kZW50QXV0bzogZnVuY3Rpb24oY20pIHtjbS5pbmRlbnRTZWxlY3Rpb24oXCJzbWFydFwiKTt9LFxuICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uKGNtKSB7Y20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpO30sXG4gICAgaW5kZW50TGVzczogZnVuY3Rpb24oY20pIHtjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTt9LFxuICAgIGluc2VydFRhYjogZnVuY3Rpb24oY20pIHtjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpO30sXG4gICAgaW5zZXJ0U29mdFRhYjogZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uZnJvbSgpO1xuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHNwYWNlcy5wdXNoKG5ldyBBcnJheSh0YWJTaXplIC0gY29sICUgdGFiU2l6ZSArIDEpLmpvaW4oXCIgXCIpKTtcbiAgICAgIH1cbiAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcyk7XG4gICAgfSxcbiAgICBkZWZhdWx0VGFiOiBmdW5jdGlvbihjbSkge1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIGNtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTtcbiAgICAgIGVsc2UgY20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7XG4gICAgfSxcbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24oY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3U2VsID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0O1xuICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKTtcbiAgICAgICAgICAgIGlmIChjdXIuY2ggPiAwKSB7XG4gICAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMiksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xuICAgICAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XG4gICAgICAgICAgICAgIGlmIChwcmV2KVxuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIFwiXFxuXCIgKyBwcmV2LmNoYXJBdChwcmV2Lmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUgLSAxLCBwcmV2Lmxlbmd0aCAtIDEpLCBQb3MoY3VyLmxpbmUsIDEpLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2VsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24oY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gY20ubGlzdFNlbGVjdGlvbnMoKS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBjbS5saXN0U2VsZWN0aW9ucygpW2ldO1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlxcblwiLCByYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQsIFwiK2lucHV0XCIpO1xuICAgICAgICAgIGNtLmluZGVudExpbmUocmFuZ2UuZnJvbSgpLmxpbmUgKyAxLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKGNtKSB7Y20udG9nZ2xlT3ZlcndyaXRlKCk7fVxuICB9O1xuXG5cbiAgLy8gU1RBTkRBUkQgS0VZTUFQU1xuXG4gIHZhciBrZXlNYXAgPSBDb2RlTWlycm9yLmtleU1hcCA9IHt9O1xuXG4gIGtleU1hcC5iYXNpYyA9IHtcbiAgICBcIkxlZnRcIjogXCJnb0NoYXJMZWZ0XCIsIFwiUmlnaHRcIjogXCJnb0NoYXJSaWdodFwiLCBcIlVwXCI6IFwiZ29MaW5lVXBcIiwgXCJEb3duXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiRW5kXCI6IFwiZ29MaW5lRW5kXCIsIFwiSG9tZVwiOiBcImdvTGluZVN0YXJ0U21hcnRcIiwgXCJQYWdlVXBcIjogXCJnb1BhZ2VVcFwiLCBcIlBhZ2VEb3duXCI6IFwiZ29QYWdlRG93blwiLFxuICAgIFwiRGVsZXRlXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLCBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIixcbiAgICBcIlRhYlwiOiBcImRlZmF1bHRUYWJcIiwgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRBdXRvXCIsXG4gICAgXCJFbnRlclwiOiBcIm5ld2xpbmVBbmRJbmRlbnRcIiwgXCJJbnNlcnRcIjogXCJ0b2dnbGVPdmVyd3JpdGVcIixcbiAgICBcIkVzY1wiOiBcInNpbmdsZVNlbGVjdGlvblwiXG4gIH07XG4gIC8vIE5vdGUgdGhhdCB0aGUgc2F2ZSBhbmQgZmluZC1yZWxhdGVkIGNvbW1hbmRzIGFyZW4ndCBkZWZpbmVkIGJ5XG4gIC8vIGRlZmF1bHQuIFVzZXIgY29kZSBvciBhZGRvbnMgY2FuIGRlZmluZSB0aGVtLiBVbmtub3duIGNvbW1hbmRzXG4gIC8vIGFyZSBzaW1wbHkgaWdub3JlZC5cbiAga2V5TWFwLnBjRGVmYXVsdCA9IHtcbiAgICBcIkN0cmwtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkN0cmwtRFwiOiBcImRlbGV0ZUxpbmVcIiwgXCJDdHJsLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ3RybC1aXCI6IFwicmVkb1wiLCBcIkN0cmwtWVwiOiBcInJlZG9cIixcbiAgICBcIkN0cmwtSG9tZVwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLUVuZFwiOiBcImdvRG9jRW5kXCIsIFwiQ3RybC1VcFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1Eb3duXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQ3RybC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIiwgXCJDdHJsLVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsIFwiQWx0LUxlZnRcIjogXCJnb0xpbmVTdGFydFwiLCBcIkFsdC1SaWdodFwiOiBcImdvTGluZUVuZFwiLFxuICAgIFwiQ3RybC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLCBcIkN0cmwtRGVsZXRlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkN0cmwtU1wiOiBcInNhdmVcIiwgXCJDdHJsLUZcIjogXCJmaW5kXCIsXG4gICAgXCJDdHJsLUdcIjogXCJmaW5kTmV4dFwiLCBcIlNoaWZ0LUN0cmwtR1wiOiBcImZpbmRQcmV2XCIsIFwiU2hpZnQtQ3RybC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUN0cmwtUlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkN0cmwtW1wiOiBcImluZGVudExlc3NcIiwgXCJDdHJsLV1cIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgXCJDdHJsLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ3RybC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkFsdC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLFxuICAgIGZhbGx0aHJvdWdoOiBcImJhc2ljXCJcbiAgfTtcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbiAga2V5TWFwLmVtYWNzeSA9IHtcbiAgICBcIkN0cmwtRlwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiQ3RybC1CXCI6IFwiZ29DaGFyTGVmdFwiLCBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1OXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQWx0LUZcIjogXCJnb1dvcmRSaWdodFwiLCBcIkFsdC1CXCI6IFwiZ29Xb3JkTGVmdFwiLCBcIkN0cmwtQVwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQ3RybC1FXCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIiwgXCJDdHJsLURcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJDdHJsLUhcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgXCJBbHQtRFwiOiBcImRlbFdvcmRBZnRlclwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxXb3JkQmVmb3JlXCIsIFwiQ3RybC1LXCI6IFwia2lsbExpbmVcIiwgXCJDdHJsLVRcIjogXCJ0cmFuc3Bvc2VDaGFyc1wiXG4gIH07XG4gIGtleU1hcC5tYWNEZWZhdWx0ID0ge1xuICAgIFwiQ21kLUFcIjogXCJzZWxlY3RBbGxcIiwgXCJDbWQtRFwiOiBcImRlbGV0ZUxpbmVcIiwgXCJDbWQtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DbWQtWlwiOiBcInJlZG9cIiwgXCJDbWQtWVwiOiBcInJlZG9cIixcbiAgICBcIkNtZC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDbWQtRG93blwiOiBcImdvRG9jRW5kXCIsIFwiQWx0LUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLFxuICAgIFwiQWx0LVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsIFwiQ21kLUxlZnRcIjogXCJnb0xpbmVMZWZ0XCIsIFwiQ21kLVJpZ2h0XCI6IFwiZ29MaW5lUmlnaHRcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIixcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJBbHQtRGVsZXRlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkNtZC1TXCI6IFwic2F2ZVwiLCBcIkNtZC1GXCI6IFwiZmluZFwiLFxuICAgIFwiQ21kLUdcIjogXCJmaW5kTmV4dFwiLCBcIlNoaWZ0LUNtZC1HXCI6IFwiZmluZFByZXZcIiwgXCJDbWQtQWx0LUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ21kLUFsdC1GXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ21kLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ21kLV1cIjogXCJpbmRlbnRNb3JlXCIsIFwiQ21kLUJhY2tzcGFjZVwiOiBcImRlbFdyYXBwZWRMaW5lTGVmdFwiLCBcIkNtZC1EZWxldGVcIjogXCJkZWxXcmFwcGVkTGluZVJpZ2h0XCIsXG4gICAgXCJDbWQtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DbWQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIiwgXCJDdHJsLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRG93blwiOiBcImdvRG9jRW5kXCIsXG4gICAgZmFsbHRocm91Z2g6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gIH07XG4gIGtleU1hcFtcImRlZmF1bHRcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHQ7XG5cbiAgLy8gS0VZTUFQIERJU1BBVENIXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyksIG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgYWx0LCBjdHJsLCBzaGlmdCwgY21kO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgbW9kID0gcGFydHNbaV07XG4gICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSBjbWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSBhbHQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgY3RybCA9IHRydWU7XG4gICAgICBlbHNlIGlmICgvXnMoaGlmdCkkL2kudGVzdChtb2QpKSBzaGlmdCA9IHRydWU7XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGN0cmwpIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChjbWQpIG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0KSBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xuICAvLyAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgc3VwcG9ydCBmZWF0dXJlc1xuICAvLyBsaWtlIG5vcm1hbGl6YXRpb24gYW5kIG11bHRpLXN0cm9rZSBrZXkgYmluZGluZ3MuIEl0IGNvbXBpbGVzIGFcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcbiAgLy8gdGhpcy5cbiAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAgPSBmdW5jdGlvbihrZXltYXApIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSBpZiAoa2V5bWFwLmhhc093blByb3BlcnR5KGtleW5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBrZXltYXBba2V5bmFtZV07XG4gICAgICBpZiAoL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGtleW5hbWUpKSBjb250aW51ZTtcbiAgICAgIGlmICh2YWx1ZSA9PSBcIi4uLlwiKSB7IGRlbGV0ZSBrZXltYXBba2V5bmFtZV07IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsLCBuYW1lO1xuICAgICAgICBpZiAoaSA9PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBuYW1lID0ga2V5cy5qb2luKFwiIFwiKTtcbiAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0ga2V5cy5zbGljZSgwLCBpICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFsID0gXCIuLi5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldiA9IGNvcHlbbmFtZV07XG4gICAgICAgIGlmICghcHJldikgY29weVtuYW1lXSA9IHZhbDtcbiAgICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBrZXltYXBba2V5bmFtZV07XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gY29weSkga2V5bWFwW3Byb3BdID0gY29weVtwcm9wXTtcbiAgICByZXR1cm4ga2V5bWFwO1xuICB9O1xuXG4gIHZhciBsb29rdXBLZXkgPSBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGZ1bmN0aW9uKGtleSwgbWFwLCBoYW5kbGUsIGNvbnRleHQpIHtcbiAgICBtYXAgPSBnZXRLZXlNYXAobWFwKTtcbiAgICB2YXIgZm91bmQgPSBtYXAuY2FsbCA/IG1hcC5jYWxsKGtleSwgY29udGV4dCkgOiBtYXBba2V5XTtcbiAgICBpZiAoZm91bmQgPT09IGZhbHNlKSByZXR1cm4gXCJub3RoaW5nXCI7XG4gICAgaWYgKGZvdW5kID09PSBcIi4uLlwiKSByZXR1cm4gXCJtdWx0aVwiO1xuICAgIGlmIChmb3VuZCAhPSBudWxsICYmIGhhbmRsZShmb3VuZCkpIHJldHVybiBcImhhbmRsZWRcIjtcblxuICAgIGlmIChtYXAuZmFsbHRocm91Z2gpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWFwLmZhbGx0aHJvdWdoKSAhPSBcIltvYmplY3QgQXJyYXldXCIpXG4gICAgICAgIHJldHVybiBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2gsIGhhbmRsZSwgY29udGV4dCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5mYWxsdGhyb3VnaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoW2ldLCBoYW5kbGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxuICAvLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cbiAgdmFyIGlzTW9kaWZpZXJLZXkgPSBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IGtleU5hbWVzW3ZhbHVlLmtleUNvZGVdO1xuICAgIHJldHVybiBuYW1lID09IFwiQ3RybFwiIHx8IG5hbWUgPT0gXCJBbHRcIiB8fCBuYW1lID09IFwiU2hpZnRcIiB8fCBuYW1lID09IFwiTW9kXCI7XG4gIH07XG5cbiAgLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxuICB2YXIga2V5TmFtZSA9IENvZGVNaXJyb3Iua2V5TmFtZSA9IGZ1bmN0aW9uKGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgaWYgKHByZXN0byAmJiBldmVudC5rZXlDb2RlID09IDM0ICYmIGV2ZW50W1wiY2hhclwiXSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBiYXNlID0ga2V5TmFtZXNbZXZlbnQua2V5Q29kZV0sIG5hbWUgPSBiYXNlO1xuICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGJhc2UgIT0gXCJBbHRcIikgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXCJDdHJsXCIpIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcIkNtZFwiKSBuYW1lID0gXCJDbWQtXCIgKyBuYW1lO1xuICAgIGlmICghbm9TaGlmdCAmJiBldmVudC5zaGlmdEtleSAmJiBiYXNlICE9IFwiU2hpZnRcIikgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8ga2V5TWFwW3ZhbF0gOiB2YWw7XG4gIH1cblxuICAvLyBGUk9NVEVYVEFSRUFcblxuICBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSA9IGZ1bmN0aW9uKHRleHRhcmVhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XG4gICAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xuICAgIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleClcbiAgICAgIG9wdGlvbnMudGFiaW5kZXggPSB0ZXh0YXJlYS50YWJJbmRleDtcbiAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXIgJiYgdGV4dGFyZWEucGxhY2Vob2xkZXIpXG4gICAgICBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXI7XG4gICAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXG4gICAgLy8gYXV0b2ZvY3VzIGFuZCBubyBvdGhlciBlbGVtZW50IGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09IG51bGwpIHtcbiAgICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgb3B0aW9ucy5hdXRvZm9jdXMgPSBoYXNGb2N1cyA9PSB0ZXh0YXJlYSB8fFxuICAgICAgICB0ZXh0YXJlYS5nZXRBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgIT0gbnVsbCAmJiBoYXNGb2N1cyA9PSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmUoKSB7dGV4dGFyZWEudmFsdWUgPSBjbS5nZXRWYWx1ZSgpO31cbiAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xuICAgICAgb24odGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAvLyBEZXBsb3JhYmxlIGhhY2sgdG8gbWFrZSB0aGUgc3VibWl0IG1ldGhvZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xuICAgICAgICB2YXIgZm9ybSA9IHRleHRhcmVhLmZvcm0sIHJlYWxTdWJtaXQgPSBmb3JtLnN1Ym1pdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgd3JhcHBlZFN1Ym1pdCA9IGZvcm0uc3VibWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSB3cmFwcGVkU3VibWl0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmZpbmlzaEluaXQgPSBmdW5jdGlvbihjbSkge1xuICAgICAgY20uc2F2ZSA9IHNhdmU7XG4gICAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dGFyZWE7IH07XG4gICAgICBjbS50b1RleHRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTjsgLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXG4gICAgICAgIHNhdmUoKTtcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKTtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgICAgb2ZmKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdmFyIGNtID0gQ29kZU1pcnJvcihmdW5jdGlvbihub2RlKSB7XG4gICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNtO1xuICB9O1xuXG4gIC8vIFNUUklORyBTVFJFQU1cblxuICAvLyBGZWQgdG8gdGhlIG1vZGUgcGFyc2VycywgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byBtYWtlXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cblxuICB2YXIgU3RyaW5nU3RyZWFtID0gQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBmdW5jdGlvbihzdHJpbmcsIHRhYlNpemUpIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgODtcbiAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICB9O1xuXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUgPSB7XG4gICAgZW9sOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoO30sXG4gICAgc29sOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnQ7fSxcbiAgICBwZWVrOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7fSxcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9LFxuICAgIGVhdDogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpIHZhciBvayA9IGNoID09IG1hdGNoO1xuICAgICAgZWxzZSB2YXIgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaDt9XG4gICAgfSxcbiAgICBlYXRXaGlsZTogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSl7fVxuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfSxcbiAgICBlYXRTcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfSxcbiAgICBza2lwVG9FbmQ6IGZ1bmN0aW9uKCkge3RoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoO30sXG4gICAgc2tpcFRvOiBmdW5jdGlvbihjaCkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgaWYgKGZvdW5kID4gLTEpIHt0aGlzLnBvcyA9IGZvdW5kOyByZXR1cm4gdHJ1ZTt9XG4gICAgfSxcbiAgICBiYWNrVXA6IGZ1bmN0aW9uKG4pIHt0aGlzLnBvcyAtPSBuO30sXG4gICAgY29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKTtcbiAgICB9LFxuICAgIGluZGVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtXG4gICAgICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApO1xuICAgIH0sXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGNhc2VkID0gZnVuY3Rpb24oc3RyKSB7cmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO307XG4gICAgICAgIHZhciBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3VycmVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpO30sXG4gICAgaGlkZUZpcnN0Q2hhcnM6IGZ1bmN0aW9uKG4sIGlubmVyKSB7XG4gICAgICB0aGlzLmxpbmVTdGFydCArPSBuO1xuICAgICAgdHJ5IHsgcmV0dXJuIGlubmVyKCk7IH1cbiAgICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRFWFRNQVJLRVJTXG5cbiAgLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxuICAvLyBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhciBvciBmaW5kIGEgbWFya2VkIHBvc2l0aW9uIGluIHRoZVxuICAvLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xuICAvLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxuICAvLyBpbmRpY2F0aW5nIHRoYXQgc3VjaCBhIG1hcmtlciBpcyBwcmVzZW50IG9uIHRoYXQgbGluZS4gTXVsdGlwbGVcbiAgLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cbiAgLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcbiAgLy8gbWFya2VyIGNvbnRpbnVlcyBiZXlvbmQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgbGluZS4gTWFya2VycyBoYXZlXG4gIC8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxuXG4gIHZhciBuZXh0TWFya2VySWQgPSAwO1xuXG4gIHZhciBUZXh0TWFya2VyID0gQ29kZU1pcnJvci5UZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICB9O1xuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xuXG4gIC8vIENsZWFyIHRoZSBtYXJrZXIuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHJldHVybjtcbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICBpZiAoaGFzSGFuZGxlcih0aGlzLCBcImNsZWFyXCIpKSB7XG4gICAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoKTtcbiAgICAgIGlmIChmb3VuZCkgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiLCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgfVxuICAgIHZhciBtaW4gPSBudWxsLCBtYXggPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKGNtICYmICF0aGlzLmNvbGxhcHNlZCkgcmVnTGluZUNoYW5nZShjbSwgbGluZU5vKGxpbmUpLCBcInRleHRcIik7XG4gICAgICBlbHNlIGlmIChjbSkge1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSBtYXggPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkgbWluID0gbGluZU5vKGxpbmUpO1xuICAgICAgfVxuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3Bhbik7XG4gICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pXG4gICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgdGV4dEhlaWdodChjbS5kaXNwbGF5KSk7XG4gICAgfVxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcy5saW5lc1tpXSksIGxlbiA9IGxpbmVMZW5ndGgodmlzdWFsKTtcbiAgICAgIGlmIChsZW4gPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gdmlzdWFsO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpO1xuICAgIHRoaXMubGluZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5hdG9taWMgJiYgdGhpcy5kb2MuY2FudEVkaXQpIHtcbiAgICAgIHRoaXMuZG9jLmNhbnRFZGl0ID0gZmFsc2U7XG4gICAgICBpZiAoY20pIHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTtcbiAgICB9XG4gICAgaWYgKGNtKSBzaWduYWxMYXRlcihjbSwgXCJtYXJrZXJDbGVhcmVkXCIsIGNtLCB0aGlzKTtcbiAgICBpZiAod2l0aE9wKSBlbmRPcGVyYXRpb24oY20pO1xuICAgIGlmICh0aGlzLnBhcmVudCkgdGhpcy5wYXJlbnQuY2xlYXIoKTtcbiAgfTtcblxuICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxuICAvLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxuICAvLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxuICAvLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xuICAgIGlmIChzaWRlID09IG51bGwgJiYgdGhpcy50eXBlID09IFwiYm9va21hcmtcIikgc2lkZSA9IDE7XG4gICAgdmFyIGZyb20sIHRvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4uZnJvbSk7XG4gICAgICAgIGlmIChzaWRlID09IC0xKSByZXR1cm4gZnJvbTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pO1xuICAgICAgICBpZiAoc2lkZSA9PSAxKSByZXR1cm4gdG87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99O1xuICB9O1xuXG4gIC8vIFNpZ25hbHMgdGhhdCB0aGUgbWFya2VyJ3Mgd2lkZ2V0IGNoYW5nZWQsIGFuZCBzdXJyb3VuZGluZyBsYXlvdXRcbiAgLy8gc2hvdWxkIGJlIHJlY29tcHV0ZWQuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcbiAgICBpZiAoIXBvcyB8fCAhY20pIHJldHVybjtcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lID0gcG9zLmxpbmUsIGxpbmVOID0gbGluZU5vKHBvcy5saW5lKTtcbiAgICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgICBpZiAodmlldykge1xuICAgICAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKHZpZXcpO1xuICAgICAgICBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7XG4gICAgICBpZiAoIWxpbmVJc0hpZGRlbih3aWRnZXQuZG9jLCBsaW5lKSAmJiB3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHdpZGdldC5oZWlnaHQ7XG4gICAgICAgIHdpZGdldC5oZWlnaHQgPSBudWxsO1xuICAgICAgICB2YXIgZEhlaWdodCA9IHdpZGdldEhlaWdodCh3aWRnZXQpIC0gb2xkSGVpZ2h0O1xuICAgICAgICBpZiAoZEhlaWdodClcbiAgICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XG4gICAgICB2YXIgb3AgPSB0aGlzLmRvYy5jbS5jdXJPcDtcbiAgICAgIGlmICghb3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IGluZGV4T2Yob3AubWF5YmVIaWRkZW5NYXJrZXJzLCB0aGlzKSA9PSAtMSlcbiAgICAgICAgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuICB9O1xuICBUZXh0TWFya2VyLnByb3RvdHlwZS5kZXRhY2hMaW5lID0gZnVuY3Rpb24obGluZSkge1xuICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpO1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xuICAgICAgKG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDb2xsYXBzZWQgbWFya2VycyBoYXZlIHVuaXF1ZSBpZHMsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gb3JkZXJcbiAgLy8gdGhlbSwgd2hpY2ggaXMgbmVlZGVkIGZvciB1bmlxdWVseSBkZXRlcm1pbmluZyBhbiBvdXRlciBtYXJrZXJcbiAgLy8gd2hlbiB0aGV5IG92ZXJsYXAgKHRoZXkgbWF5IG5lc3QsIGJ1dCBub3QgcGFydGlhbGx5IG92ZXJsYXApLlxuICB2YXIgbmV4dE1hcmtlcklkID0gMDtcblxuICAvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcbiAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgIC8vIFNoYXJlZCBtYXJrZXJzIChhY3Jvc3MgbGlua2VkIGRvY3VtZW50cykgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXG4gICAgLy8gZG9jdW1lbnQpLlxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkKSByZXR1cm4gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSk7XG4gICAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFya1RleHQpKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpO1xuXG4gICAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChvcHRpb25zKSBjb3B5T2JqKG9wdGlvbnMsIG1hcmtlciwgZmFsc2UpO1xuICAgIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICByZXR1cm4gbWFya2VyO1xuICAgIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHQoXCJzcGFuXCIsIFttYXJrZXIucmVwbGFjZWRXaXRoXSwgXCJDb2RlTWlycm9yLXdpZGdldFwiKTtcbiAgICAgIGlmICghb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50cykgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSBtYXJrZXIud2lkZ2V0Tm9kZS5pbnNlcnRMZWZ0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKTtcbiAgICAgIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWFya2VyLmFkZFRvSGlzdG9yeSlcbiAgICAgIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTtcblxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcbiAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB1cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgIGlmIChtYXJrZXIuY29sbGFwc2VkICYmIGN1ckxpbmUgIT0gZnJvbS5saW5lKSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApO1xuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCkpO1xuICAgICAgKytjdXJMaW5lO1xuICAgIH0pO1xuICAgIC8vIGxpbmVJc0hpZGRlbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUgc3BhbnMsIHNvIG5lZWRzIGEgc2Vjb25kIHBhc3NcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApO1xuICAgIH0pO1xuXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIG9uKG1hcmtlciwgXCJiZWZvcmVDdXJzb3JFbnRlclwiLCBmdW5jdGlvbigpIHsgbWFya2VyLmNsZWFyKCk7IH0pO1xuXG4gICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgZG9jLmNsZWFySGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xuICAgICAgbWFya2VyLmlkID0gKytuZXh0TWFya2VySWQ7XG4gICAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNtKSB7XG4gICAgICAvLyBTeW5jIGVkaXRvciBzdGF0ZVxuICAgICAgaWYgKHVwZGF0ZU1heExpbmUpIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXG4gICAgICAgIHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSk7XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci50aXRsZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcylcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHJlZ0xpbmVDaGFuZ2UoY20sIGksIFwidGV4dFwiKTtcbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJtYXJrZXJBZGRlZFwiLCBjbSwgbWFya2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcjtcbiAgfVxuXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xuXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbiAgLy8gbWFya2Vycy5cbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpcztcbiAgfTtcbiAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcblxuICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSByZXR1cm47XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB0aGlzLm1hcmtlcnNbaV0uY2xlYXIoKTtcbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xuICB9O1xuICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZTtcbiAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xuICAgIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uKGRvYykge1xuICAgICAgaWYgKHdpZGdldCkgb3B0aW9ucy53aWRnZXROb2RlID0gd2lkZ2V0LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIG1hcmtlcnMucHVzaChtYXJrVGV4dChkb2MsIGNsaXBQb3MoZG9jLCBmcm9tKSwgY2xpcFBvcyhkb2MsIHRvKSwgb3B0aW9ucywgdHlwZSkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgcmV0dXJuO1xuICAgICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kU2hhcmVkTWFya2Vycyhkb2MpIHtcbiAgICByZXR1cm4gZG9jLmZpbmRNYXJrcyhQb3MoZG9jLmZpcnN0LCAwKSwgZG9jLmNsaXBQb3MoUG9zKGRvYy5sYXN0TGluZSgpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24obSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVNoYXJlZE1hcmtlcnMoZG9jLCBtYXJrZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcbiAgICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKTtcbiAgICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcbiAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcbiAgICAgICAgbWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKTtcbiAgICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgbGlua2VkID0gW21hcmtlci5wcmltYXJ5LmRvY107O1xuICAgICAgbGlua2VkRG9jcyhtYXJrZXIucHJpbWFyeS5kb2MsIGZ1bmN0aW9uKGQpIHsgbGlua2VkLnB1c2goZCk7IH0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgIGlmIChpbmRleE9mKGxpbmtlZCwgc3ViTWFya2VyLmRvYykgPT0gLTEpIHtcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRFWFRNQVJLRVIgU1BBTlNcblxuICBmdW5jdGlvbiBNYXJrZWRTcGFuKG1hcmtlciwgZnJvbSwgdG8pIHtcbiAgICB0aGlzLm1hcmtlciA9IG1hcmtlcjtcbiAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gIH1cblxuICAvLyBTZWFyY2ggYW4gYXJyYXkgb2Ygc3BhbnMgZm9yIGEgc3BhbiBtYXRjaGluZyB0aGUgZ2l2ZW4gbWFya2VyLlxuICBmdW5jdGlvbiBnZXRNYXJrZWRTcGFuRm9yKHNwYW5zLCBtYXJrZXIpIHtcbiAgICBpZiAoc3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSByZXR1cm4gc3BhbjtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlIGEgc3BhbiBmcm9tIGFuIGFycmF5LCByZXR1cm5pbmcgdW5kZWZpbmVkIGlmIG5vIHNwYW5zIGFyZVxuICAvLyBsZWZ0ICh3ZSBkb24ndCBzdG9yZSBhcnJheXMgZm9yIGxpbmVzIHdpdGhvdXQgc3BhbnMpLlxuICBmdW5jdGlvbiByZW1vdmVNYXJrZWRTcGFuKHNwYW5zLCBzcGFuKSB7XG4gICAgZm9yICh2YXIgciwgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIGlmIChzcGFuc1tpXSAhPSBzcGFuKSAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgLy8gQWRkIGEgc3BhbiB0byBhIGxpbmUuXG4gIGZ1bmN0aW9uIGFkZE1hcmtlZFNwYW4obGluZSwgc3Bhbikge1xuICAgIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXTtcbiAgICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdGhlIGFsZ29yaXRobSB0aGF0IGFkanVzdHMgbWFya2VycyBmb3IgYSBjaGFuZ2UgaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cbiAgLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcbiAgLy8gdW5kZWZpbmVkIGlmIG5vdGhpbmcgcmVtYWlucykuXG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcbiAgICBpZiAob2xkKSBmb3IgKHZhciBpID0gMCwgbnc7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gc3RhcnRDaCA6IHNwYW4uZnJvbSA8IHN0YXJ0Q2gpO1xuICAgICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgKCFpc0luc2VydCB8fCAhc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpO1xuICAgICAgICAobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3Bhbi5mcm9tLCBlbmRzQWZ0ZXIgPyBudWxsIDogc3Bhbi50bykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnc7XG4gIH1cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xuICAgIGlmIChvbGQpIGZvciAodmFyIGkgPSAwLCBudzsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBlbmRDaCA6IHNwYW4udG8gPiBlbmRDaCk7XG4gICAgICBpZiAoZW5kc0FmdGVyIHx8IHNwYW4uZnJvbSA9PSBlbmRDaCAmJiBtYXJrZXIudHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgKCFpc0luc2VydCB8fCBzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpO1xuICAgICAgICAobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3RhcnRzQmVmb3JlID8gbnVsbCA6IHNwYW4uZnJvbSAtIGVuZENoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4udG8gPT0gbnVsbCA/IG51bGwgOiBzcGFuLnRvIC0gZW5kQ2gpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG53O1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XG4gIC8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xuICAvLyBlbnRpcmVseSB3aXRoaW4gdGhlIGNoYW5nZSwgcmVjb25uZWN0cyBzcGFucyBiZWxvbmdpbmcgdG8gdGhlXG4gIC8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXG4gIC8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXG4gIC8vIGFycmF5cyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGxpbmUgaW4gKGFmdGVyKSB0aGUgY2hhbmdlLlxuICBmdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5mdWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgb2xkRmlyc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkubWFya2VkU3BhbnM7XG4gICAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFucztcbiAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwO1xuICAgIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXG4gICAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KTtcbiAgICB2YXIgbGFzdCA9IG1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCwgZW5kQ2gsIGlzSW5zZXJ0KTtcblxuICAgIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXG4gICAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRml4IHVwIC50byBwcm9wZXJ0aWVzIG9mIGZpcnN0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gZmlyc3RbaV07XG4gICAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSBzcGFuLnRvID0gc3RhcnRDaDtcbiAgICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIC8vIEZpeCB1cCAuZnJvbSBpbiBsYXN0IChvciBtb3ZlIHRoZW0gaW50byBmaXJzdCBpbiBjYXNlIG9mIHNhbWVMaW5lKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gbGFzdFtpXTtcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgc3Bhbi50byArPSBvZmZzZXQ7XG4gICAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4ubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBzcGFuLmZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2FtZUxpbmUpIChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4uZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKHNhbWVMaW5lKSAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgY3JlYXRlIGFueSB6ZXJvLWxlbmd0aCBzcGFuc1xuICAgIGlmIChmaXJzdCkgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpO1xuICAgIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIGxhc3QgPSBjbGVhckVtcHR5U3BhbnMobGFzdCk7XG5cbiAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XG4gICAgaWYgKCFzYW1lTGluZSkge1xuICAgICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXG4gICAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcbiAgICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChmaXJzdFtpXS50byA9PSBudWxsKVxuICAgICAgICAgICAgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaV0ubWFya2VyLCBudWxsLCBudWxsKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhcDsgKytpKVxuICAgICAgICBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7XG4gICAgICBuZXdNYXJrZXJzLnB1c2gobGFzdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXJrZXJzO1xuICB9XG5cbiAgLy8gUmVtb3ZlIHNwYW5zIHRoYXQgYXJlIGVtcHR5IGFuZCBkb24ndCBoYXZlIGEgY2xlYXJXaGVuRW1wdHlcbiAgLy8gb3B0aW9uIG9mIGZhbHNlLlxuICBmdW5jdGlvbiBjbGVhckVtcHR5U3BhbnMoc3BhbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsICYmIHNwYW4uZnJvbSA9PSBzcGFuLnRvICYmIHNwYW4ubWFya2VyLmNsZWFyV2hlbkVtcHR5ICE9PSBmYWxzZSlcbiAgICAgICAgc3BhbnMuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuICAgIGlmICghc3BhbnMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc3BhbnM7XG4gIH1cblxuICAvLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxuICAvLyByZXN1bHQgb2YgY29tcHV0aW5nIHRoZSBleGlzdGluZyBzcGFucyB3aXRoIHRoZSBzZXQgb2Ygc3BhbnMgdGhhdFxuICAvLyBleGlzdGVkIGluIHRoZSBoaXN0b3J5IChzbyB0aGF0IGRlbGV0aW5nIGFyb3VuZCBhIHNwYW4gYW5kIHRoZW5cbiAgLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXG4gIGZ1bmN0aW9uIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb2xkID0gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpO1xuICAgIHZhciBzdHJldGNoZWQgPSBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBpZiAoIW9sZCkgcmV0dXJuIHN0cmV0Y2hlZDtcbiAgICBpZiAoIXN0cmV0Y2hlZCkgcmV0dXJuIG9sZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgb2xkQ3VyID0gb2xkW2ldLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2ldO1xuICAgICAgaWYgKG9sZEN1ciAmJiBzdHJldGNoQ3VyKSB7XG4gICAgICAgIHNwYW5zOiBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal07XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDdXIubGVuZ3RoOyArK2spXG4gICAgICAgICAgICBpZiAob2xkQ3VyW2tdLm1hcmtlciA9PSBzcGFuLm1hcmtlcikgY29udGludWUgc3BhbnM7XG4gICAgICAgICAgb2xkQ3VyLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xuICAgICAgICBvbGRbaV0gPSBzdHJldGNoQ3VyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkO1xuICB9XG5cbiAgLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cbiAgZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xuICAgIHZhciBtYXJrZXJzID0gbnVsbDtcbiAgICBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXI7XG4gICAgICAgIGlmIChtYXJrLnJlYWRPbmx5ICYmICghbWFya2VycyB8fCBpbmRleE9mKG1hcmtlcnMsIG1hcmspID09IC0xKSlcbiAgICAgICAgICAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlcnMpIHJldHVybiBudWxsO1xuICAgIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHAgPSBwYXJ0c1tqXTtcbiAgICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pO1xuICAgICAgICBpZiAoZGZyb20gPCAwIHx8ICFtay5pbmNsdXNpdmVMZWZ0ICYmICFkZnJvbSlcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KTtcbiAgICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pXG4gICAgICAgICAgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KTtcbiAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XG4gICAgICAgIGogKz0gbmV3UGFydHMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgLy8gQ29ubmVjdCBvciBkaXNjb25uZWN0IHNwYW5zIGZyb20gYSBsaW5lLlxuICBmdW5jdGlvbiBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoIXNwYW5zKSByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpO1xuICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICBzcGFuc1tpXS5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTtcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XG4gIH1cblxuICAvLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cbiAgLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxuICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IC0xIDogMDsgfVxuICBmdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDA7IH1cblxuICAvLyBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hpY2ggb2YgdHdvIG92ZXJsYXBwaW5nIGNvbGxhcHNlZFxuICAvLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cbiAgLy8gY29tcGFyaW5nIGlkcyB3aGVuIHRoZSBzcGFucyBjb3ZlciBleGFjdGx5IHRoZSBzYW1lIHJhbmdlLlxuICBmdW5jdGlvbiBjb21wYXJlQ29sbGFwc2VkTWFya2VycyhhLCBiKSB7XG4gICAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoO1xuICAgIGlmIChsZW5EaWZmICE9IDApIHJldHVybiBsZW5EaWZmO1xuICAgIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKTtcbiAgICB2YXIgZnJvbUNtcCA9IGNtcChhUG9zLmZyb20sIGJQb3MuZnJvbSkgfHwgZXh0cmFMZWZ0KGEpIC0gZXh0cmFMZWZ0KGIpO1xuICAgIGlmIChmcm9tQ21wKSByZXR1cm4gLWZyb21DbXA7XG4gICAgdmFyIHRvQ21wID0gY21wKGFQb3MudG8sIGJQb3MudG8pIHx8IGV4dHJhUmlnaHQoYSkgLSBleHRyYVJpZ2h0KGIpO1xuICAgIGlmICh0b0NtcCkgcmV0dXJuIHRvQ21wO1xuICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbiAgfVxuXG4gIC8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXG4gIC8vIHNvLCByZXR1cm4gdGhlIG1hcmtlciBmb3IgdGhhdCBzcGFuLlxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgIGlmIChzcHMpIGZvciAodmFyIHNwLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3RhcnQgPyBzcC5mcm9tIDogc3AudG8pID09IG51bGwgJiZcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpXG4gICAgICAgIGZvdW5kID0gc3AubWFya2VyO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKTsgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSk7IH1cblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcbiAgLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXG4gIC8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cbiAgZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVObyk7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgY29udGludWU7XG4gICAgICB2YXIgZm91bmQgPSBzcC5tYXJrZXIuZmluZCgwKTtcbiAgICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcik7XG4gICAgICB2YXIgdG9DbXAgPSBjbXAoZm91bmQudG8sIHRvKSB8fCBleHRyYVJpZ2h0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcik7XG4gICAgICBpZiAoZnJvbUNtcCA+PSAwICYmIHRvQ21wIDw9IDAgfHwgZnJvbUNtcCA8PSAwICYmIHRvQ21wID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKGZyb21DbXAgPD0gMCAmJiAoY21wKGZvdW5kLnRvLCBmcm9tKSA+IDAgfHwgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCkpIHx8XG4gICAgICAgICAgZnJvbUNtcCA+PSAwICYmIChjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCB8fCAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbWFya2VyLmluY2x1c2l2ZVJpZ2h0KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgdmlzdWFsIGxpbmUgaXMgYSBsaW5lIGFzIGRyYXduIG9uIHRoZSBzY3JlZW4uIEZvbGRpbmcsIGZvclxuICAvLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcbiAgLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIGlzIHBhcnQgb2YgKHVzdWFsbHkgdGhhdCBpcyB0aGUgbGluZSBpdHNlbGYpLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxuICAvLyBzdGFydGVkIGJ5IHRoZSBhcmd1bWVudCwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBzdWNoIGxpbmVzLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkLCBsaW5lcztcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTtcbiAgICAgIChsaW5lcyB8fCAobGluZXMgPSBbXSkpLnB1c2gobGluZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIG51bWJlciBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lTm8oZG9jLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICBpZiAobGluZSA9PSB2aXMpIHJldHVybiBsaW5lTjtcbiAgICByZXR1cm4gbGluZU5vKHZpcyk7XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcbiAgLy8gdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHJldHVybiBsaW5lTjtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIG1lcmdlZDtcbiAgICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSByZXR1cm4gbGluZU47XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lO1xuICAgIHJldHVybiBsaW5lTm8obGluZSkgKyAxO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcbiAgLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxuICAvLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgZm9yICh2YXIgc3AsIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgY29udGludWU7XG4gICAgICBpZiAoc3AuZnJvbSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgY29udGludWU7XG4gICAgICBpZiAoc3AuZnJvbSA9PSAwICYmIHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0ICYmIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XG4gICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgdmFyIGVuZCA9IHNwYW4ubWFya2VyLmZpbmQoMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKTtcbiAgICB9XG4gICAgaWYgKHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIHNwYW4udG8gPT0gbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAodmFyIHNwLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmICFzcC5tYXJrZXIud2lkZ2V0Tm9kZSAmJiBzcC5mcm9tID09IHNwYW4udG8gJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXG4gICAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxuICAgICAgICAgIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBMSU5FIFdJREdFVFNcblxuICAvLyBMaW5lIHdpZGdldHMgYXJlIGJsb2NrIGVsZW1lbnRzIGRpc3BsYXllZCBhYm92ZSBvciBiZWxvdyBhIGxpbmUuXG5cbiAgdmFyIExpbmVXaWRnZXQgPSBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBmdW5jdGlvbihkb2MsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICB0aGlzW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfTtcbiAgZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcblxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XG4gICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcbiAgICAgIGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBkaWZmKTtcbiAgfVxuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgIGlmIChubyA9PSBudWxsIHx8ICF3cykgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIGlmICh3c1tpXSA9PSB0aGlzKSB3cy5zcGxpY2UoaS0tLCAxKTtcbiAgICBpZiAoIXdzLmxlbmd0aCkgbGluZS53aWRnZXRzID0gbnVsbDtcbiAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpO1xuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICBpZiAoY20pIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodCk7XG4gICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXCJ3aWRnZXRcIik7XG4gICAgfSk7XG4gIH07XG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkSCA9IHRoaXMuaGVpZ2h0LCBjbSA9IHRoaXMuZG9jLmNtLCBsaW5lID0gdGhpcy5saW5lO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB2YXIgZGlmZiA9IHdpZGdldEhlaWdodCh0aGlzKSAtIG9sZEg7XG4gICAgaWYgKCFkaWZmKSByZXR1cm47XG4gICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpO1xuICAgIGlmIChjbSkgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgcmV0dXJuIHdpZGdldC5oZWlnaHQ7XG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcbiAgICBpZiAoIWNtKSByZXR1cm4gMDtcbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxuICAgICAgICBwYXJlbnRTdHlsZSArPSBcIm1hcmdpbi1sZWZ0OiAtXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiO1xuICAgICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpXG4gICAgICAgIHBhcmVudFN0eWxlICs9IFwid2lkdGg6IFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXCJweDtcIjtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIG51bGwsIHBhcmVudFN0eWxlKSk7XG4gICAgfVxuICAgIHJldHVybiB3aWRnZXQuaGVpZ2h0ID0gd2lkZ2V0Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xuICAgIHZhciBjbSA9IGRvYy5jbTtcbiAgICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgY20uZGlzcGxheS5hbGlnbldpZGdldHMgPSB0cnVlO1xuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciB3aWRnZXRzID0gbGluZS53aWRnZXRzIHx8IChsaW5lLndpZGdldHMgPSBbXSk7XG4gICAgICBpZiAod2lkZ2V0Lmluc2VydEF0ID09IG51bGwpIHdpZGdldHMucHVzaCh3aWRnZXQpO1xuICAgICAgZWxzZSB3aWRnZXRzLnNwbGljZShNYXRoLm1pbih3aWRnZXRzLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpO1xuICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xuICAgICAgaWYgKGNtICYmICFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xuICAgICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcbiAgICAgICAgaWYgKGFib3ZlVmlzaWJsZSkgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIHdpZGdldC5oZWlnaHQpO1xuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2lkZ2V0O1xuICB9XG5cbiAgLy8gTElORSBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXG4gIC8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cbiAgdmFyIExpbmUgPSBDb2RlTWlycm9yLkxpbmUgPSBmdW5jdGlvbih0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcbiAgICB0aGlzLmhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQodGhpcykgOiAxO1xuICB9O1xuICBldmVudE1peGluKExpbmUpO1xuICBMaW5lLnByb3RvdHlwZS5saW5lTm8gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVObyh0aGlzKTsgfTtcblxuICAvLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxuICAvLyBpbnZhbGlkYXRlcyBjYWNoZWQgaW5mb3JtYXRpb24gYW5kIHRyaWVzIHRvIHJlLWVzdGltYXRlIHRoZVxuICAvLyBsaW5lJ3MgaGVpZ2h0LlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGxpbmUudGV4dCA9IHRleHQ7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcbiAgICBpZiAobGluZS5zdHlsZXMpIGxpbmUuc3R5bGVzID0gbnVsbDtcbiAgICBpZiAobGluZS5vcmRlciAhPSBudWxsKSBsaW5lLm9yZGVyID0gbnVsbDtcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgICBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBtYXJrZWRTcGFucyk7XG4gICAgdmFyIGVzdEhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQobGluZSkgOiAxO1xuICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTtcbiAgfVxuXG4gIC8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXG4gIGZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcbiAgICBsaW5lLnBhcmVudCA9IG51bGw7XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0TGluZUNsYXNzZXModHlwZSwgb3V0cHV0KSB7XG4gICAgaWYgKHR5cGUpIGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lQ2xhc3MgPSB0eXBlLm1hdGNoKC8oPzpefFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFMrKS8pO1xuICAgICAgaWYgKCFsaW5lQ2xhc3MpIGJyZWFrO1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgbGluZUNsYXNzLmluZGV4KSArIHR5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4ICsgbGluZUNsYXNzWzBdLmxlbmd0aCk7XG4gICAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFwiYmdDbGFzc1wiIDogXCJ0ZXh0Q2xhc3NcIjtcbiAgICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcbiAgICAgICAgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdO1xuICAgICAgZWxzZSBpZiAoIShuZXcgUmVnRXhwKFwiKD86XnxcXHMpXCIgKyBsaW5lQ2xhc3NbMl0gKyBcIig/OiR8XFxzKVwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxuICAgICAgICBvdXRwdXRbcHJvcF0gKz0gXCIgXCIgKyBsaW5lQ2xhc3NbMl07XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgcmV0dXJuIG1vZGUuYmxhbmtMaW5lKHN0YXRlKTtcbiAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSByZXR1cm47XG4gICAgdmFyIGlubmVyID0gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgc3RhdGUpO1xuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgaWYgKGlubmVyKSBpbm5lclswXSA9IENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlO1xuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xuICBmdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xuICAgIGZ1bmN0aW9uIGdldE9iaihjb3B5KSB7XG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdHJlYW0uc3RhcnQsIGVuZDogc3RyZWFtLnBvcyxcbiAgICAgICAgICAgICAgc3RyaW5nOiBzdHJlYW0uY3VycmVudCgpLFxuICAgICAgICAgICAgICB0eXBlOiBzdHlsZSB8fCBudWxsLFxuICAgICAgICAgICAgICBzdGF0ZTogY29weSA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGV9O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XG4gICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLCBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBwb3MubGluZSwgcHJlY2lzZSk7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCB0b2tlbnM7XG4gICAgaWYgKGFzQXJyYXkpIHRva2VucyA9IFtdO1xuICAgIHdoaWxlICgoYXNBcnJheSB8fCBzdHJlYW0ucG9zIDwgcG9zLmNoKSAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoYXNBcnJheSkgdG9rZW5zLnB1c2goZ2V0T2JqKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBnZXRPYmooKTtcbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxuICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBzdGF0ZSwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSBmbGF0dGVuU3BhbnMgPSBjbS5vcHRpb25zLmZsYXR0ZW5TcGFucztcbiAgICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgc3R5bGU7XG4gICAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSwgbGluZUNsYXNzZXMpO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlO1xuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKTtcbiAgICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgICBzdHlsZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZTtcbiAgICAgICAgaWYgKG1OYW1lKSBzdHlsZSA9IFwibS1cIiArIChzdHlsZSA/IG1OYW1lICsgXCIgXCIgKyBzdHlsZSA6IG1OYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gTWF0aC5taW4oc3RyZWFtLnN0YXJ0LCBjdXJTdGFydCArIDUwMDAwKTtcbiAgICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDQgY2hhcmFjdGVyc1xuICAgICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMDApO1xuICAgICAgZihwb3MsIGN1clN0eWxlKTtcbiAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxuICAvLyAtLSBmb3IgaW52YWxpZGF0aW9uIC0tIGZvbGxvd2VkIGJ5IHBhaXJzIG9mIGVuZCBwb3NpdGlvbnMgYW5kXG4gIC8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxuICAvLyBsaW5lLlxuICBmdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBzdGF0ZSwgZm9yY2VUb0VuZCkge1xuICAgIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXG4gICAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgc3RhdGUsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcbiAgICAgIHN0LnB1c2goZW5kLCBzdHlsZSk7XG4gICAgfSwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpO1xuXG4gICAgLy8gUnVuIG92ZXJsYXlzLCBhZGp1c3Qgc3R5bGUgYXJyYXkuXG4gICAgZm9yICh2YXIgbyA9IDA7IG8gPCBjbS5zdGF0ZS5vdmVybGF5cy5sZW5ndGg7ICsrbykge1xuICAgICAgdmFyIG92ZXJsYXkgPSBjbS5zdGF0ZS5vdmVybGF5c1tvXSwgaSA9IDEsIGF0ID0gMDtcbiAgICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCB0cnVlLCBmdW5jdGlvbihlbmQsIHN0eWxlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGEgdG9rZW4gZW5kIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhhdCBpIHBvaW50cyBhdCBpdFxuICAgICAgICB3aGlsZSAoYXQgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgaV9lbmQgPSBzdFtpXTtcbiAgICAgICAgICBpZiAoaV9lbmQgPiBlbmQpXG4gICAgICAgICAgICBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcbiAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcImNtLW92ZXJsYXkgXCIgKyBzdHlsZSk7XG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJjbS1vdmVybGF5IFwiICsgc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtzdHlsZXM6IHN0LCBjbGFzc2VzOiBsaW5lQ2xhc3Nlcy5iZ0NsYXNzIHx8IGxpbmVDbGFzc2VzLnRleHRDbGFzcyA/IGxpbmVDbGFzc2VzIDogbnVsbH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xuICAgIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xuICAgICAgdmFyIHJlc3VsdCA9IGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIGxpbmUuc3RhdGVBZnRlciA9IGdldFN0YXRlQmVmb3JlKGNtLCBsaW5lTm8obGluZSkpKTtcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgIGlmIChyZXN1bHQuY2xhc3NlcykgbGluZS5zdHlsZUNsYXNzZXMgPSByZXN1bHQuY2xhc3NlcztcbiAgICAgIGVsc2UgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7XG4gICAgICBpZiAodXBkYXRlRnJvbnRpZXIgPT09IGNtLmRvYy5mcm9udGllcikgY20uZG9jLmZyb250aWVyKys7XG4gICAgfVxuICAgIHJldHVybiBsaW5lLnN0eWxlcztcbiAgfVxuXG4gIC8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxuICAvLyBhcmVuJ3QgY3VycmVudGx5IHZpc2libGUuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBzdGF0ZSwgc3RhcnRBdCkge1xuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKTtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpICYmIHN0cmVhbS5wb3MgPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpIHtcbiAgICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBhIHN0eWxlIGFzIHJldHVybmVkIGJ5IGEgbW9kZSAoZWl0aGVyIG51bGwsIG9yIGEgc3RyaW5nXG4gIC8vIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGVzKSB0byBhIENTUyBzdHlsZS4gVGhpcyBpcyBjYWNoZWQsXG4gIC8vIGFuZCBhbHNvIGxvb2tzIGZvciBsaW5lLXdpZGUgc3R5bGVzLlxuICB2YXIgc3R5bGVUb0NsYXNzQ2FjaGUgPSB7fSwgc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA9IHt9O1xuICBmdW5jdGlvbiBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzdHlsZSB8fCAvXlxccyokLy50ZXN0KHN0eWxlKSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNhY2hlID0gb3B0aW9ucy5hZGRNb2RlQ2xhc3MgPyBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIDogc3R5bGVUb0NsYXNzQ2FjaGU7XG4gICAgcmV0dXJuIGNhY2hlW3N0eWxlXSB8fFxuICAgICAgKGNhY2hlW3N0eWxlXSA9IHN0eWxlLnJlcGxhY2UoL1xcUysvZywgXCJjbS0kJlwiKSk7XG4gIH1cblxuICAvLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXG4gIC8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcbiAgLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cbiAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcbiAgLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxuICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXG4gICAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXG4gICAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cbiAgICB2YXIgY29udGVudCA9IGVsdChcInNwYW5cIiwgbnVsbCwgbnVsbCwgd2Via2l0ID8gXCJwYWRkaW5nLXJpZ2h0OiAuMXB4XCIgOiBudWxsKTtcbiAgICB2YXIgYnVpbGRlciA9IHtwcmU6IGVsdChcInByZVwiLCBbY29udGVudF0pLCBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgIGNvbDogMCwgcG9zOiAwLCBjbTogY20sXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07XG4gICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyO1xuICAgICAgYnVpbGRlci5wb3MgPSAwO1xuICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW47XG4gICAgICAvLyBPcHRpb25hbGx5IHdpcmUgaW4gc29tZSBoYWNrcyBpbnRvIHRoZSB0b2tlbi1yZW5kZXJpbmdcbiAgICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgaWYgKGhhc0JhZEJpZGlSZWN0cyhjbS5kaXNwbGF5Lm1lYXN1cmUpICYmIChvcmRlciA9IGdldE9yZGVyKGxpbmUpKSlcbiAgICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTtcbiAgICAgIGJ1aWxkZXIubWFwID0gW107XG4gICAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XG4gICAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSk7XG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXG4gICAgICAgICAgYnVpbGRlci5iZ0NsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcywgYnVpbGRlci5iZ0NsYXNzIHx8IFwiXCIpO1xuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxuICAgICAgICAgIGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGF0IGxlYXN0IGEgc2luZ2xlIG5vZGUgaXMgcHJlc2VudCwgZm9yIG1lYXN1cmluZy5cbiAgICAgIGlmIChidWlsZGVyLm1hcC5sZW5ndGggPT0gMClcbiAgICAgICAgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcDtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKTtcbiAgICAgICAgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXG4gICAgaWYgKHdlYmtpdCAmJiAvXFxiY20tdGFiXFxiLy50ZXN0KGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGQuY2xhc3NOYW1lKSlcbiAgICAgIGJ1aWxkZXIuY29udGVudC5jbGFzc05hbWUgPSBcImNtLXRhYi13cmFwLWhhY2tcIjtcblxuICAgIHNpZ25hbChjbSwgXCJyZW5kZXJMaW5lXCIsIGNtLCBsaW5lVmlldy5saW5lLCBidWlsZGVyLnByZSk7XG4gICAgaWYgKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSlcbiAgICAgIGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTtcblxuICAgIHJldHVybiBidWlsZGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIoY2gpIHtcbiAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAyMlwiLCBcImNtLWludmFsaWRjaGFyXCIpO1xuICAgIHRva2VuLnRpdGxlID0gXCJcXFxcdVwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgdG9rZW4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0b2tlbi50aXRsZSk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cbiAgLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIHtcbiAgICBpZiAoIXRleHQpIHJldHVybjtcbiAgICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gdGV4dC5yZXBsYWNlKC8gezMsfS9nLCBzcGxpdFNwYWNlcykgOiB0ZXh0O1xuICAgIHZhciBzcGVjaWFsID0gYnVpbGRlci5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnMsIG11c3RXcmFwID0gZmFsc2U7XG4gICAgaWYgKCFzcGVjaWFsLnRlc3QodGV4dCkpIHtcbiAgICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dCk7XG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgbXVzdFdyYXAgPSB0cnVlO1xuICAgICAgYnVpbGRlci5wb3MgKz0gdGV4dC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3M7XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHRdKSk7XG4gICAgICAgICAgZWxzZSBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XG4gICAgICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBza2lwcGVkLCB0eHQpO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHNraXBwZWQ7XG4gICAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW0pIGJyZWFrO1xuICAgICAgICBwb3MgKz0gc2tpcHBlZCArIDE7XG4gICAgICAgIGlmIChtWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICB2YXIgdGFiU2l6ZSA9IGJ1aWxkZXIuY20ub3B0aW9ucy50YWJTaXplLCB0YWJXaWR0aCA9IHRhYlNpemUgLSBidWlsZGVyLmNvbCAlIHRhYlNpemU7XG4gICAgICAgICAgdmFyIHR4dCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBzcGFjZVN0cih0YWJXaWR0aCksIFwiY20tdGFiXCIpKTtcbiAgICAgICAgICB0eHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICB0eHQuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlxcdFwiKTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHh0ID0gYnVpbGRlci5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIobVswXSk7XG4gICAgICAgICAgdHh0LnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dF0pKTtcbiAgICAgICAgICBlbHNlIGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgMSwgdHh0KTtcbiAgICAgICAgYnVpbGRlci5wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzKSB7XG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXCJcIjtcbiAgICAgIGlmIChzdGFydFN0eWxlKSBmdWxsU3R5bGUgKz0gc3RhcnRTdHlsZTtcbiAgICAgIGlmIChlbmRTdHlsZSkgZnVsbFN0eWxlICs9IGVuZFN0eWxlO1xuICAgICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBbY29udGVudF0sIGZ1bGxTdHlsZSwgY3NzKTtcbiAgICAgIGlmICh0aXRsZSkgdG9rZW4udGl0bGUgPSB0aXRsZTtcbiAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pO1xuICAgIH1cbiAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpdFNwYWNlcyhvbGQpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoIC0gMjsgKytpKSBvdXQgKz0gaSAlIDIgPyBcIiBcIiA6IFwiXFx1MDBhMFwiO1xuICAgIG91dCArPSBcIiBcIjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXG4gIC8vIHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbkJhZEJpZGkoaW5uZXIsIG9yZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xuICAgICAgc3R5bGUgPSBzdHlsZSA/IHN0eWxlICsgXCIgY20tZm9yY2UtYm9yZGVyXCIgOiBcImNtLWZvcmNlLWJvcmRlclwiO1xuICAgICAgdmFyIHN0YXJ0ID0gYnVpbGRlci5wb3MsIGVuZCA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcyk7XG4gICAgICAgIGlubmVyKGJ1aWxkZXIsIHRleHQuc2xpY2UoMCwgcGFydC50byAtIHN0YXJ0KSwgc3R5bGUsIHN0YXJ0U3R5bGUsIG51bGwsIHRpdGxlLCBjc3MpO1xuICAgICAgICBzdGFydFN0eWxlID0gbnVsbDtcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UocGFydC50byAtIHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBwYXJ0LnRvO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcbiAgICB2YXIgd2lkZ2V0ID0gIWlnbm9yZVdpZGdldCAmJiBtYXJrZXIud2lkZ2V0Tm9kZTtcbiAgICBpZiAod2lkZ2V0KSBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNpemUsIHdpZGdldCk7XG4gICAgaWYgKCFpZ25vcmVXaWRnZXQgJiYgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0Lm5lZWRzQ29udGVudEF0dHJpYnV0ZSkge1xuICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgIHdpZGdldCA9IGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsIG1hcmtlci5pZCk7XG4gICAgfVxuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldCk7XG4gICAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcbiAgICB9XG4gICAgYnVpbGRlci5wb3MgKz0gc2l6ZTtcbiAgfVxuXG4gIC8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcbiAgLy8gYW5kIG1hcmtlZCB0ZXh0IGludG8gYWNjb3VudC5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xuICAgIGlmICghc3BhbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSs9MilcbiAgICAgICAgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcIlwiLCBzdHlsZSwgY3NzO1xuICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCB0aXRsZSwgY29sbGFwc2VkO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG4gICAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gdGl0bGUgPSBjc3MgPSBcIlwiO1xuICAgICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICBmb3VuZEJvb2ttYXJrcy5wdXNoKG0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xuICAgICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AudG87XG4gICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jbGFzc05hbWUpIHNwYW5TdHlsZSArPSBcIiBcIiArIG0uY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKG0uY3NzKSBjc3MgPSBtLmNzcztcbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHNwYW5TdGFydFN0eWxlICs9IFwiIFwiICsgbS5zdGFydFN0eWxlO1xuICAgICAgICAgICAgaWYgKG0uZW5kU3R5bGUgJiYgc3AudG8gPT0gbmV4dENoYW5nZSkgc3BhbkVuZFN0eWxlICs9IFwiIFwiICsgbS5lbmRTdHlsZTtcbiAgICAgICAgICAgIGlmIChtLnRpdGxlICYmICF0aXRsZSkgdGl0bGUgPSBtLnRpdGxlO1xuICAgICAgICAgICAgaWYgKG0uY29sbGFwc2VkICYmICghY29sbGFwc2VkIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGNvbGxhcHNlZC5tYXJrZXIsIG0pIDwgMCkpXG4gICAgICAgICAgICAgIGNvbGxhcHNlZCA9IHNwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xuICAgICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAoY29sbGFwc2VkLnRvID09IG51bGwgPyBsZW4gKyAxIDogY29sbGFwc2VkLnRvKSAtIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBwb3MpIGNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sbGFwc2VkICYmIGZvdW5kQm9va21hcmtzLmxlbmd0aCkgZm9yICh2YXIgaiA9IDA7IGogPCBmb3VuZEJvb2ttYXJrcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3Nbal0pO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSBsZW4pIGJyZWFrO1xuXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dDtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgdGl0bGUsIGNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVhazt9XG4gICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgIHNwYW5TdGFydFN0eWxlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSsrXSk7XG4gICAgICAgIHN0eWxlID0gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSsrXSwgYnVpbGRlci5jbS5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBET0NVTUVOVCBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIEJ5IGRlZmF1bHQsIHVwZGF0ZXMgdGhhdCBzdGFydCBhbmQgZW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gIC8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxuICAvLyB3aWRnZXRzIGFuZCBtYXJrZXIgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBiZWhhdmUgbW9yZSBpbnR1aXRpdmUuXG4gIGZ1bmN0aW9uIGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSB7XG4gICAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcIlwiICYmXG4gICAgICAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGNoYW5nZSBvbiB0aGUgZG9jdW1lbnQgZGF0YSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgZnVuY3Rpb24gc3BhbnNGb3Iobikge3JldHVybiBtYXJrZWRTcGFucyA/IG1hcmtlZFNwYW5zW25dIDogbnVsbDt9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XG4gICAgICBzaWduYWxMYXRlcihsaW5lLCBcImNoYW5nZVwiLCBsaW5lLCBjaGFuZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQsIHJlc3VsdCA9IFtdOyBpIDwgZW5kOyArK2kpXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xuICAgIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSk7XG4gICAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxuICAgIGlmIChjaGFuZ2UuZnVsbCkge1xuICAgICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgZG9jLnJlbW92ZSh0ZXh0Lmxlbmd0aCwgZG9jLnNpemUgLSB0ZXh0Lmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcbiAgICAgIC8vIHN1cmUgbGluZSBvYmplY3RzIG1vdmUgdGhlIHdheSB0aGV5IGFyZSBzdXBwb3NlZCB0by5cbiAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XG4gICAgICBpZiAobmxpbmVzKSBkb2MucmVtb3ZlKGZyb20ubGluZSwgbmxpbmVzKTtcbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYWRkZWQgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICBhZGRlZC5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSk7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBzcGFuc0ZvcigwKSk7XG4gICAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChubGluZXMgPiAxKSBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyAtIDEpO1xuICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCk7XG4gICAgfVxuXG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcImNoYW5nZVwiLCBkb2MsIGNoYW5nZSk7XG4gIH1cblxuICAvLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxuICAvLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXG4gIC8vXG4gIC8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XG4gIC8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXG5cbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMCwgaGVpZ2h0ID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aDsgfSxcbiAgICAvLyBSZW1vdmUgdGhlIG4gbGluZXMgYXQgb2Zmc2V0ICdhdCcuXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gYXQsIGUgPSBhdCArIG47IGkgPCBlOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgICB0aGlzLmhlaWdodCAtPSBsaW5lLmhlaWdodDtcbiAgICAgICAgY2xlYW5VcExpbmUobGluZSk7XG4gICAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiZGVsZXRlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5saW5lcy5zcGxpY2UoYXQsIG4pO1xuICAgIH0sXG4gICAgLy8gSGVscGVyIHVzZWQgdG8gY29sbGFwc2UgYSBzbWFsbCBicmFuY2ggaW50byBhIHNpbmdsZSBsZWFmLlxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgfSxcbiAgICAvLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgbGluZXNbaV0ucGFyZW50ID0gdGhpcztcbiAgICB9LFxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cbiAgICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XG4gICAgICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpXG4gICAgICAgIGlmIChvcCh0aGlzLmxpbmVzW2F0XSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xuICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBCcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZTsgfSxcbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgIHRoaXMuc2l6ZSAtPSBuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgICBjaGlsZC5yZW1vdmVJbm5lcihhdCwgcm0pO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IG9sZEhlaWdodCAtIGNoaWxkLmhlaWdodDtcbiAgICAgICAgICBpZiAoc3ogPT0gcm0pIHsgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaS0tLCAxKTsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxuICAgICAgICAgIGlmICgobiAtPSBybSkgPT0gMCkgYnJlYWs7XG4gICAgICAgICAgYXQgPSAwO1xuICAgICAgICB9IGVsc2UgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cbiAgICAgIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcbiAgICAgICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGVhZkNodW5rKGxpbmVzKV07XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB0aGlzLmNoaWxkcmVuW2ldLmNvbGxhcHNlKGxpbmVzKTtcbiAgICB9LFxuICAgIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xuICAgICAgdGhpcy5zaXplICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPD0gc3opIHtcbiAgICAgICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodCk7XG4gICAgICAgICAgaWYgKGNoaWxkLmxpbmVzICYmIGNoaWxkLmxpbmVzLmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgICAgdmFyIHNwaWxsZWQgPSBjaGlsZC5saW5lcy5zcGxpY2UoY2hpbGQubGluZXMubGVuZ3RoIC0gMjUsIDI1KTtcbiAgICAgICAgICAgICAgdmFyIG5ld2xlYWYgPSBuZXcgTGVhZkNodW5rKHNwaWxsZWQpO1xuICAgICAgICAgICAgICBjaGlsZC5oZWlnaHQgLT0gbmV3bGVhZi5oZWlnaHQ7XG4gICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGkgKyAxLCAwLCBuZXdsZWFmKTtcbiAgICAgICAgICAgICAgbmV3bGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF0IC09IHN6O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cbiAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgcmV0dXJuO1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xuICAgICAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvcHkucGFyZW50ID0gbWU7XG4gICAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XG4gICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplO1xuICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcbiAgICAgICAgICB2YXIgbXlJbmRleCA9IGluZGV4T2YobWUucGFyZW50LmNoaWxkcmVuLCBtZSk7XG4gICAgICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChtZS5jaGlsZHJlbi5sZW5ndGggPiAxMCk7XG4gICAgICBtZS5wYXJlbnQubWF5YmVTcGlsbCgpO1xuICAgIH0sXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIGJyZWFrO1xuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIGF0IC09IHN6O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgbmV4dERvY0lkID0gMDtcbiAgdmFyIERvYyA9IENvZGVNaXJyb3IuRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHJldHVybiBuZXcgRG9jKHRleHQsIG1vZGUsIGZpcnN0TGluZSk7XG4gICAgaWYgKGZpcnN0TGluZSA9PSBudWxsKSBmaXJzdExpbmUgPSAwO1xuXG4gICAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXCJcIiwgbnVsbCldKV0pO1xuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuY2FudEVkaXQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XG4gICAgdGhpcy5mcm9udGllciA9IGZpcnN0TGluZTtcbiAgICB2YXIgc3RhcnQgPSBQb3MoZmlyc3RMaW5lLCAwKTtcbiAgICB0aGlzLnNlbCA9IHNpbXBsZVNlbGVjdGlvbihzdGFydCk7XG4gICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgdGhpcy5pZCA9ICsrbmV4dERvY0lkO1xuICAgIHRoaXMubW9kZU9wdGlvbiA9IG1vZGU7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikgdGV4dCA9IHNwbGl0TGluZXModGV4dCk7XG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKTtcbiAgfTtcblxuICBEb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBEb2MsXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxuICAgIC8vIHRocmVlLCBpdCBpdGVyYXRlcyBvdmVyIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgZmlyc3QgdHdvICh3aXRoXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cbiAgICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcbiAgICAgIGlmIChvcCkgdGhpcy5pdGVyTihmcm9tIC0gdGhpcy5maXJzdCwgdG8gLSBmcm9tLCBvcCk7XG4gICAgICBlbHNlIHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7XG4gICAgfSxcblxuICAgIC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxuICAgIGluc2VydDogZnVuY3Rpb24oYXQsIGxpbmVzKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XG4gICAgICB0aGlzLmluc2VydElubmVyKGF0IC0gdGhpcy5maXJzdCwgbGluZXMsIGhlaWdodCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcblxuICAgIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgcmV0dXJuIGxpbmVzO1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCBcIlxcblwiKTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlKSB7XG4gICAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7XG4gICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzcGxpdExpbmVzKGNvZGUpLCBvcmlnaW46IFwic2V0VmFsdWVcIiwgZnVsbDogdHJ1ZX0sIHRydWUpO1xuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbih0b3ApKTtcbiAgICB9KSxcbiAgICByZXBsYWNlUmFuZ2U6IGZ1bmN0aW9uKGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcbiAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0QmV0d2Vlbih0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSk7XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHJldHVybiBsaW5lcztcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgXCJcXG5cIik7XG4gICAgfSxcblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0O30sXG5cbiAgICBnZXRMaW5lSGFuZGxlOiBmdW5jdGlvbihsaW5lKSB7aWYgKGlzTGluZSh0aGlzLCBsaW5lKSkgcmV0dXJuIGdldExpbmUodGhpcywgbGluZSk7fSxcbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihsaW5lKSB7cmV0dXJuIGxpbmVObyhsaW5lKTt9LFxuXG4gICAgZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7XG4gICAgICByZXR1cm4gdmlzdWFsTGluZShsaW5lKTtcbiAgICB9LFxuXG4gICAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zaXplO30sXG4gICAgZmlyc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdDt9LFxuICAgIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7fSxcblxuICAgIGNsaXBQb3M6IGZ1bmN0aW9uKHBvcykge3JldHVybiBjbGlwUG9zKHRoaXMsIHBvcyk7fSxcblxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHBvcyA9IHJhbmdlLmhlYWQ7XG4gICAgICBlbHNlIGlmIChzdGFydCA9PSBcImFuY2hvclwiKSBwb3MgPSByYW5nZS5hbmNob3I7XG4gICAgICBlbHNlIGlmIChzdGFydCA9PSBcImVuZFwiIHx8IHN0YXJ0ID09IFwidG9cIiB8fCBzdGFydCA9PT0gZmFsc2UpIHBvcyA9IHJhbmdlLnRvKCk7XG4gICAgICBlbHNlIHBvcyA9IHJhbmdlLmZyb20oKTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfSxcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXM7IH0sXG4gICAgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpO30sXG5cbiAgICBzZXRDdXJzb3I6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGNoLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgaGVhZCksIG90aGVyICYmIGNsaXBQb3ModGhpcywgb3RoZXIpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkcywgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMsIG9wdGlvbnMpKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgbWFwKHRoaXMuc2VsLnJhbmdlcywgZiksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIHNldFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlcywgcHJpbWFyeSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBpID0gMCwgb3V0ID0gW107IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uaGVhZCkpO1xuICAgICAgaWYgKHByaW1hcnkgPT0gbnVsbCkgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpO1xuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIHByaW1hcnkpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBhZGRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpKSk7XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgcmFuZ2VzLmxlbmd0aCAtIDEpLCBvcHRpb25zKTtcbiAgICB9KSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcywgbGluZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XG4gICAgICAgIGxpbmVzID0gbGluZXMgPyBsaW5lcy5jb25jYXQoc2VsKSA6IHNlbDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgcmV0dXJuIGxpbmVzO1xuICAgICAgZWxzZSByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IFwiXFxuXCIpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSBzZWwgPSBzZWwuam9pbihsaW5lU2VwIHx8IFwiXFxuXCIpO1xuICAgICAgICBwYXJ0c1tpXSA9IHNlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBkdXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICBkdXBbaV0gPSBjb2RlO1xuICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXCIraW5wdXRcIik7XG4gICAgfSxcbiAgICByZXBsYWNlU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xuICAgICAgdmFyIGNoYW5nZXMgPSBbXSwgc2VsID0gdGhpcy5zZWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgICAgY2hhbmdlc1tpXSA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpLCB0ZXh0OiBzcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXCJlbmRcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xuICAgICAgZm9yICh2YXIgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG1ha2VDaGFuZ2UodGhpcywgY2hhbmdlc1tpXSk7XG4gICAgICBpZiAobmV3U2VsKSBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpO1xuICAgICAgZWxzZSBpZiAodGhpcy5jbSkgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTtcbiAgICB9KSxcbiAgICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIpO30pLFxuICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIik7fSksXG4gICAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiLCB0cnVlKTt9KSxcbiAgICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIsIHRydWUpO30pLFxuXG4gICAgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbih2YWwpIHt0aGlzLmV4dGVuZCA9IHZhbDt9LFxuICAgIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kO30sXG5cbiAgICBoaXN0b3J5U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSwgZG9uZSA9IDAsIHVuZG9uZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QuZG9uZS5sZW5ndGg7IGkrKykgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSArK2RvbmU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QudW5kb25lLmxlbmd0aDsgaSsrKSBpZiAoIWhpc3QudW5kb25lW2ldLnJhbmdlcykgKyt1bmRvbmU7XG4gICAgICByZXR1cm4ge3VuZG86IGRvbmUsIHJlZG86IHVuZG9uZX07XG4gICAgfSxcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge3RoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTt9LFxuXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xuICAgIH0sXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgaWYgKGZvcmNlU3BsaXQpXG4gICAgICAgIHRoaXMuaGlzdG9yeS5sYXN0T3AgPSB0aGlzLmhpc3RvcnkubGFzdFNlbE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RPcmlnaW4gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uO1xuICAgIH0sXG4gICAgaXNDbGVhbjogZnVuY3Rpb24gKGdlbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pO1xuICAgIH0sXG5cbiAgICBnZXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7ZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSksXG4gICAgICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKX07XG4gICAgfSxcbiAgICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbik7XG4gICAgICBoaXN0LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xuICAgICAgaGlzdC51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLnVuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGFkZExpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIGxpbmVbcHJvcF0gPSBjbHM7XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICB2YXIgY3VyID0gbGluZVtwcm9wXTtcbiAgICAgICAgaWYgKCFjdXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIGxpbmVbcHJvcF0gPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBjdXIubWF0Y2goY2xhc3NUZXN0KGNscykpO1xuICAgICAgICAgIGlmICghZm91bmQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YXIgZW5kID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGg7XG4gICAgICAgICAgbGluZVtwcm9wXSA9IGN1ci5zbGljZSgwLCBmb3VuZC5pbmRleCkgKyAoIWZvdW5kLmluZGV4IHx8IGVuZCA9PSBjdXIubGVuZ3RoID8gXCJcIiA6IFwiIFwiKSArIGN1ci5zbGljZShlbmQpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICByZW1vdmVMaW5lV2lkZ2V0OiBmdW5jdGlvbih3aWRnZXQpIHsgd2lkZ2V0LmNsZWFyKCk7IH0sXG5cbiAgICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtYXJrVGV4dCh0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSwgb3B0aW9ucywgXCJyYW5nZVwiKTtcbiAgICB9LFxuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudHM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcImJvb2ttYXJrXCIpO1xuICAgIH0sXG4gICAgZmluZE1hcmtzQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcGFucykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICBpZiAoKHNwYW4uZnJvbSA9PSBudWxsIHx8IHNwYW4uZnJvbSA8PSBwb3MuY2gpICYmXG4gICAgICAgICAgICAoc3Bhbi50byA9PSBudWxsIHx8IHNwYW4udG8gPj0gcG9zLmNoKSlcbiAgICAgICAgICBtYXJrZXJzLnB1c2goc3Bhbi5tYXJrZXIucGFyZW50IHx8IHNwYW4ubWFya2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTsgdG8gPSBjbGlwUG9zKHRoaXMsIHRvKTtcbiAgICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmU7XG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICAgIGlmICghKGxpbmVObyA9PSBmcm9tLmxpbmUgJiYgZnJvbS5jaCA+IHNwYW4udG8gfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8gIT0gZnJvbS5saW5lfHxcbiAgICAgICAgICAgICAgICBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPiB0by5jaCkgJiZcbiAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyKHNwYW4ubWFya2VyKSkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgKytsaW5lTm87XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgc3BzID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgaWYgKHNwcykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIG1hcmtlcnMucHVzaChzcHNbaV0ubWFya2VyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSxcblxuICAgIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XG4gICAgICB2YXIgY2gsIGxpbmVObyA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgc3ogPSBsaW5lLnRleHQubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKHN6ID4gb2ZmKSB7IGNoID0gb2ZmOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICBvZmYgLT0gc3o7XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vLCBjaCkpO1xuICAgIH0sXG4gICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHJldHVybiAwO1xuICAgICAgdGhpcy5pdGVyKHRoaXMuZmlyc3QsIGNvb3Jkcy5saW5lLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihjb3B5SGlzdG9yeSkge1xuICAgICAgdmFyIGRvYyA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgdGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSksIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCk7XG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XG4gICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2M7XG4gICAgfSxcblxuICAgIGxpbmtlZERvYzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSBmcm9tID0gb3B0aW9ucy5mcm9tO1xuICAgICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHRvID0gb3B0aW9ucy50bztcbiAgICAgIHZhciBjb3B5ID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCBmcm9tLCB0byksIG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGVPcHRpb24sIGZyb20pO1xuICAgICAgaWYgKG9wdGlvbnMuc2hhcmVkSGlzdCkgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuICAgICAgKHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcbiAgICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XTtcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG4gICAgdW5saW5rRG9jOiBmdW5jdGlvbihvdGhlcikge1xuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29kZU1pcnJvcikgb3RoZXIgPSBvdGhlci5kb2M7XG4gICAgICBpZiAodGhpcy5saW5rZWQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5rZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmxpbmtlZFtpXTtcbiAgICAgICAgaWYgKGxpbmsuZG9jICE9IG90aGVyKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy5saW5rZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICBvdGhlci51bmxpbmtEb2ModGhpcyk7XG4gICAgICAgIGRldGFjaFNoYXJlZE1hcmtlcnMoZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbiAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbihkb2MpIHtzcGxpdElkcy5wdXNoKGRvYy5pZCk7fSwgdHJ1ZSk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXG5cbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlO30sXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbTt9XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBhbGlhcy5cbiAgRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcblxuICAvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cbiAgdmFyIGRvbnREZWxlZ2F0ZSA9IFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpIGlmIChEb2MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmIGluZGV4T2YoZG9udERlbGVnYXRlLCBwcm9wKSA8IDApXG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYywgYXJndW1lbnRzKTt9O1xuICAgIH0pKERvYy5wcm90b3R5cGVbcHJvcF0pO1xuXG4gIGV2ZW50TWl4aW4oRG9jKTtcblxuICAvLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGUoZG9jLCBza2lwLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoZG9jLmxpbmtlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZWwgPSBkb2MubGlua2VkW2ldO1xuICAgICAgICBpZiAocmVsLmRvYyA9PSBza2lwKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHNoYXJlZCA9IHNoYXJlZEhpc3QgJiYgcmVsLnNoYXJlZEhpc3Q7XG4gICAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSBjb250aW51ZTtcbiAgICAgICAgZihyZWwuZG9jLCBzaGFyZWQpO1xuICAgICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wYWdhdGUoZG9jLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBhIGRvY3VtZW50IHRvIGFuIGVkaXRvci5cbiAgZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcbiAgICBpZiAoZG9jLmNtKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKTtcbiAgICBjbS5kb2MgPSBkb2M7XG4gICAgZG9jLmNtID0gY207XG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XG4gICAgbG9hZE1vZGUoY20pO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGZpbmRNYXhMaW5lKGNtKTtcbiAgICBjbS5vcHRpb25zLm1vZGUgPSBkb2MubW9kZU9wdGlvbjtcbiAgICByZWdDaGFuZ2UoY20pO1xuICB9XG5cbiAgLy8gTElORSBVVElMSVRJRVNcblxuICAvLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcbiAgICBuIC09IGRvYy5maXJzdDtcbiAgICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gbGluZSBcIiArIChuICsgZG9jLmZpcnN0KSArIFwiIGluIHRoZSBkb2N1bWVudC5cIik7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBkb2M7ICFjaHVuay5saW5lczspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrOyB9XG4gICAgICAgIG4gLT0gc3o7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaHVuay5saW5lc1tuXTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcbiAgLy8gc3RyaW5ncy5cbiAgZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xuICAgIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHRleHQgPSBsaW5lLnRleHQ7XG4gICAgICBpZiAobiA9PSBlbmQubGluZSkgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTtcbiAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHRleHQgPSB0ZXh0LnNsaWNlKHN0YXJ0LmNoKTtcbiAgICAgIG91dC5wdXNoKHRleHQpO1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbihsaW5lKSB7IG91dC5wdXNoKGxpbmUudGV4dCk7IH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHByb3BhZ2F0aW5nIHRoZSBoZWlnaHQgY2hhbmdlXG4gIC8vIHVwd2FyZHMgdG8gcGFyZW50IG5vZGVzLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGhlaWdodCkge1xuICAgIHZhciBkaWZmID0gaGVpZ2h0IC0gbGluZS5oZWlnaHQ7XG4gICAgaWYgKGRpZmYpIGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIG4uaGVpZ2h0ICs9IGRpZmY7XG4gIH1cblxuICAvLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcbiAgLy8gaXRzIHBhcmVudCBsaW5rcy5cbiAgZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcbiAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKTtcbiAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIGJyZWFrO1xuICAgICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0O1xuICB9XG5cbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG4gIGZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgb3V0ZXI6IGRvIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIGNoID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICBpZiAoaCA8IGNoKSB7IGNodW5rID0gY2hpbGQ7IGNvbnRpbnVlIG91dGVyOyB9XG4gICAgICAgIGggLT0gY2g7XG4gICAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaCA8IGxoKSBicmVhaztcbiAgICAgIGggLT0gbGg7XG4gICAgfVxuICAgIHJldHVybiBuICsgaTtcbiAgfVxuXG5cbiAgLy8gRmluZCB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xuICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuXG4gICAgdmFyIGggPSAwLCBjaHVuayA9IGxpbmVPYmoucGFyZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XG4gICAgICBpZiAobGluZSA9PSBsaW5lT2JqKSBicmVhaztcbiAgICAgIGVsc2UgaCArPSBsaW5lLmhlaWdodDtcbiAgICB9XG4gICAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjdXIgPT0gY2h1bmspIGJyZWFrO1xuICAgICAgICBlbHNlIGggKz0gY3VyLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGg7XG4gIH1cblxuICAvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXG4gIC8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcbiAgLy8gQmlkaVNwYW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGxpbmUpIHtcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgIGlmIChvcmRlciA9PSBudWxsKSBvcmRlciA9IGxpbmUub3JkZXIgPSBiaWRpT3JkZXJpbmcobGluZS50ZXh0KTtcbiAgICByZXR1cm4gb3JkZXI7XG4gIH1cblxuICAvLyBISVNUT1JZXG5cbiAgZnVuY3Rpb24gSGlzdG9yeShzdGFydEdlbikge1xuICAgIC8vIEFycmF5cyBvZiBjaGFuZ2UgZXZlbnRzIGFuZCBzZWxlY3Rpb25zLiBEb2luZyBzb21ldGhpbmcgYWRkcyBhblxuICAgIC8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcbiAgICAvLyB0byB1bmRvbmUsIHJlZG9pbmcgbW92ZXMgdGhlbSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgIHRoaXMuZG9uZSA9IFtdOyB0aGlzLnVuZG9uZSA9IFtdO1xuICAgIHRoaXMudW5kb0RlcHRoID0gSW5maW5pdHk7XG4gICAgLy8gVXNlZCB0byB0cmFjayB3aGVuIGNoYW5nZXMgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIHVuZG9cbiAgICAvLyBldmVudFxuICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLmxhc3RTZWxUaW1lID0gMDtcbiAgICB0aGlzLmxhc3RPcCA9IHRoaXMubGFzdFNlbE9wID0gbnVsbDtcbiAgICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIC8vIFVzZWQgYnkgdGhlIGlzQ2xlYW4oKSBtZXRob2RcbiAgICB0aGlzLmdlbmVyYXRpb24gPSB0aGlzLm1heEdlbmVyYXRpb24gPSBzdGFydEdlbiB8fCAxO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXG4gIC8vIG9iamVjdC5cbiAgZnVuY3Rpb24gaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9O1xuICAgIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO1xuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MpIHthdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTt9LCB0cnVlKTtcbiAgICByZXR1cm4gaGlzdENoYW5nZTtcbiAgfVxuXG4gIC8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcbiAgLy8gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xuICAgICAgaWYgKGxhc3QucmFuZ2VzKSBhcnJheS5wb3AoKTtcbiAgICAgIGVsc2UgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cbiAgLy8gZXZlbnRzIHRoYXQgYXJlIGluIHRoZSB3YXkuXG4gIGZ1bmN0aW9uIGxhc3RDaGFuZ2VFdmVudChoaXN0LCBmb3JjZSkge1xuICAgIGlmIChmb3JjZSkge1xuICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKTtcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpO1xuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCA+IDEgJiYgIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMl0ucmFuZ2VzKSB7XG4gICAgICBoaXN0LmRvbmUucG9wKCk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgaW4gdGhlIGhpc3RvcnkuIE1lcmdlcyBjaGFuZ2VzIHRoYXQgYXJlIHdpdGhpblxuICAvLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yZSBhcmUgY2xvc2UgdG9nZXRoZXIgd2l0aCBhbiBvcmlnaW4gdGhhdFxuICAvLyBhbGxvd3MgbWVyZ2luZyAoc3RhcnRpbmcgd2l0aCBcIitcIikgaW50byBhIHNpbmdsZSBldmVudC5cbiAgZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgb3BJZCkge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XG4gICAgaGlzdC51bmRvbmUubGVuZ3RoID0gMDtcbiAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSwgY3VyO1xuXG4gICAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XG4gICAgICAgICBoaXN0Lmxhc3RPcmlnaW4gPT0gY2hhbmdlLm9yaWdpbiAmJiBjaGFuZ2Uub3JpZ2luICYmXG4gICAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiK1wiICYmIGRvYy5jbSAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5KSB8fFxuICAgICAgICAgIGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiKlwiKSkgJiZcbiAgICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcbiAgICAgIC8vIE1lcmdlIHRoaXMgY2hhbmdlIGludG8gdGhlIGxhc3QgZXZlbnRcbiAgICAgIHZhciBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKTtcbiAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcbiAgICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcbiAgICAgICAgLy8gbmV3IGNoYW5nZXNldHMgZm9yIGV2ZXJ5IGNoYXJhY3RlciB0eXBlZFxuICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbmV3IHN1Yi1ldmVudFxuICAgICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cbiAgICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKTtcbiAgICAgIGlmICghYmVmb3JlIHx8ICFiZWZvcmUucmFuZ2VzKVxuICAgICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSk7XG4gICAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXG4gICAgICAgICAgICAgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufTtcbiAgICAgIGhpc3QuZG9uZS5wdXNoKGN1cik7XG4gICAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XG4gICAgICAgIGhpc3QuZG9uZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIWhpc3QuZG9uZVswXS5yYW5nZXMpIGhpc3QuZG9uZS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcik7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gKytoaXN0Lm1heEdlbmVyYXRpb247XG4gICAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lO1xuICAgIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IGNoYW5nZS5vcmlnaW47XG5cbiAgICBpZiAoIWxhc3QpIHNpZ25hbChkb2MsIFwiaGlzdG9yeUFkZGVkXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gY2ggPT0gXCIqXCIgfHxcbiAgICAgIGNoID09IFwiK1wiICYmXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xuICAvLyB0aGUgcGVuZGluZyBzZWxlY3Rpb24gaW4gdGhlIGhpc3RvcnksIGFuZCBwdXNoZXMgdGhlIG9sZCBwZW5kaW5nXG4gIC8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxuICAvLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXG4gIGZ1bmN0aW9uIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIHNlbCwgb3BJZCwgb3B0aW9ucykge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW47XG5cbiAgICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxuICAgIC8vIHRoZSBjdXJyZW50LCBvciB0aGUgb3JpZ2lucyBkb24ndCBhbGxvdyBtYXRjaGluZy4gT3JpZ2luc1xuICAgIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxuICAgIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXG4gICAgaWYgKG9wSWQgPT0gaGlzdC5sYXN0U2VsT3AgfHxcbiAgICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXG4gICAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcbiAgICAgICAgICBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBsc3QoaGlzdC5kb25lKSwgc2VsKSkpKVxuICAgICAgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICBlbHNlXG4gICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgaGlzdC5kb25lKTtcblxuICAgIGhpc3QubGFzdFNlbFRpbWUgPSArbmV3IERhdGU7XG4gICAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luO1xuICAgIGhpc3QubGFzdFNlbE9wID0gb3BJZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpXG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xuICAgIHZhciB0b3AgPSBsc3QoZGVzdCk7XG4gICAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcbiAgICAgIGRlc3QucHVzaChzZWwpO1xuICB9XG5cbiAgLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKVxuICAgICAgICAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICArK247XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIHVuL3JlLWRvaW5nIHJlc3RvcmVzIHRleHQgY29udGFpbmluZyBtYXJrZWQgc3BhbnMsIHRob3NlXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxuICBmdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSByZXR1cm4gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMCwgb3V0OyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzcGFuc1tpXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQpIHsgaWYgKCFvdXQpIG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpOyB9XG4gICAgICBlbHNlIGlmIChvdXQpIG91dC5wdXNoKHNwYW5zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0cmlldmUgYW5kIGZpbHRlciB0aGUgb2xkIG1hcmtlZCBzcGFucyBzdG9yZWQgaW4gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgIGlmICghZm91bmQpIHJldHVybiBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwLCBudyA9IFtdOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXG4gICAgICBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpO1xuICAgIHJldHVybiBudztcbiAgfVxuXG4gIC8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXG4gIC8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cbiAgZnVuY3Rpb24gY29weUhpc3RvcnlBcnJheShldmVudHMsIG5ld0dyb3VwLCBpbnN0YW50aWF0ZVNlbCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3B5ID0gW107IGkgPCBldmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtO1xuICAgICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xuICAgICAgICBpZiAobmV3R3JvdXApIGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIC8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xuICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSArPSBkaWZmO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICBwb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xuICAvLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxuICAvLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXG4gIC8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcbiAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uYW5jaG9yLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGN1ciA9IHN1Yi5jaGFuZ2VzW2pdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgfVxuXG4gIC8vIEVWRU5UIFVUSUxJVElFU1xuXG4gIC8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxuXG4gIHZhciBlX3ByZXZlbnREZWZhdWx0ID0gQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIH07XG4gIHZhciBlX3N0b3BQcm9wYWdhdGlvbiA9IENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsc2UgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICB9O1xuICBmdW5jdGlvbiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkge1xuICAgIHJldHVybiBlLmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IGUuZGVmYXVsdFByZXZlbnRlZCA6IGUucmV0dXJuVmFsdWUgPT0gZmFsc2U7XG4gIH1cbiAgdmFyIGVfc3RvcCA9IENvZGVNaXJyb3IuZV9zdG9wID0gZnVuY3Rpb24oZSkge2VfcHJldmVudERlZmF1bHQoZSk7IGVfc3RvcFByb3BhZ2F0aW9uKGUpO307XG5cbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIGIgPSAxO1xuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSBiID0gMztcbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgNCkgYiA9IDI7XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgYiA9IDM7XG4gICAgcmV0dXJuIGI7XG4gIH1cblxuICAvLyBFVkVOVCBIQU5ETElOR1xuXG4gIC8vIExpZ2h0d2VpZ2h0IGV2ZW50IGZyYW1ld29yay4gb24vb2ZmIGFsc28gd29yayBvbiBET00gbm9kZXMsXG4gIC8vIHJlZ2lzdGVyaW5nIG5hdGl2ZSBET00gaGFuZGxlcnMuXG5cbiAgdmFyIG9uID0gQ29kZU1pcnJvci5vbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KVxuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSk7XG4gICAgICB2YXIgYXJyID0gbWFwW3R5cGVdIHx8IChtYXBbdHlwZV0gPSBbXSk7XG4gICAgICBhcnIucHVzaChmKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9mZiA9IENvZGVNaXJyb3Iub2ZmID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xuICAgIGlmIChlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpXG4gICAgICBlbWl0dGVyLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGFyciA9IGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdO1xuICAgICAgaWYgKCFhcnIpIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoYXJyW2ldID09IGYpIHsgYXJyLnNwbGljZShpLCAxKTsgYnJlYWs7IH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNpZ25hbCA9IENvZGVNaXJyb3Iuc2lnbmFsID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcbiAgICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV07XG4gICAgaWYgKCFhcnIpIHJldHVybjtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGFycltpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG5cbiAgLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcbiAgLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xuICAvLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxuICAvLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cbiAgLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXG4gIC8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXG4gIC8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxuICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBhcnIgPSBlbWl0dGVyLl9oYW5kbGVycyAmJiBlbWl0dGVyLl9oYW5kbGVyc1t0eXBlXTtcbiAgICBpZiAoIWFycikgcmV0dXJuO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgbGlzdDtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSBpZiAob3JwaGFuRGVsYXllZENhbGxiYWNrcykge1xuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICBzZXRUaW1lb3V0KGZpcmVPcnBoYW5EZWxheWVkLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5kKGYpIHtyZXR1cm4gZnVuY3Rpb24oKXtmLmFwcGx5KG51bGwsIGFyZ3MpO307fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSlcbiAgICAgIGxpc3QucHVzaChibmQoYXJyW2ldKSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcbiAgICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XG4gICAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSBkZWxheWVkW2ldKCk7XG4gIH1cblxuICAvLyBUaGUgRE9NIGV2ZW50cyB0aGF0IENvZGVNaXJyb3IgaGFuZGxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieVxuICAvLyByZWdpc3RlcmluZyBhIChub24tRE9NKSBoYW5kbGVyIG9uIHRoZSBlZGl0b3IgZm9yIHRoZSBldmVudCBuYW1lLFxuICAvLyBhbmQgcHJldmVudERlZmF1bHQtaW5nIHRoZSBldmVudCBpbiB0aGF0IGhhbmRsZXIuXG4gIGZ1bmN0aW9uIHNpZ25hbERPTUV2ZW50KGNtLCBlLCBvdmVycmlkZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgZSA9IHt0eXBlOiBlLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19O1xuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XG4gICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmU7XG4gIH1cblxuICBmdW5jdGlvbiBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkge1xuICAgIHZhciBhcnIgPSBjbS5faGFuZGxlcnMgJiYgY20uX2hhbmRsZXJzLmN1cnNvckFjdGl2aXR5O1xuICAgIGlmICghYXJyKSByZXR1cm47XG4gICAgdmFyIHNldCA9IGNtLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgfHwgKGNtLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgPSBbXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGlmIChpbmRleE9mKHNldCwgYXJyW2ldKSA9PSAtMSlcbiAgICAgIHNldC5wdXNoKGFycltpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV07XG4gICAgcmV0dXJuIGFyciAmJiBhcnIubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XG4gICAgY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmKSB7b24odGhpcywgdHlwZSwgZik7fTtcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XG4gIH1cblxuICAvLyBNSVNDIFVUSUxJVElFU1xuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG4gIHZhciBzY3JvbGxlckdhcCA9IDMwO1xuXG4gIC8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcbiAgLy8gaGFuZGxpbmcgdGhpcycuXG4gIHZhciBQYXNzID0gQ29kZU1pcnJvci5QYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuUGFzc1wiO319O1xuXG4gIC8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xuICB2YXIgc2VsX2RvbnRTY3JvbGwgPSB7c2Nyb2xsOiBmYWxzZX0sIHNlbF9tb3VzZSA9IHtvcmlnaW46IFwiKm1vdXNlXCJ9LCBzZWxfbW92ZSA9IHtvcmlnaW46IFwiK21vdmVcIn07XG5cbiAgZnVuY3Rpb24gRGVsYXllZCgpIHt0aGlzLmlkID0gbnVsbDt9XG4gIERlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG1zLCBmKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KGYsIG1zKTtcbiAgfTtcblxuICAvLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbiAgLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbiAgdmFyIGNvdW50Q29sdW1uID0gQ29kZU1pcnJvci5jb3VudENvbHVtbiA9IGZ1bmN0aW9uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcbiAgICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXCJcXHRcIiwgaSk7XG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXG4gICAgICAgIHJldHVybiBuICsgKGVuZCAtIGkpO1xuICAgICAgbiArPSBuZXh0VGFiIC0gaTtcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICBpID0gbmV4dFRhYiArIDE7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXG4gIGZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XG4gICAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIHBvcyk7XG4gICAgICBpZiAobmV4dFRhYiA9PSAtMSkgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgc2tpcHBlZCA9IG5leHRUYWIgLSBwb3M7XG4gICAgICBpZiAobmV4dFRhYiA9PSBzdHJpbmcubGVuZ3RoIHx8IGNvbCArIHNraXBwZWQgPj0gZ29hbClcbiAgICAgICAgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpO1xuICAgICAgY29sICs9IG5leHRUYWIgLSBwb3M7XG4gICAgICBjb2wgKz0gdGFiU2l6ZSAtIChjb2wgJSB0YWJTaXplKTtcbiAgICAgIHBvcyA9IG5leHRUYWIgKyAxO1xuICAgICAgaWYgKGNvbCA+PSBnb2FsKSByZXR1cm4gcG9zO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcGFjZVN0cnMgPSBbXCJcIl07XG4gIGZ1bmN0aW9uIHNwYWNlU3RyKG4pIHtcbiAgICB3aGlsZSAoc3BhY2VTdHJzLmxlbmd0aCA8PSBuKVxuICAgICAgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcIiBcIik7XG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxzdChhcnIpIHsgcmV0dXJuIGFyclthcnIubGVuZ3RoLTFdOyB9XG5cbiAgdmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xuICBpZiAoaW9zKSAvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cbiAgICBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3Rpb25TdGFydCA9IDA7IG5vZGUuc2VsZWN0aW9uRW5kID0gbm9kZS52YWx1ZS5sZW5ndGg7IH07XG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG4gICAgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCk7IH0gY2F0Y2goX2UpIHt9IH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgIGlmIChhcnJheVtpXSA9PSBlbHQpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBtYXAoYXJyYXksIGYpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgb3V0W2ldID0gZihhcnJheVtpXSwgaSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgY29weU9iaihwcm9wcywgaW5zdCk7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29weU9iaihvYmosIHRhcmdldCwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAob3ZlcndyaXRlICE9PSBmYWxzZSB8fCAhdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5kKGYpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7fTtcbiAgfVxuXG4gIHZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbiAgdmFyIGlzV29yZENoYXJCYXNpYyA9IENvZGVNaXJyb3IuaXNXb3JkQ2hhciA9IGZ1bmN0aW9uKGNoKSB7XG4gICAgcmV0dXJuIC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmXG4gICAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKTtcbiAgfTtcbiAgZnVuY3Rpb24gaXNXb3JkQ2hhcihjaCwgaGVscGVyKSB7XG4gICAgaWYgKCFoZWxwZXIpIHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpO1xuICAgIGlmIChoZWxwZXIuc291cmNlLmluZGV4T2YoXCJcXFxcd1wiKSA+IC0xICYmIGlzV29yZENoYXJCYXNpYyhjaCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBoZWxwZXIudGVzdChjaCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xuICAvLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXG4gIC8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXG4gIC8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXG4gIC8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXG4gIHZhciBleHRlbmRpbmdDaGFycyA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztcbiAgZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApID49IDc2OCAmJiBleHRlbmRpbmdDaGFycy50ZXN0KGNoKTsgfVxuXG4gIC8vIERPTSBVVElMSVRJRVNcblxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKHN0eWxlKSBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIikgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XG4gICAgZWxzZSBpZiAoY29udGVudCkgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSBlLmFwcGVuZENoaWxkKGNvbnRlbnRbaV0pO1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIHJhbmdlO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xuICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZCk7XG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIGVsc2UgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHRyeSB7IHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIHI7IH1cbiAgICByLmNvbGxhcHNlKHRydWUpO1xuICAgIHIubW92ZUVuZChcImNoYXJhY3RlclwiLCBlbmQpO1xuICAgIHIubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIHN0YXJ0KTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXG4gICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKTtcbiAgfVxuXG4gIHZhciBjb250YWlucyA9IENvZGVNaXJyb3IuY29udGFpbnMgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcbiAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gICAgZG8ge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSBjaGlsZCA9IGNoaWxkLmhvc3Q7XG4gICAgICBpZiAoY2hpbGQgPT0gcGFyZW50KSByZXR1cm4gdHJ1ZTtcbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHsgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IH1cbiAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhyb3dzIHVuc3BlY2lmaWVkIGVycm9yIHdoZW4gdG91Y2hpbmdcbiAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBzb21lIGNhc2VzIChkdXJpbmcgbG9hZGluZywgaW4gaWZyYW1lKVxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSBhY3RpdmVFbHQgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkgeyByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGRvY3VtZW50LmJvZHk7IH1cbiAgfTtcblxuICBmdW5jdGlvbiBjbGFzc1Rlc3QoY2xzKSB7IHJldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbHMgKyBcIig/OiR8XFxcXHMpXFxcXHMqXCIpOyB9XG4gIHZhciBybUNsYXNzID0gQ29kZU1pcnJvci5ybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFwiXCIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGFkZENsYXNzID0gQ29kZU1pcnJvci5hZGRDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNscykge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFwiIFwiIDogXCJcIikgKyBjbHM7XG4gIH07XG4gIGZ1bmN0aW9uIGpvaW5DbGFzc2VzKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIGIgKz0gXCIgXCIgKyBhc1tpXTtcbiAgICByZXR1cm4gYjtcbiAgfVxuXG4gIC8vIFdJTkRPVy1XSURFIEVWRU5UU1xuXG4gIC8vIFRoZXNlIG11c3QgYmUgaGFuZGxlZCBjYXJlZnVsbHksIGJlY2F1c2UgbmFpdmVseSByZWdpc3RlcmluZyBhXG4gIC8vIGhhbmRsZXIgZm9yIGVhY2ggZWRpdG9yIHdpbGwgY2F1c2UgdGhlIGVkaXRvcnMgdG8gbmV2ZXIgYmVcbiAgLy8gZ2FyYmFnZSBjb2xsZWN0ZWQuXG5cbiAgZnVuY3Rpb24gZm9yRWFjaENvZGVNaXJyb3IoZikge1xuICAgIGlmICghZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSByZXR1cm47XG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnlDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xuICAgICAgaWYgKGNtKSBmKGNtKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2xvYmFsc1JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgaWYgKGdsb2JhbHNSZWdpc3RlcmVkKSByZXR1cm47XG4gICAgcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpO1xuICAgIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCkge1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWN0aXZlIGVkaXRvcnMuXG4gICAgdmFyIHJlc2l6ZVRpbWVyO1xuICAgIG9uKHdpbmRvdywgXCJyZXNpemVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgcmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IGxvc2VzIGZvY3VzLCB3ZSB3YW50IHRvIHNob3cgdGhlIGVkaXRvciBhcyBibHVycmVkXG4gICAgb24od2luZG93LCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRkVBVFVSRSBERVRFQ1RJT05cblxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxuICB2YXIgZHJhZ0FuZERyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xuICAgIHJldHVybiBcImRyYWdnYWJsZVwiIGluIGRpdiB8fCBcImRyYWdEcm9wXCIgaW4gZGl2O1xuICB9KCk7XG5cbiAgdmFyIHp3c3BTdXBwb3J0ZWQ7XG4gIGZ1bmN0aW9uIHplcm9XaWR0aEVsZW1lbnQobWVhc3VyZSkge1xuICAgIGlmICh6d3NwU3VwcG9ydGVkID09IG51bGwpIHtcbiAgICAgIHZhciB0ZXN0ID0gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIik7XG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBlbHQoXCJzcGFuXCIsIFt0ZXN0LCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIildKSk7XG4gICAgICBpZiAobWVhc3VyZS5maXJzdENoaWxkLm9mZnNldEhlaWdodCAhPSAwKVxuICAgICAgICB6d3NwU3VwcG9ydGVkID0gdGVzdC5vZmZzZXRXaWR0aCA8PSAxICYmIHRlc3Qub2Zmc2V0SGVpZ2h0ID4gMiAmJiAhKGllICYmIGllX3ZlcnNpb24gPCA4KTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxuICAgICAgZWx0KFwic3BhblwiLCBcIlxcdTAwYTBcIiwgbnVsbCwgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBGZWF0dXJlLWRldGVjdCBJRSdzIGNydW1teSBjbGllbnQgcmVjdCByZXBvcnRpbmcgZm9yIGJpZGkgdGV4dFxuICB2YXIgYmFkQmlkaVJlY3RzO1xuICBmdW5jdGlvbiBoYXNCYWRCaWRpUmVjdHMobWVhc3VyZSkge1xuICAgIGlmIChiYWRCaWRpUmVjdHMgIT0gbnVsbCkgcmV0dXJuIGJhZEJpZGlSZWN0cztcbiAgICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJBXFx1MDYyZUFcIikpO1xuICAgIHZhciByMCA9IHJhbmdlKHR4dCwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSByZXR1cm4gZmFsc2U7IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXG4gICAgdmFyIHIxID0gcmFuZ2UodHh0LCAxLCAyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gYmFkQmlkaVJlY3RzID0gKHIxLnJpZ2h0IC0gcjAucmlnaHQgPCAzKTtcbiAgfVxuXG4gIC8vIFNlZSBpZiBcIlwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cbiAgLy8gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwbGl0IGxpbmVzLlxuICB2YXIgc3BsaXRMaW5lcyA9IENvZGVNaXJyb3Iuc3BsaXRMaW5lcyA9IFwiXFxuXFxuYlwiLnNwbGl0KC9cXG4vKS5sZW5ndGggIT0gMyA/IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XG4gICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgaWYgKG5sID09IC0xKSBubCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcIlxcclwiID8gbmwgLSAxIDogbmwpO1xuICAgICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFwiXFxyXCIpO1xuICAgICAgaWYgKHJ0ICE9IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcbiAgICAgICAgcG9zICs9IHJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBwb3MgPSBubCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gOiBmdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcuc3BsaXQoL1xcclxcbj98XFxuLyk7fTtcblxuICB2YXIgaGFzU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IGZ1bmN0aW9uKHRlKSB7XG4gICAgdHJ5IHsgcmV0dXJuIHRlLnNlbGVjdGlvblN0YXJ0ICE9IHRlLnNlbGVjdGlvbkVuZDsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH0gOiBmdW5jdGlvbih0ZSkge1xuICAgIHRyeSB7dmFyIHJhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTt9XG4gICAgY2F0Y2goZSkge31cbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCByYW5nZSkgIT0gMDtcbiAgfTtcblxuICB2YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xuICAgIGlmIChcIm9uY29weVwiIGluIGUpIHJldHVybiB0cnVlO1xuICAgIGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFwiZnVuY3Rpb25cIjtcbiAgfSkoKTtcblxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICBmdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHJldHVybiBiYWRab29tZWRSZWN0cztcbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcbiAgICB2YXIgbm9ybWFsID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxO1xuICB9XG5cbiAgLy8gS0VZIE5BTUVTXG5cbiAgdmFyIGtleU5hbWVzID0gezM6IFwiRW50ZXJcIiwgODogXCJCYWNrc3BhY2VcIiwgOTogXCJUYWJcIiwgMTM6IFwiRW50ZXJcIiwgMTY6IFwiU2hpZnRcIiwgMTc6IFwiQ3RybFwiLCAxODogXCJBbHRcIixcbiAgICAgICAgICAgICAgICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXG4gICAgICAgICAgICAgICAgICAzNjogXCJIb21lXCIsIDM3OiBcIkxlZnRcIiwgMzg6IFwiVXBcIiwgMzk6IFwiUmlnaHRcIiwgNDA6IFwiRG93blwiLCA0NDogXCJQcmludFNjcm5cIiwgNDU6IFwiSW5zZXJ0XCIsXG4gICAgICAgICAgICAgICAgICA0NjogXCJEZWxldGVcIiwgNTk6IFwiO1wiLCA2MTogXCI9XCIsIDkxOiBcIk1vZFwiLCA5MjogXCJNb2RcIiwgOTM6IFwiTW9kXCIsIDEwNzogXCI9XCIsIDEwOTogXCItXCIsIDEyNzogXCJEZWxldGVcIixcbiAgICAgICAgICAgICAgICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXG4gICAgICAgICAgICAgICAgICAyMjE6IFwiXVwiLCAyMjI6IFwiJ1wiLCA2MzIzMjogXCJVcFwiLCA2MzIzMzogXCJEb3duXCIsIDYzMjM0OiBcIkxlZnRcIiwgNjMyMzU6IFwiUmlnaHRcIiwgNjMyNzI6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICA2MzI3MzogXCJIb21lXCIsIDYzMjc1OiBcIkVuZFwiLCA2MzI3NjogXCJQYWdlVXBcIiwgNjMyNzc6IFwiUGFnZURvd25cIiwgNjMzMDI6IFwiSW5zZXJ0XCJ9O1xuICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXM7XG4gIChmdW5jdGlvbigpIHtcbiAgICAvLyBOdW1iZXIga2V5c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7XG4gICAgLy8gQWxwaGFiZXRpYyBrZXlzXG4gICAgZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIGtleU5hbWVzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAvLyBGdW5jdGlvbiBrZXlzXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTI7IGkrKykga2V5TmFtZXNbaSArIDExMV0gPSBrZXlOYW1lc1tpICsgNjMyMzVdID0gXCJGXCIgKyBpO1xuICB9KSgpO1xuXG4gIC8vIEJJREkgSEVMUEVSU1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb20sIHRvLCBmKSB7XG4gICAgaWYgKCFvcmRlcikgcmV0dXJuIGYoZnJvbSwgdG8sIFwibHRyXCIpO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICBpZiAocGFydC5mcm9tIDwgdG8gJiYgcGFydC50byA+IGZyb20gfHwgZnJvbSA9PSB0byAmJiBwYXJ0LnRvID09IGZyb20pIHtcbiAgICAgICAgZihNYXRoLm1heChwYXJ0LmZyb20sIGZyb20pLCBNYXRoLm1pbihwYXJ0LnRvLCB0byksIHBhcnQubGV2ZWwgPT0gMSA/IFwicnRsXCIgOiBcImx0clwiKTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBmKGZyb20sIHRvLCBcImx0clwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZGlMZWZ0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC50byA6IHBhcnQuZnJvbTsgfVxuICBmdW5jdGlvbiBiaWRpUmlnaHQocGFydCkgeyByZXR1cm4gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvOyB9XG5cbiAgZnVuY3Rpb24gbGluZUxlZnQobGluZSkgeyB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTsgcmV0dXJuIG9yZGVyID8gYmlkaUxlZnQob3JkZXJbMF0pIDogMDsgfVxuICBmdW5jdGlvbiBsaW5lUmlnaHQobGluZSkge1xuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpO1xuICAgIGlmICghb3JkZXIpIHJldHVybiBsaW5lLnRleHQubGVuZ3RoO1xuICAgIHJldHVybiBiaWRpUmlnaHQobHN0KG9yZGVyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgbGluZU4gPSBsaW5lTm8odmlzdWFsKTtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcih2aXN1YWwpO1xuICAgIHZhciBjaCA9ICFvcmRlciA/IDAgOiBvcmRlclswXS5sZXZlbCAlIDIgPyBsaW5lUmlnaHQodmlzdWFsKSA6IGxpbmVMZWZ0KHZpc3VhbCk7XG4gICAgcmV0dXJuIFBvcyhsaW5lTiwgY2gpO1xuICB9XG4gIGZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XG4gICAgdmFyIG1lcmdlZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7XG4gICAgICBsaW5lTiA9IG51bGw7XG4gICAgfVxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpO1xuICAgIHZhciBjaCA9ICFvcmRlciA/IGxpbmUudGV4dC5sZW5ndGggOiBvcmRlclswXS5sZXZlbCAlIDIgPyBsaW5lTGVmdChsaW5lKSA6IGxpbmVSaWdodChsaW5lKTtcbiAgICByZXR1cm4gUG9zKGxpbmVOID09IG51bGwgPyBsaW5lTm8obGluZSkgOiBsaW5lTiwgY2gpO1xuICB9XG4gIGZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKTtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTtcbiAgICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcbiAgICAgIHZhciBmaXJzdE5vbldTID0gTWF0aC5tYXgoMCwgbGluZS50ZXh0LnNlYXJjaCgvXFxTLykpO1xuICAgICAgdmFyIGluV1MgPSBwb3MubGluZSA9PSBzdGFydC5saW5lICYmIHBvcy5jaCA8PSBmaXJzdE5vbldTICYmIHBvcy5jaDtcbiAgICAgIHJldHVybiBQb3Moc3RhcnQubGluZSwgaW5XUyA/IDAgOiBmaXJzdE5vbldTKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUJpZGlMZXZlbChvcmRlciwgYSwgYikge1xuICAgIHZhciBsaW5lZGlyID0gb3JkZXJbMF0ubGV2ZWw7XG4gICAgaWYgKGEgPT0gbGluZWRpcikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGIgPT0gbGluZWRpcikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhIDwgYjtcbiAgfVxuICB2YXIgYmlkaU90aGVyO1xuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MpIHtcbiAgICBiaWRpT3RoZXIgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwLCBmb3VuZDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY3VyID0gb3JkZXJbaV07XG4gICAgICBpZiAoY3VyLmZyb20gPCBwb3MgJiYgY3VyLnRvID4gcG9zKSByZXR1cm4gaTtcbiAgICAgIGlmICgoY3VyLmZyb20gPT0gcG9zIHx8IGN1ci50byA9PSBwb3MpKSB7XG4gICAgICAgIGlmIChmb3VuZCA9PSBudWxsKSB7XG4gICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsIGN1ci5sZXZlbCwgb3JkZXJbZm91bmRdLmxldmVsKSkge1xuICAgICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIGJpZGlPdGhlciA9IGZvdW5kO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIGJpZGlPdGhlciA9IGk7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVJbkxpbmUobGluZSwgcG9zLCBkaXIsIGJ5VW5pdCkge1xuICAgIGlmICghYnlVbml0KSByZXR1cm4gcG9zICsgZGlyO1xuICAgIGRvIHBvcyArPSBkaXI7XG4gICAgd2hpbGUgKHBvcyA+IDAgJiYgaXNFeHRlbmRpbmdDaGFyKGxpbmUudGV4dC5jaGFyQXQocG9zKSkpO1xuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICAvLyBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBtb3ZlICd2aXN1YWxseScgdGhyb3VnaCBiaS1kaXJlY3Rpb25hbFxuICAvLyB0ZXh0IC0tIGkuZS4sIHByZXNzaW5nIGxlZnQgc2hvdWxkIG1ha2UgdGhlIGN1cnNvciBnbyBsZWZ0LCBldmVuXG4gIC8vIHdoZW4gaW4gUlRMIHRleHQuIFRoZSB0cmlja3kgcGFydCBpcyB0aGUgJ2p1bXBzJywgd2hlcmUgUlRMIGFuZFxuICAvLyBMVFIgdGV4dCB0b3VjaCBlYWNoIG90aGVyLiBUaGlzIG9mdGVuIHJlcXVpcmVzIHRoZSBjdXJzb3Igb2Zmc2V0XG4gIC8vIHRvIG1vdmUgbW9yZSB0aGFuIG9uZSB1bml0LCBpbiBvcmRlciB0byB2aXN1YWxseSBtb3ZlIG9uZSB1bml0LlxuICBmdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB7XG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lKTtcbiAgICBpZiAoIWJpZGkpIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCk7XG4gICAgdmFyIHBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQpLCBwYXJ0ID0gYmlkaVtwb3NdO1xuICAgIHZhciB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHN0YXJ0LCBwYXJ0LmxldmVsICUgMiA/IC1kaXIgOiBkaXIsIGJ5VW5pdCk7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGFyZ2V0ID4gcGFydC5mcm9tICYmIHRhcmdldCA8IHBhcnQudG8pIHJldHVybiB0YXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0ID09IHBhcnQuZnJvbSB8fCB0YXJnZXQgPT0gcGFydC50bykge1xuICAgICAgICBpZiAoZ2V0QmlkaVBhcnRBdChiaWRpLCB0YXJnZXQpID09IHBvcykgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgcGFydCA9IGJpZGlbcG9zICs9IGRpcl07XG4gICAgICAgIHJldHVybiAoZGlyID4gMCkgPT0gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LnRvIDogcGFydC5mcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGJpZGlbcG9zICs9IGRpcl07XG4gICAgICAgIGlmICghcGFydCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICgoZGlyID4gMCkgPT0gcGFydC5sZXZlbCAlIDIpXG4gICAgICAgICAgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBwYXJ0LnRvLCAtMSwgYnlVbml0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRhcmdldCA9IG1vdmVJbkxpbmUobGluZSwgcGFydC5mcm9tLCAxLCBieVVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB7XG4gICAgdmFyIHRhcmdldCA9IHN0YXJ0ICsgZGlyO1xuICAgIGlmIChieVVuaXQpIHdoaWxlICh0YXJnZXQgPiAwICYmIGlzRXh0ZW5kaW5nQ2hhcihsaW5lLnRleHQuY2hhckF0KHRhcmdldCkpKSB0YXJnZXQgKz0gZGlyO1xuICAgIHJldHVybiB0YXJnZXQgPCAwIHx8IHRhcmdldCA+IGxpbmUudGV4dC5sZW5ndGggPyBudWxsIDogdGFyZ2V0O1xuICB9XG5cbiAgLy8gQmlkaXJlY3Rpb25hbCBvcmRlcmluZyBhbGdvcml0aG1cbiAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxuICAvLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cblxuICAvLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XG4gIC8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcbiAgLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxuICAvLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xuICAvLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcbiAgLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxuICAvLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxuICAvLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXG4gIC8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXG4gIC8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcbiAgLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxuICAvLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gIC8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXG4gIC8vIHcgKFdTKTogIFdoaXRlc3BhY2VcbiAgLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcblxuICAvLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxuICAvLyAobGVmdC10by1yaWdodCksIG9yIGFuIGFycmF5IG9mIHNlY3Rpb25zICh7ZnJvbSwgdG8sIGxldmVsfVxuICAvLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cbiAgdmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXG4gICAgdmFyIGxvd1R5cGVzID0gXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiO1xuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmZlxuICAgIHZhciBhcmFiaWNUeXBlcyA9IFwicnJycnJycnJycnJyLHJOTm1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1ycnJycnJybm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1ObW1tbVwiO1xuICAgIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSk7XG4gICAgICBlbHNlIGlmICgweDU5MCA8PSBjb2RlICYmIGNvZGUgPD0gMHg1ZjQpIHJldHVybiBcIlJcIjtcbiAgICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZlZCkgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApO1xuICAgICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSByZXR1cm4gXCJyXCI7XG4gICAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgcmV0dXJuIFwid1wiO1xuICAgICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHJldHVybiBcImJcIjtcbiAgICAgIGVsc2UgcmV0dXJuIFwiTFwiO1xuICAgIH1cblxuICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuICAgIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS87XG4gICAgLy8gQnJvd3NlcnMgc2VlbSB0byBhbHdheXMgdHJlYXQgdGhlIGJvdW5kYXJpZXMgb2YgYmxvY2sgZWxlbWVudHMgYXMgYmVpbmcgTC5cbiAgICB2YXIgb3V0ZXJUeXBlID0gXCJMXCI7XG5cbiAgICBmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoIWJpZGlSRS50ZXN0KHN0cikpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHR5cGU7IGkgPCBsZW47ICsraSlcbiAgICAgICAgdHlwZXMucHVzaCh0eXBlID0gY2hhclR5cGUoc3RyLmNoYXJDb2RlQXQoaSkpKTtcblxuICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlID09IFwibVwiKSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgIGVsc2UgcHJldiA9IHR5cGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgIC8vIG51bWJlci5cbiAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlID09IFwiMVwiICYmIGN1ciA9PSBcInJcIikgdHlwZXNbaV0gPSBcIm5cIjtcbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlKSkgeyBjdXIgPSB0eXBlOyBpZiAodHlwZSA9PSBcInJcIikgdHlwZXNbaV0gPSBcIlJcIjsgfVxuICAgICAgfVxuXG4gICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcbiAgICAgIC8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBwcmV2ID0gdHlwZXNbMF07IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCIrXCIgJiYgcHJldiA9PSBcIjFcIiAmJiB0eXBlc1tpKzFdID09IFwiMVwiKSB0eXBlc1tpXSA9IFwiMVwiO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiLFwiICYmIHByZXYgPT0gdHlwZXNbaSsxXSAmJlxuICAgICAgICAgICAgICAgICAocHJldiA9PSBcIjFcIiB8fCBwcmV2ID09IFwiblwiKSkgdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgLy8gTmV1dHJhbC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCIsXCIpIHR5cGVzW2ldID0gXCJOXCI7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCIlXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBlbmQgPSBpICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIlXCI7ICsrZW5kKSB7fVxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkgJiYgdHlwZXNbaS0xXSA9PSBcIiFcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiMVwiKSA/IFwiMVwiIDogXCJOXCI7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBlbmQ7ICsraikgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmIChjdXIgPT0gXCJMXCIgJiYgdHlwZSA9PSBcIjFcIikgdHlwZXNbaV0gPSBcIkxcIjtcbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlKSkgY3VyID0gdHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXG4gICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cbiAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChpc05ldXRyYWwudGVzdCh0eXBlc1tpXSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBlbmQgPSBpICsgMTsgZW5kIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZF0pOyArK2VuZCkge31cbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkgPyB0eXBlc1tpLTFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSAoZW5kIDwgbGVuID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIHJlcGxhY2UgPSBiZWZvcmUgfHwgYWZ0ZXIgPyBcIkxcIiA6IFwiUlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZW5kOyArK2opIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIZXJlIHdlIGRlcGFydCBmcm9tIHRoZSBkb2N1bWVudGVkIGFsZ29yaXRobSwgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgICAvLyBsZXZlbHMgKDAsIDEsIDIpIGluIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lc24ndCB0YWtlXG4gICAgICAvLyBleHBsaWNpdCBlbWJlZGRpbmcgaW50byBhY2NvdW50LCB3ZSBjYW4gYnVpbGQgdXAgdGhlIG9yZGVyIG9uXG4gICAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxuICAgICAgdmFyIG9yZGVyID0gW10sIG07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2ldKSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IGk7XG4gICAgICAgICAgZm9yICgrK2k7IGkgPCBsZW4gJiYgY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaV0pOyArK2kpIHt9XG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9zID0gaSwgYXQgPSBvcmRlci5sZW5ndGg7XG4gICAgICAgICAgZm9yICgrK2k7IGkgPCBsZW4gJiYgdHlwZXNbaV0gIT0gXCJMXCI7ICsraSkge31cbiAgICAgICAgICBmb3IgKHZhciBqID0gcG9zOyBqIDwgaTspIHtcbiAgICAgICAgICAgIGlmIChjb3VudHNBc051bS50ZXN0KHR5cGVzW2pdKSkge1xuICAgICAgICAgICAgICBpZiAocG9zIDwgaikgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBqKSk7XG4gICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqO1xuICAgICAgICAgICAgICBmb3IgKCsrajsgaiA8IGkgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqXSk7ICsraikge31cbiAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqKSk7XG4gICAgICAgICAgICAgIHBvcyA9IGo7XG4gICAgICAgICAgICB9IGVsc2UgKytqO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zIDwgaSkgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICBvcmRlclswXS5mcm9tID0gbVswXS5sZW5ndGg7XG4gICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDAsIDAsIG1bMF0ubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBpZiAobHN0KG9yZGVyKS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9cXHMrJC8pKSkge1xuICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xuICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgPT0gMilcbiAgICAgICAgb3JkZXIudW5zaGlmdChuZXcgQmlkaVNwYW4oMSwgb3JkZXJbMF0udG8sIG9yZGVyWzBdLnRvKSk7XG4gICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgIT0gbHN0KG9yZGVyKS5sZXZlbClcbiAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4ob3JkZXJbMF0ubGV2ZWwsIGxlbiwgbGVuKSk7XG5cbiAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIFRIRSBFTkRcblxuICBDb2RlTWlycm9yLnZlcnNpb24gPSBcIjUuNC4wXCI7XG5cbiAgcmV0dXJuIENvZGVNaXJyb3I7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gVE9ETyBhY3R1YWxseSByZWNvZ25pemUgc3ludGF4IG9mIFR5cGVTY3JpcHQgY29uc3RydWN0c1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImphdmFzY3JpcHRcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcbiAgdmFyIHN0YXRlbWVudEluZGVudCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnQ7XG4gIHZhciBqc29ubGRNb2RlID0gcGFyc2VyQ29uZmlnLmpzb25sZDtcbiAgdmFyIGpzb25Nb2RlID0gcGFyc2VyQ29uZmlnLmpzb24gfHwganNvbmxkTW9kZTtcbiAgdmFyIGlzVFMgPSBwYXJzZXJDb25maWcudHlwZXNjcmlwdDtcbiAgdmFyIHdvcmRSRSA9IHBhcnNlckNvbmZpZy53b3JkQ2hhcmFjdGVycyB8fCAvW1xcdyRcXHhhMS1cXHVmZmZmXS87XG5cbiAgLy8gVG9rZW5pemVyXG5cbiAgdmFyIGtleXdvcmRzID0gZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbiAgICB2YXIgQSA9IGt3KFwia2V5d29yZCBhXCIpLCBCID0ga3coXCJrZXl3b3JkIGJcIiksIEMgPSBrdyhcImtleXdvcmQgY1wiKTtcbiAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9O1xuXG4gICAgdmFyIGpzS2V5d29yZHMgPSB7XG4gICAgICBcImlmXCI6IGt3KFwiaWZcIiksIFwid2hpbGVcIjogQSwgXCJ3aXRoXCI6IEEsIFwiZWxzZVwiOiBCLCBcImRvXCI6IEIsIFwidHJ5XCI6IEIsIFwiZmluYWxseVwiOiBCLFxuICAgICAgXCJyZXR1cm5cIjogQywgXCJicmVha1wiOiBDLCBcImNvbnRpbnVlXCI6IEMsIFwibmV3XCI6IEMsIFwiZGVsZXRlXCI6IEMsIFwidGhyb3dcIjogQywgXCJkZWJ1Z2dlclwiOiBDLFxuICAgICAgXCJ2YXJcIjoga3coXCJ2YXJcIiksIFwiY29uc3RcIjoga3coXCJ2YXJcIiksIFwibGV0XCI6IGt3KFwidmFyXCIpLFxuICAgICAgXCJmdW5jdGlvblwiOiBrdyhcImZ1bmN0aW9uXCIpLCBcImNhdGNoXCI6IGt3KFwiY2F0Y2hcIiksXG4gICAgICBcImZvclwiOiBrdyhcImZvclwiKSwgXCJzd2l0Y2hcIjoga3coXCJzd2l0Y2hcIiksIFwiY2FzZVwiOiBrdyhcImNhc2VcIiksIFwiZGVmYXVsdFwiOiBrdyhcImRlZmF1bHRcIiksXG4gICAgICBcImluXCI6IG9wZXJhdG9yLCBcInR5cGVvZlwiOiBvcGVyYXRvciwgXCJpbnN0YW5jZW9mXCI6IG9wZXJhdG9yLFxuICAgICAgXCJ0cnVlXCI6IGF0b20sIFwiZmFsc2VcIjogYXRvbSwgXCJudWxsXCI6IGF0b20sIFwidW5kZWZpbmVkXCI6IGF0b20sIFwiTmFOXCI6IGF0b20sIFwiSW5maW5pdHlcIjogYXRvbSxcbiAgICAgIFwidGhpc1wiOiBrdyhcInRoaXNcIiksIFwibW9kdWxlXCI6IGt3KFwibW9kdWxlXCIpLCBcImNsYXNzXCI6IGt3KFwiY2xhc3NcIiksIFwic3VwZXJcIjoga3coXCJhdG9tXCIpLFxuICAgICAgXCJ5aWVsZFwiOiBDLCBcImV4cG9ydFwiOiBrdyhcImV4cG9ydFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwiZXh0ZW5kc1wiOiBDXG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCB0aGUgJ25vcm1hbCcga2V5d29yZHMgd2l0aCB0aGUgVHlwZVNjcmlwdCBsYW5ndWFnZSBleHRlbnNpb25zXG4gICAgaWYgKGlzVFMpIHtcbiAgICAgIHZhciB0eXBlID0ge3R5cGU6IFwidmFyaWFibGVcIiwgc3R5bGU6IFwidmFyaWFibGUtM1wifTtcbiAgICAgIHZhciB0c0tleXdvcmRzID0ge1xuICAgICAgICAvLyBvYmplY3QtbGlrZSB0aGluZ3NcbiAgICAgICAgXCJpbnRlcmZhY2VcIjoga3coXCJpbnRlcmZhY2VcIiksXG4gICAgICAgIFwiZXh0ZW5kc1wiOiBrdyhcImV4dGVuZHNcIiksXG4gICAgICAgIFwiY29uc3RydWN0b3JcIjoga3coXCJjb25zdHJ1Y3RvclwiKSxcblxuICAgICAgICAvLyBzY29wZSBtb2RpZmllcnNcbiAgICAgICAgXCJwdWJsaWNcIjoga3coXCJwdWJsaWNcIiksXG4gICAgICAgIFwicHJpdmF0ZVwiOiBrdyhcInByaXZhdGVcIiksXG4gICAgICAgIFwicHJvdGVjdGVkXCI6IGt3KFwicHJvdGVjdGVkXCIpLFxuICAgICAgICBcInN0YXRpY1wiOiBrdyhcInN0YXRpY1wiKSxcblxuICAgICAgICAvLyB0eXBlc1xuICAgICAgICBcInN0cmluZ1wiOiB0eXBlLCBcIm51bWJlclwiOiB0eXBlLCBcImJvb2xcIjogdHlwZSwgXCJhbnlcIjogdHlwZVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgYXR0ciBpbiB0c0tleXdvcmRzKSB7XG4gICAgICAgIGpzS2V5d29yZHNbYXR0cl0gPSB0c0tleXdvcmRzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqc0tleXdvcmRzO1xuICB9KCk7XG5cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT98fl5dLztcbiAgdmFyIGlzSnNvbmxkS2V5d29yZCA9IC9eQChjb250ZXh0fGlkfHZhbHVlfGxhbmd1YWdlfHR5cGV8Y29udGFpbmVyfGxpc3R8c2V0fHJldmVyc2V8aW5kZXh8YmFzZXx2b2NhYnxncmFwaClcIi87XG5cbiAgZnVuY3Rpb24gcmVhZFJlZ2V4cChzdHJlYW0pIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBpblNldCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICBpZiAobmV4dCA9PSBcIi9cIiAmJiAhaW5TZXQpIHJldHVybjtcbiAgICAgICAgaWYgKG5leHQgPT0gXCJbXCIpIGluU2V0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoaW5TZXQgJiYgbmV4dCA9PSBcIl1cIikgaW5TZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgYXMgc2NyYXRjaCB2YXJpYWJsZXMgdG8gY29tbXVuaWNhdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGhvdXRcbiAgLy8gY29uc2luZyB1cCB0b25zIG9mIG9iamVjdHMuXG4gIHZhciB0eXBlLCBjb250ZW50O1xuICBmdW5jdGlvbiByZXQodHAsIHN0eWxlLCBjb250KSB7XG4gICAgdHlwZSA9IHRwOyBjb250ZW50ID0gY29udDtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiLlwiICYmIHN0cmVhbS5tYXRjaCgvXlxcZCsoPzpbZUVdWytcXC1dP1xcZCspPy8pKSB7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKFwiLi5cIikpIHtcbiAgICAgIHJldHVybiByZXQoXCJzcHJlYWRcIiwgXCJtZXRhXCIpO1xuICAgIH0gZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiByZXQoY2gpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHJldHVybiByZXQoXCI9PlwiLCBcIm9wZXJhdG9yXCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIgJiYgc3RyZWFtLmVhdCgveC9pKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkYS1mXS9pKTtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eXFxkKig/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/Lyk7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxhc3RUeXBlID09IFwib3BlcmF0b3JcIiB8fCBzdGF0ZS5sYXN0VHlwZSA9PSBcImtleXdvcmQgY1wiIHx8XG4gICAgICAgICAgICAgICBzdGF0ZS5sYXN0VHlwZSA9PSBcInNvZlwiIHx8IC9eW1xcW3t9XFwoLDs6XSQvLnRlc3Qoc3RhdGUubGFzdFR5cGUpKSB7XG4gICAgICAgIHJlYWRSZWdleHAoc3RyZWFtKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eXFxiKChbZ2lteXVdKSg/IVtnaW15dV0qXFwyKSkrXFxiLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBcIm9wZXJhdG9yXCIsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJgXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5RdWFzaTtcbiAgICAgIHJldHVybiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJlcnJvclwiLCBcImVycm9yXCIpO1xuICAgIH0gZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9IGVsc2UgaWYgKHdvcmRSRS50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKHdvcmRSRSk7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG4gICAgICByZXR1cm4gKGtub3duICYmIHN0YXRlLmxhc3RUeXBlICE9IFwiLlwiKSA/IHJldChrbm93bi50eXBlLCBrbm93bi5zdHlsZSwgd29yZCkgOlxuICAgICAgICAgICAgICAgICAgICAgcmV0KFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB3b3JkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICAgICAgaWYgKGpzb25sZE1vZGUgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIkBcIiAmJiBzdHJlYW0ubWF0Y2goaXNKc29ubGRLZXl3b3JkKSl7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICByZXR1cm4gcmV0KFwianNvbmxkLWtleXdvcmRcIiwgXCJtZXRhXCIpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkgYnJlYWs7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuUXVhc2koc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkICYmIChuZXh0ID09IFwiYFwiIHx8IG5leHQgPT0gXCIkXCIgJiYgc3RyZWFtLmVhdChcIntcIikpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwicXVhc2lcIiwgXCJzdHJpbmctMlwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgfVxuXG4gIHZhciBicmFja2V0cyA9IFwiKFt7fV0pXCI7XG4gIC8vIFRoaXMgaXMgYSBjcnVkZSBsb29rYWhlYWQgdHJpY2sgdG8gdHJ5IGFuZCBub3RpY2UgdGhhdCB3ZSdyZVxuICAvLyBwYXJzaW5nIHRoZSBhcmd1bWVudCBwYXR0ZXJucyBmb3IgYSBmYXQtYXJyb3cgZnVuY3Rpb24gYmVmb3JlIHdlXG4gIC8vIGFjdHVhbGx5IGhpdCB0aGUgYXJyb3cgdG9rZW4uIEl0IG9ubHkgd29ya3MgaWYgdGhlIGFycm93IGlzIG9uXG4gIC8vIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGFyZ3VtZW50cyBhbmQgdGhlcmUncyBubyBzdHJhbmdlIG5vaXNlXG4gIC8vIChjb21tZW50cykgaW4gYmV0d2Vlbi4gRmFsbGJhY2sgaXMgdG8gb25seSBub3RpY2Ugd2hlbiB3ZSBoaXQgdGhlXG4gIC8vIGFycm93LCBhbmQgbm90IGRlY2xhcmUgdGhlIGFyZ3VtZW50cyBhcyBsb2NhbHMgZm9yIHRoZSBhcnJvd1xuICAvLyBib2R5LlxuICBmdW5jdGlvbiBmaW5kRmF0QXJyb3coc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5mYXRBcnJvd0F0KSBzdGF0ZS5mYXRBcnJvd0F0ID0gbnVsbDtcbiAgICB2YXIgYXJyb3cgPSBzdHJlYW0uc3RyaW5nLmluZGV4T2YoXCI9PlwiLCBzdHJlYW0uc3RhcnQpO1xuICAgIGlmIChhcnJvdyA8IDApIHJldHVybjtcblxuICAgIHZhciBkZXB0aCA9IDAsIHNhd1NvbWV0aGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBvcyA9IGFycm93IC0gMTsgcG9zID49IDA7IC0tcG9zKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgdmFyIGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKGNoKTtcbiAgICAgIGlmIChicmFja2V0ID49IDAgJiYgYnJhY2tldCA8IDMpIHtcbiAgICAgICAgaWYgKCFkZXB0aCkgeyArK3BvczsgYnJlYWs7IH1cbiAgICAgICAgaWYgKC0tZGVwdGggPT0gMCkgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXQgPj0gMyAmJiBicmFja2V0IDwgNikge1xuICAgICAgICArK2RlcHRoO1xuICAgICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgICAgc2F3U29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoL1tcIidcXC9dLy50ZXN0KGNoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHNhd1NvbWV0aGluZyAmJiAhZGVwdGgpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2F3U29tZXRoaW5nICYmICFkZXB0aCkgc3RhdGUuZmF0QXJyb3dBdCA9IHBvcztcbiAgfVxuXG4gIC8vIFBhcnNlclxuXG4gIHZhciBhdG9taWNUeXBlcyA9IHtcImF0b21cIjogdHJ1ZSwgXCJudW1iZXJcIjogdHJ1ZSwgXCJ2YXJpYWJsZVwiOiB0cnVlLCBcInN0cmluZ1wiOiB0cnVlLCBcInJlZ2V4cFwiOiB0cnVlLCBcInRoaXNcIjogdHJ1ZSwgXCJqc29ubGQta2V5d29yZFwiOiB0cnVlfTtcblxuICBmdW5jdGlvbiBKU0xleGljYWwoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYsIGluZm8pIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgaWYgKGFsaWduICE9IG51bGwpIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluU2NvcGUoc3RhdGUsIHZhcm5hbWUpIHtcbiAgICBmb3IgKHZhciB2ID0gc3RhdGUubG9jYWxWYXJzOyB2OyB2ID0gdi5uZXh0KVxuICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKHZhciBjeCA9IHN0YXRlLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnByZXYpIHtcbiAgICAgIGZvciAodmFyIHYgPSBjeC52YXJzOyB2OyB2ID0gdi5uZXh0KVxuICAgICAgICBpZiAodi5uYW1lID09IHZhcm5hbWUpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSlMoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pIHtcbiAgICB2YXIgY2MgPSBzdGF0ZS5jYztcbiAgICAvLyBDb21tdW5pY2F0ZSBvdXIgY29udGV4dCB0byB0aGUgY29tYmluYXRvcnMuXG4gICAgLy8gKExlc3Mgd2FzdGVmdWwgdGhhbiBjb25zaW5nIHVwIGEgaHVuZHJlZCBjbG9zdXJlcyBvbiBldmVyeSBjYWxsLilcbiAgICBjeC5zdGF0ZSA9IHN0YXRlOyBjeC5zdHJlYW0gPSBzdHJlYW07IGN4Lm1hcmtlZCA9IG51bGwsIGN4LmNjID0gY2M7IGN4LnN0eWxlID0gc3R5bGU7XG5cbiAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgIHN0YXRlLmxleGljYWwuYWxpZ24gPSB0cnVlO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IGpzb25Nb2RlID8gZXhwcmVzc2lvbiA6IHN0YXRlbWVudDtcbiAgICAgIGlmIChjb21iaW5hdG9yKHR5cGUsIGNvbnRlbnQpKSB7XG4gICAgICAgIHdoaWxlKGNjLmxlbmd0aCAmJiBjY1tjYy5sZW5ndGggLSAxXS5sZXgpXG4gICAgICAgICAgY2MucG9wKCkoKTtcbiAgICAgICAgaWYgKGN4Lm1hcmtlZCkgcmV0dXJuIGN4Lm1hcmtlZDtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGluU2NvcGUoc3RhdGUsIGNvbnRlbnQpKSByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21iaW5hdG9yIHV0aWxzXG5cbiAgdmFyIGN4ID0ge3N0YXRlOiBudWxsLCBjb2x1bW46IG51bGwsIG1hcmtlZDogbnVsbCwgY2M6IG51bGx9O1xuICBmdW5jdGlvbiBwYXNzKCkge1xuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgfVxuICBmdW5jdGlvbiBjb250KCkge1xuICAgIHBhc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgZnVuY3Rpb24gaW5MaXN0KGxpc3QpIHtcbiAgICAgIGZvciAodmFyIHYgPSBsaXN0OyB2OyB2ID0gdi5uZXh0KVxuICAgICAgICBpZiAodi5uYW1lID09IHZhcm5hbWUpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICAgIGlmIChpbkxpc3Qoc3RhdGUubG9jYWxWYXJzKSkgcmV0dXJuO1xuICAgICAgc3RhdGUubG9jYWxWYXJzID0ge25hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmxvY2FsVmFyc307XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbkxpc3Qoc3RhdGUuZ2xvYmFsVmFycykpIHJldHVybjtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZ2xvYmFsVmFycylcbiAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5nbG9iYWxWYXJzfTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21iaW5hdG9yc1xuXG4gIHZhciBkZWZhdWx0VmFycyA9IHtuYW1lOiBcInRoaXNcIiwgbmV4dDoge25hbWU6IFwiYXJndW1lbnRzXCJ9fTtcbiAgZnVuY3Rpb24gcHVzaGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUuY29udGV4dCA9IHtwcmV2OiBjeC5zdGF0ZS5jb250ZXh0LCB2YXJzOiBjeC5zdGF0ZS5sb2NhbFZhcnN9O1xuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGRlZmF1bHRWYXJzO1xuICB9XG4gIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzO1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBjeC5zdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaGxleCh0eXBlLCBpbmZvKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlID0gY3guc3RhdGUsIGluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcInN0YXRcIikgaW5kZW50ID0gc3RhdGUubGV4aWNhbC5pbmRlbnRlZDtcbiAgICAgIGVsc2UgZm9yICh2YXIgb3V0ZXIgPSBzdGF0ZS5sZXhpY2FsOyBvdXRlciAmJiBvdXRlci50eXBlID09IFwiKVwiICYmIG91dGVyLmFsaWduOyBvdXRlciA9IG91dGVyLnByZXYpXG4gICAgICAgIGluZGVudCA9IG91dGVyLmluZGVudGVkO1xuICAgICAgc3RhdGUubGV4aWNhbCA9IG5ldyBKU0xleGljYWwoaW5kZW50LCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUsIG51bGwsIHN0YXRlLmxleGljYWwsIGluZm8pO1xuICAgIH07XG4gICAgcmVzdWx0LmxleCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwb3BsZXgoKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgaWYgKHN0YXRlLmxleGljYWwucHJldikge1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcIilcIilcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgc3RhdGUubGV4aWNhbCA9IHN0YXRlLmxleGljYWwucHJldjtcbiAgICB9XG4gIH1cbiAgcG9wbGV4LmxleCA9IHRydWU7XG5cbiAgZnVuY3Rpb24gZXhwZWN0KHdhbnRlZCkge1xuICAgIGZ1bmN0aW9uIGV4cCh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSB3YW50ZWQpIHJldHVybiBjb250KCk7XG4gICAgICBlbHNlIGlmICh3YW50ZWQgPT0gXCI7XCIpIHJldHVybiBwYXNzKCk7XG4gICAgICBlbHNlIHJldHVybiBjb250KGV4cCk7XG4gICAgfTtcbiAgICByZXR1cm4gZXhwO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVtZW50KHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInZhcmRlZlwiLCB2YWx1ZS5sZW5ndGgpLCB2YXJkZWYsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGFcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgYmxvY2ssIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpZlwiKSB7XG4gICAgICBpZiAoY3guc3RhdGUubGV4aWNhbC5pbmZvID09IFwiZWxzZVwiICYmIGN4LnN0YXRlLmNjW2N4LnN0YXRlLmNjLmxlbmd0aCAtIDFdID09IHBvcGxleClcbiAgICAgICAgY3guc3RhdGUuY2MucG9wKCkoKTtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleCwgbWF5YmVlbHNlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgaWYgKHR5cGUgPT0gXCJmb3JcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGZvcnNwZWMsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWxhYmVsKTtcbiAgICBpZiAodHlwZSA9PSBcInN3aXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgcHVzaGxleChcIn1cIiwgXCJzd2l0Y2hcIiksIGV4cGVjdChcIntcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLCBwb3BsZXgsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJjYXNlXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiZGVmYXVsdFwiKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcImNhdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgZXhwZWN0KFwiKFwiKSwgZnVuYXJnLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcIm1vZHVsZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGNvbnRleHQsIGFmdGVyTW9kdWxlLCBwb3Bjb250ZXh0LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiY2xhc3NcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGNsYXNzTmFtZSwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImV4cG9ydFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgYWZ0ZXJFeHBvcnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpbXBvcnRcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGFmdGVySW1wb3J0LCBwb3BsZXgpO1xuICAgIHJldHVybiBwYXNzKHB1c2hsZXgoXCJzdGF0XCIpLCBleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGV4cHJlc3Npb24odHlwZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25Ob0NvbW1hKHR5cGUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25Jbm5lcih0eXBlLCBub0NvbW1hKSB7XG4gICAgaWYgKGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0KSB7XG4gICAgICB2YXIgYm9keSA9IG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5O1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAocGF0dGVybiwgXCIpXCIpLCBwb3BsZXgsIGV4cGVjdChcIj0+XCIpLCBib2R5LCBwb3Bjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gcGFzcyhwdXNoY29udGV4dCwgcGF0dGVybiwgZXhwZWN0KFwiPT5cIiksIGJvZHksIHBvcGNvbnRleHQpO1xuICAgIH1cblxuICAgIHZhciBtYXliZW9wID0gbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hO1xuICAgIGlmIChhdG9taWNUeXBlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGNvbnQobWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZiwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGNcIikgcmV0dXJuIGNvbnQobm9Db21tYSA/IG1heWJlZXhwcmVzc2lvbk5vQ29tbWEgOiBtYXliZWV4cHJlc3Npb24pO1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgbWF5YmVleHByZXNzaW9uLCBjb21wcmVoZW5zaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgsIG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiB8fCB0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KG5vQ29tbWEgPyBleHByZXNzaW9uTm9Db21tYSA6IGV4cHJlc3Npb24pO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgYXJyYXlMaXRlcmFsLCBwb3BsZXgsIG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udENvbW1hc2VwKG9ianByb3AsIFwifVwiLCBudWxsLCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcInF1YXNpXCIpIHsgcmV0dXJuIHBhc3MocXVhc2ksIG1heWJlb3ApOyB9XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZWV4cHJlc3Npb24odHlwZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uTm9Db21tYSh0eXBlKSB7XG4gICAgaWYgKHR5cGUubWF0Y2goL1s7XFx9XFwpXFxdLF0vKSkgcmV0dXJuIHBhc3MoKTtcbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uTm9Db21tYSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZW9wZXJhdG9yQ29tbWEodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZSwgdmFsdWUsIG5vQ29tbWEpIHtcbiAgICB2YXIgbWUgPSBub0NvbW1hID09IGZhbHNlID8gbWF5YmVvcGVyYXRvckNvbW1hIDogbWF5YmVvcGVyYXRvck5vQ29tbWE7XG4gICAgdmFyIGV4cHIgPSBub0NvbW1hID09IGZhbHNlID8gZXhwcmVzc2lvbiA6IGV4cHJlc3Npb25Ob0NvbW1hO1xuICAgIGlmICh0eXBlID09IFwiPT5cIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgIGlmICgvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGNvbnQobWUpO1xuICAgICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpLCBleHByKTtcbiAgICAgIHJldHVybiBjb250KGV4cHIpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInF1YXNpXCIpIHsgcmV0dXJuIHBhc3MocXVhc2ksIG1lKTsgfVxuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250Q29tbWFzZXAoZXhwcmVzc2lvbk5vQ29tbWEsIFwiKVwiLCBcImNhbGxcIiwgbWUpO1xuICAgIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChwcm9wZXJ0eSwgbWUpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCJdXCIpLCBwb3BsZXgsIG1lKTtcbiAgfVxuICBmdW5jdGlvbiBxdWFzaSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlICE9IFwicXVhc2lcIikgcmV0dXJuIHBhc3MoKTtcbiAgICBpZiAodmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gMikgIT0gXCIke1wiKSByZXR1cm4gY29udChxdWFzaSk7XG4gICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY29udGludWVRdWFzaSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udGludWVRdWFzaSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwic3RyaW5nLTJcIjtcbiAgICAgIGN4LnN0YXRlLnRva2VuaXplID0gdG9rZW5RdWFzaTtcbiAgICAgIHJldHVybiBjb250KHF1YXNpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJyb3dCb2R5KHR5cGUpIHtcbiAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgcmV0dXJuIHBhc3ModHlwZSA9PSBcIntcIiA/IHN0YXRlbWVudCA6IGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIGFycm93Qm9keU5vQ29tbWEodHlwZSkge1xuICAgIGZpbmRGYXRBcnJvdyhjeC5zdHJlYW0sIGN4LnN0YXRlKTtcbiAgICByZXR1cm4gcGFzcyh0eXBlID09IFwie1wiID8gc3RhdGVtZW50IDogZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gICAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvckNvbW1hLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BlcnR5KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7IHJldHVybiBjb250KCk7fVxuICB9XG4gIGZ1bmN0aW9uIG9ianByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PSBcImdldFwiIHx8IHZhbHVlID09IFwic2V0XCIpIHJldHVybiBjb250KGdldHRlclNldHRlcik7XG4gICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY3gubWFya2VkID0ganNvbmxkTW9kZSA/IFwicHJvcGVydHlcIiA6IChjeC5zdHlsZSArIFwiIHByb3BlcnR5XCIpO1xuICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJqc29ubGQta2V5d29yZFwiKSB7XG4gICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgYWZ0ZXJwcm9wKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0dGVyU2V0dGVyKHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKGFmdGVycHJvcCk7XG4gICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlcnByb3AodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSk7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwYXNzKGZ1bmN0aW9uZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBjb21tYXNlcCh3aGF0LCBlbmQpIHtcbiAgICBmdW5jdGlvbiBwcm9jZWVkKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiLFwiKSB7XG4gICAgICAgIHZhciBsZXggPSBjeC5zdGF0ZS5sZXhpY2FsO1xuICAgICAgICBpZiAobGV4LmluZm8gPT0gXCJjYWxsXCIpIGxleC5wb3MgPSAobGV4LnBvcyB8fCAwKSArIDE7XG4gICAgICAgIHJldHVybiBjb250KHdoYXQsIHByb2NlZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIHBhc3Mod2hhdCwgcHJvY2VlZCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb250Q29tbWFzZXAod2hhdCwgZW5kLCBpbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgcmV0dXJuIGNvbnQocHVzaGxleChlbmQsIGluZm8pLCBjb21tYXNlcCh3aGF0LCBlbmQpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGJsb2NrKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZXR5cGUodHlwZSkge1xuICAgIGlmIChpc1RTICYmIHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVkZWYpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZGVmYXVsdChfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIHR5cGVkZWYodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge2N4Lm1hcmtlZCA9IFwidmFyaWFibGUtM1wiOyByZXR1cm4gY29udCgpO31cbiAgfVxuICBmdW5jdGlvbiB2YXJkZWYoKSB7XG4gICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmV0eXBlLCBtYXliZUFzc2lnbiwgdmFyZGVmQ29udCk7XG4gIH1cbiAgZnVuY3Rpb24gcGF0dGVybih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgeyByZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnRDb21tYXNlcChwYXR0ZXJuLCBcIl1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAocHJvcHBhdHRlcm4sIFwifVwiKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wcGF0dGVybih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiAhY3guc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpIHtcbiAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250KG1heWJlQXNzaWduKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwiOlwiKSwgcGF0dGVybiwgbWF5YmVBc3NpZ24pO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlQXNzaWduKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIHZhcmRlZkNvbnQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZWxzZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIgJiYgdmFsdWUgPT0gXCJlbHNlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIFwiZWxzZVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWModHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgZm9yc3BlYzEsIGV4cGVjdChcIilcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yc3BlYzEodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHZhcmRlZiwgZXhwZWN0KFwiO1wiKSwgZm9yc3BlYzIpO1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udChmb3JzcGVjMik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChmb3JtYXliZWlub2YpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIGZvcnNwZWMyKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXliZWlub2YoX3R5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiaW5cIiB8fCB2YWx1ZSA9PSBcIm9mXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24pOyB9XG4gICAgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvckNvbW1hLCBmb3JzcGVjMik7XG4gIH1cbiAgZnVuY3Rpb24gZm9yc3BlYzIodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoZm9yc3BlYzMpO1xuICAgIGlmICh2YWx1ZSA9PSBcImluXCIgfHwgdmFsdWUgPT0gXCJvZlwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChleHByZXNzaW9uKTsgfVxuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIGZvcnNwZWMzKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjMyh0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCIpXCIpIGNvbnQoZXhwcmVzc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gZnVuY3Rpb25kZWYodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO31cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAoZnVuYXJnLCBcIilcIiksIHBvcGxleCwgc3RhdGVtZW50LCBwb3Bjb250ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBmdW5hcmcodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KGZ1bmFyZyk7XG4gICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmV0eXBlLCBtYXliZWRlZmF1bHQpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzTmFtZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoY2xhc3NOYW1lQWZ0ZXIpO31cbiAgfVxuICBmdW5jdGlvbiBjbGFzc05hbWVBZnRlcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImV4dGVuZHNcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY2xhc3NOYW1lQWZ0ZXIpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY2xhc3NCb2R5LCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzQm9keSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiB8fCBjeC5zdHlsZSA9PSBcImtleXdvcmRcIikge1xuICAgICAgaWYgKHZhbHVlID09IFwic3RhdGljXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgICB9XG4gICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICBpZiAodmFsdWUgPT0gXCJnZXRcIiB8fCB2YWx1ZSA9PSBcInNldFwiKSByZXR1cm4gY29udChjbGFzc0dldHRlclNldHRlciwgZnVuY3Rpb25kZWYsIGNsYXNzQm9keSk7XG4gICAgICByZXR1cm4gY29udChmdW5jdGlvbmRlZiwgY2xhc3NCb2R5KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzR2V0dGVyU2V0dGVyKHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKCk7XG4gICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJNb2R1bGUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChzdGF0ZW1lbnQpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgeyByZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KG1heWJlRnJvbSk7IH1cbiAgfVxuICBmdW5jdGlvbiBhZnRlckV4cG9ydChfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7IH1cbiAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIikpOyB9XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckltcG9ydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhpbXBvcnRTcGVjLCBtYXliZUZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFNwZWModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChpbXBvcnRTcGVjLCBcIn1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZWdpc3Rlcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICByZXR1cm4gY29udChtYXliZUFzKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFzKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImFzXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGltcG9ydFNwZWMpOyB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVGcm9tKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImZyb21cIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7IH1cbiAgfVxuICBmdW5jdGlvbiBhcnJheUxpdGVyYWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiXVwiKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb25Ob0NvbW1hLCBtYXliZUFycmF5Q29tcHJlaGVuc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVBcnJheUNvbXByZWhlbnNpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBwYXNzKGNvbXByZWhlbnNpb24sIGV4cGVjdChcIl1cIikpO1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udChjb21tYXNlcChtYXliZWV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICAgIHJldHVybiBwYXNzKGNvbW1hc2VwKGV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXByZWhlbnNpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBjb250KGZvcnNwZWMsIGNvbXByZWhlbnNpb24pO1xuICAgIGlmICh0eXBlID09IFwiaWZcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY29tcHJlaGVuc2lvbik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbnRpbnVlZFN0YXRlbWVudChzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RUeXBlID09IFwib3BlcmF0b3JcIiB8fCBzdGF0ZS5sYXN0VHlwZSA9PSBcIixcIiB8fFxuICAgICAgaXNPcGVyYXRvckNoYXIudGVzdCh0ZXh0QWZ0ZXIuY2hhckF0KDApKSB8fFxuICAgICAgL1ssLl0vLnRlc3QodGV4dEFmdGVyLmNoYXJBdCgwKSk7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgbGFzdFR5cGU6IFwic29mXCIsXG4gICAgICAgIGNjOiBbXSxcbiAgICAgICAgbGV4aWNhbDogbmV3IEpTTGV4aWNhbCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgICBsb2NhbFZhcnM6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMsXG4gICAgICAgIGNvbnRleHQ6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMgJiYge3ZhcnM6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnN9LFxuICAgICAgICBpbmRlbnRlZDogMFxuICAgICAgfTtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZ2xvYmFsVmFycyAmJiB0eXBlb2YgcGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkNvbW1lbnQgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgc3RhdGUubGFzdFR5cGUgPSB0eXBlID09IFwib3BlcmF0b3JcIiAmJiAoY29udGVudCA9PSBcIisrXCIgfHwgY29udGVudCA9PSBcIi0tXCIpID8gXCJpbmNkZWNcIiA6IHR5cGU7XG4gICAgICByZXR1cm4gcGFyc2VKUyhzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplID09IHRva2VuQ29tbWVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbDtcbiAgICAgIC8vIEtsdWRnZSB0byBwcmV2ZW50ICdtYXliZWxzZScgZnJvbSBibG9ja2luZyBsZXhpY2FsIHNjb3BlIHBvcHNcbiAgICAgIGlmICghL15cXHMqZWxzZVxcYi8udGVzdCh0ZXh0QWZ0ZXIpKSBmb3IgKHZhciBpID0gc3RhdGUuY2MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGMgPSBzdGF0ZS5jY1tpXTtcbiAgICAgICAgaWYgKGMgPT0gcG9wbGV4KSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICBlbHNlIGlmIChjICE9IG1heWJlZWxzZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobGV4aWNhbC50eXBlID09IFwic3RhdFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgIGlmIChzdGF0ZW1lbnRJbmRlbnQgJiYgbGV4aWNhbC50eXBlID09IFwiKVwiICYmIGxleGljYWwucHJldi50eXBlID09IFwic3RhdFwiKVxuICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTtcblxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiID8gbGV4aWNhbC5pbmZvICsgMSA6IDApO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIiAmJiBmaXJzdENoYXIgPT0gXCJ7XCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInN0YXRcIilcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikgPyBzdGF0ZW1lbnRJbmRlbnQgfHwgaW5kZW50VW5pdCA6IDApO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5pbmZvID09IFwic3dpdGNoXCIgJiYgIWNsb3NpbmcgJiYgcGFyc2VyQ29uZmlnLmRvdWJsZUluZGVudFN3aXRjaCAhPSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikgPyBpbmRlbnRVbml0IDogMiAqIGluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5hbGlnbikgcmV0dXJuIGxleGljYWwuY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHt8XFx9KSQvLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBqc29uTW9kZSA/IG51bGwgOiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBqc29uTW9kZSA/IG51bGwgOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiLy9cIixcbiAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgY2xvc2VCcmFja2V0czogXCIoKVtde30nJ1xcXCJcXFwiYGBcIixcblxuICAgIGhlbHBlclR5cGU6IGpzb25Nb2RlID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIixcbiAgICBqc29ubGRNb2RlOiBqc29ubGRNb2RlLFxuICAgIGpzb25Nb2RlOiBqc29uTW9kZVxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJ3b3JkQ2hhcnNcIiwgXCJqYXZhc2NyaXB0XCIsIC9bXFx3JF0vKTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9qYXZhc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvZWNtYXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2pzb25cIiwge25hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29uOiB0cnVlfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWpzb25cIiwge25hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29uOiB0cnVlfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIsIHtuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbmxkOiB0cnVlfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3R5cGVzY3JpcHRcIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwgdHlwZXNjcmlwdDogdHJ1ZSB9KTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3R5cGVzY3JpcHRcIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwgdHlwZXNjcmlwdDogdHJ1ZSB9KTtcblxufSk7XG4iLCIvLyAgICAga2V5bWFzdGVyLmpzXG4vLyAgICAgKGMpIDIwMTEtMjAxMyBUaG9tYXMgRnVjaHNcbi8vICAgICBrZXltYXN0ZXIuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbjsoZnVuY3Rpb24oZ2xvYmFsKXtcbiAgdmFyIGssXG4gICAgX2hhbmRsZXJzID0ge30sXG4gICAgX21vZHMgPSB7IDE2OiBmYWxzZSwgMTg6IGZhbHNlLCAxNzogZmFsc2UsIDkxOiBmYWxzZSB9LFxuICAgIF9zY29wZSA9ICdhbGwnLFxuICAgIC8vIG1vZGlmaWVyIGtleXNcbiAgICBfTU9ESUZJRVJTID0ge1xuICAgICAgJ+KHpyc6IDE2LCBzaGlmdDogMTYsXG4gICAgICAn4oylJzogMTgsIGFsdDogMTgsIG9wdGlvbjogMTgsXG4gICAgICAn4oyDJzogMTcsIGN0cmw6IDE3LCBjb250cm9sOiAxNyxcbiAgICAgICfijJgnOiA5MSwgY29tbWFuZDogOTFcbiAgICB9LFxuICAgIC8vIHNwZWNpYWwga2V5c1xuICAgIF9NQVAgPSB7XG4gICAgICBiYWNrc3BhY2U6IDgsIHRhYjogOSwgY2xlYXI6IDEyLFxuICAgICAgZW50ZXI6IDEzLCAncmV0dXJuJzogMTMsXG4gICAgICBlc2M6IDI3LCBlc2NhcGU6IDI3LCBzcGFjZTogMzIsXG4gICAgICBsZWZ0OiAzNywgdXA6IDM4LFxuICAgICAgcmlnaHQ6IDM5LCBkb3duOiA0MCxcbiAgICAgIGRlbDogNDYsICdkZWxldGUnOiA0NixcbiAgICAgIGhvbWU6IDM2LCBlbmQ6IDM1LFxuICAgICAgcGFnZXVwOiAzMywgcGFnZWRvd246IDM0LFxuICAgICAgJywnOiAxODgsICcuJzogMTkwLCAnLyc6IDE5MSxcbiAgICAgICdgJzogMTkyLCAnLSc6IDE4OSwgJz0nOiAxODcsXG4gICAgICAnOyc6IDE4NiwgJ1xcJyc6IDIyMixcbiAgICAgICdbJzogMjE5LCAnXSc6IDIyMSwgJ1xcXFwnOiAyMjBcbiAgICB9LFxuICAgIGNvZGUgPSBmdW5jdGlvbih4KXtcbiAgICAgIHJldHVybiBfTUFQW3hdIHx8IHgudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgIH0sXG4gICAgX2Rvd25LZXlzID0gW107XG5cbiAgZm9yKGs9MTtrPDIwO2srKykgX01BUFsnZicra10gPSAxMTEraztcblxuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgQXJyYXkjaW5kZXhPZiwgc28gaGF2ZSBhIHNpbXBsZSByZXBsYWNlbWVudFxuICBmdW5jdGlvbiBpbmRleChhcnJheSwgaXRlbSl7XG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKSBpZihhcnJheVtpXT09PWl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIGZvciBjb21wYXJpbmcgbW9kcyBiZWZvcmUgdW5hc3NpZ25tZW50XG4gIGZ1bmN0aW9uIGNvbXBhcmVBcnJheShhMSwgYTIpIHtcbiAgICBpZiAoYTEubGVuZ3RoICE9IGEyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGExW2ldICE9PSBhMltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtb2RpZmllck1hcCA9IHtcbiAgICAgIDE2OidzaGlmdEtleScsXG4gICAgICAxODonYWx0S2V5JyxcbiAgICAgIDE3OidjdHJsS2V5JyxcbiAgICAgIDkxOidtZXRhS2V5J1xuICB9O1xuICBmdW5jdGlvbiB1cGRhdGVNb2RpZmllcktleShldmVudCkge1xuICAgICAgZm9yKGsgaW4gX21vZHMpIF9tb2RzW2tdID0gZXZlbnRbbW9kaWZpZXJNYXBba11dO1xuICB9O1xuXG4gIC8vIGhhbmRsZSBrZXlkb3duIGV2ZW50XG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgdmFyIGtleSwgaGFuZGxlciwgaywgaSwgbW9kaWZpZXJzTWF0Y2gsIHNjb3BlO1xuICAgIGtleSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgICBpZiAoaW5kZXgoX2Rvd25LZXlzLCBrZXkpID09IC0xKSB7XG4gICAgICAgIF9kb3duS2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgLy8gaWYgYSBtb2RpZmllciBrZXksIHNldCB0aGUga2V5Ljxtb2RpZmllcmtleW5hbWU+IHByb3BlcnR5IHRvIHRydWUgYW5kIHJldHVyblxuICAgIGlmKGtleSA9PSA5MyB8fCBrZXkgPT0gMjI0KSBrZXkgPSA5MTsgLy8gcmlnaHQgY29tbWFuZCBvbiB3ZWJraXQsIGNvbW1hbmQgb24gR2Vja29cbiAgICBpZihrZXkgaW4gX21vZHMpIHtcbiAgICAgIF9tb2RzW2tleV0gPSB0cnVlO1xuICAgICAgLy8gJ2Fzc2lnbktleScgZnJvbSBpbnNpZGUgdGhpcyBjbG9zdXJlIGlzIGV4cG9ydGVkIHRvIHdpbmRvdy5rZXlcbiAgICAgIGZvcihrIGluIF9NT0RJRklFUlMpIGlmKF9NT0RJRklFUlNba10gPT0ga2V5KSBhc3NpZ25LZXlba10gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVNb2RpZmllcktleShldmVudCk7XG5cbiAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBpZ25vcmUgdGhlIGtleXByZXNzIChmaWx0ZXIoKSBjYW4gY2FuIGJlIG92ZXJyaWRkZW4pXG4gICAgLy8gYnkgZGVmYXVsdCBpZ25vcmUga2V5IHByZXNzZXMgaWYgYSBzZWxlY3QsIHRleHRhcmVhLCBvciBpbnB1dCBpcyBmb2N1c2VkXG4gICAgaWYoIWFzc2lnbktleS5maWx0ZXIuY2FsbCh0aGlzLCBldmVudCkpIHJldHVybjtcblxuICAgIC8vIGFib3J0IGlmIG5vIHBvdGVudGlhbGx5IG1hdGNoaW5nIHNob3J0Y3V0cyBmb3VuZFxuICAgIGlmICghKGtleSBpbiBfaGFuZGxlcnMpKSByZXR1cm47XG5cbiAgICBzY29wZSA9IGdldFNjb3BlKCk7XG5cbiAgICAvLyBmb3IgZWFjaCBwb3RlbnRpYWwgc2hvcnRjdXRcbiAgICBmb3IgKGkgPSAwOyBpIDwgX2hhbmRsZXJzW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXIgPSBfaGFuZGxlcnNba2V5XVtpXTtcblxuICAgICAgLy8gc2VlIGlmIGl0J3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICAgIGlmKGhhbmRsZXIuc2NvcGUgPT0gc2NvcGUgfHwgaGFuZGxlci5zY29wZSA9PSAnYWxsJyl7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vZGlmaWVycyBtYXRjaCBpZiBhbnlcbiAgICAgICAgbW9kaWZpZXJzTWF0Y2ggPSBoYW5kbGVyLm1vZHMubGVuZ3RoID4gMDtcbiAgICAgICAgZm9yKGsgaW4gX21vZHMpXG4gICAgICAgICAgaWYoKCFfbW9kc1trXSAmJiBpbmRleChoYW5kbGVyLm1vZHMsICtrKSA+IC0xKSB8fFxuICAgICAgICAgICAgKF9tb2RzW2tdICYmIGluZGV4KGhhbmRsZXIubW9kcywgK2spID09IC0xKSkgbW9kaWZpZXJzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbCB0aGUgaGFuZGxlciBhbmQgc3RvcCB0aGUgZXZlbnQgaWYgbmVjY2Vzc2FyeVxuICAgICAgICBpZigoaGFuZGxlci5tb2RzLmxlbmd0aCA9PSAwICYmICFfbW9kc1sxNl0gJiYgIV9tb2RzWzE4XSAmJiAhX21vZHNbMTddICYmICFfbW9kc1s5MV0pIHx8IG1vZGlmaWVyc01hdGNoKXtcbiAgICAgICAgICBpZihoYW5kbGVyLm1ldGhvZChldmVudCwgaGFuZGxlcik9PT1mYWxzZSl7XG4gICAgICAgICAgICBpZihldmVudC5wcmV2ZW50RGVmYXVsdCkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZWxzZSBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmKGV2ZW50LmNhbmNlbEJ1YmJsZSkgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gdW5zZXQgbW9kaWZpZXIga2V5cyBvbiBrZXl1cFxuICBmdW5jdGlvbiBjbGVhck1vZGlmaWVyKGV2ZW50KXtcbiAgICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZSwgayxcbiAgICAgICAgaSA9IGluZGV4KF9kb3duS2V5cywga2V5KTtcblxuICAgIC8vIHJlbW92ZSBrZXkgZnJvbSBfZG93bktleXNcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIF9kb3duS2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgaWYoa2V5ID09IDkzIHx8IGtleSA9PSAyMjQpIGtleSA9IDkxO1xuICAgIGlmKGtleSBpbiBfbW9kcykge1xuICAgICAgX21vZHNba2V5XSA9IGZhbHNlO1xuICAgICAgZm9yKGsgaW4gX01PRElGSUVSUykgaWYoX01PRElGSUVSU1trXSA9PSBrZXkpIGFzc2lnbktleVtrXSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZXNldE1vZGlmaWVycygpIHtcbiAgICBmb3IoayBpbiBfbW9kcykgX21vZHNba10gPSBmYWxzZTtcbiAgICBmb3IoayBpbiBfTU9ESUZJRVJTKSBhc3NpZ25LZXlba10gPSBmYWxzZTtcbiAgfTtcblxuICAvLyBwYXJzZSBhbmQgYXNzaWduIHNob3J0Y3V0XG4gIGZ1bmN0aW9uIGFzc2lnbktleShrZXksIHNjb3BlLCBtZXRob2Qpe1xuICAgIHZhciBrZXlzLCBtb2RzO1xuICAgIGtleXMgPSBnZXRLZXlzKGtleSk7XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXRob2QgPSBzY29wZTtcbiAgICAgIHNjb3BlID0gJ2FsbCc7XG4gICAgfVxuXG4gICAgLy8gZm9yIGVhY2ggc2hvcnRjdXRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHNldCBtb2RpZmllciBrZXlzIGlmIGFueVxuICAgICAgbW9kcyA9IFtdO1xuICAgICAga2V5ID0ga2V5c1tpXS5zcGxpdCgnKycpO1xuICAgICAgaWYgKGtleS5sZW5ndGggPiAxKXtcbiAgICAgICAgbW9kcyA9IGdldE1vZHMoa2V5KTtcbiAgICAgICAga2V5ID0gW2tleVtrZXkubGVuZ3RoLTFdXTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgdG8ga2V5Y29kZSBhbmQuLi5cbiAgICAgIGtleSA9IGtleVswXVxuICAgICAga2V5ID0gY29kZShrZXkpO1xuICAgICAgLy8gLi4uc3RvcmUgaGFuZGxlclxuICAgICAgaWYgKCEoa2V5IGluIF9oYW5kbGVycykpIF9oYW5kbGVyc1trZXldID0gW107XG4gICAgICBfaGFuZGxlcnNba2V5XS5wdXNoKHsgc2hvcnRjdXQ6IGtleXNbaV0sIHNjb3BlOiBzY29wZSwgbWV0aG9kOiBtZXRob2QsIGtleToga2V5c1tpXSwgbW9kczogbW9kcyB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdW5iaW5kIGFsbCBoYW5kbGVycyBmb3IgZ2l2ZW4ga2V5IGluIGN1cnJlbnQgc2NvcGVcbiAgZnVuY3Rpb24gdW5iaW5kS2V5KGtleSwgc2NvcGUpIHtcbiAgICB2YXIgbXVsdGlwbGVLZXlzLCBrZXlzLFxuICAgICAgbW9kcyA9IFtdLFxuICAgICAgaSwgaiwgb2JqO1xuXG4gICAgbXVsdGlwbGVLZXlzID0gZ2V0S2V5cyhrZXkpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IG11bHRpcGxlS2V5cy5sZW5ndGg7IGorKykge1xuICAgICAga2V5cyA9IG11bHRpcGxlS2V5c1tqXS5zcGxpdCgnKycpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1vZHMgPSBnZXRNb2RzKGtleXMpO1xuICAgICAgICBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGNvZGUoa2V5KTtcblxuICAgICAgaWYgKHNjb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2NvcGUgPSBnZXRTY29wZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFfaGFuZGxlcnNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgX2hhbmRsZXJzW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JqID0gX2hhbmRsZXJzW2tleV1baV07XG4gICAgICAgIC8vIG9ubHkgY2xlYXIgaGFuZGxlcnMgaWYgY29ycmVjdCBzY29wZSBhbmQgbW9kcyBtYXRjaFxuICAgICAgICBpZiAob2JqLnNjb3BlID09PSBzY29wZSAmJiBjb21wYXJlQXJyYXkob2JqLm1vZHMsIG1vZHMpKSB7XG4gICAgICAgICAgX2hhbmRsZXJzW2tleV1baV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSB3aXRoIGNvZGUgJ2tleUNvZGUnIGlzIGN1cnJlbnRseSBkb3duXG4gIC8vIENvbnZlcnRzIHN0cmluZ3MgaW50byBrZXkgY29kZXMuXG4gIGZ1bmN0aW9uIGlzUHJlc3NlZChrZXlDb2RlKSB7XG4gICAgICBpZiAodHlwZW9mKGtleUNvZGUpPT0nc3RyaW5nJykge1xuICAgICAgICBrZXlDb2RlID0gY29kZShrZXlDb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleChfZG93bktleXMsIGtleUNvZGUpICE9IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlc3NlZEtleUNvZGVzKCkge1xuICAgICAgcmV0dXJuIF9kb3duS2V5cy5zbGljZSgwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlcihldmVudCl7XG4gICAgdmFyIHRhZ05hbWUgPSAoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQpLnRhZ05hbWU7XG4gICAgLy8gaWdub3JlIGtleXByZXNzZWQgaW4gYW55IGVsZW1lbnRzIHRoYXQgc3VwcG9ydCBrZXlib2FyZCBkYXRhIGlucHV0XG4gICAgcmV0dXJuICEodGFnTmFtZSA9PSAnSU5QVVQnIHx8IHRhZ05hbWUgPT0gJ1NFTEVDVCcgfHwgdGFnTmFtZSA9PSAnVEVYVEFSRUEnKTtcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUga2V5Ljxtb2RpZmllcj4gdG8gZmFsc2VcbiAgZm9yKGsgaW4gX01PRElGSUVSUykgYXNzaWduS2V5W2tdID0gZmFsc2U7XG5cbiAgLy8gc2V0IGN1cnJlbnQgc2NvcGUgKGRlZmF1bHQgJ2FsbCcpXG4gIGZ1bmN0aW9uIHNldFNjb3BlKHNjb3BlKXsgX3Njb3BlID0gc2NvcGUgfHwgJ2FsbCcgfTtcbiAgZnVuY3Rpb24gZ2V0U2NvcGUoKXsgcmV0dXJuIF9zY29wZSB8fCAnYWxsJyB9O1xuXG4gIC8vIGRlbGV0ZSBhbGwgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gc2NvcGVcbiAgZnVuY3Rpb24gZGVsZXRlU2NvcGUoc2NvcGUpe1xuICAgIHZhciBrZXksIGhhbmRsZXJzLCBpO1xuXG4gICAgZm9yIChrZXkgaW4gX2hhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVycyA9IF9oYW5kbGVyc1trZXldO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKSB7XG4gICAgICAgIGlmIChoYW5kbGVyc1tpXS5zY29wZSA9PT0gc2NvcGUpIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZWxzZSBpKys7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGFic3RyYWN0IGtleSBsb2dpYyBmb3IgYXNzaWduIGFuZCB1bmFzc2lnblxuICBmdW5jdGlvbiBnZXRLZXlzKGtleSkge1xuICAgIHZhciBrZXlzO1xuICAgIGtleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGtleXMgPSBrZXkuc3BsaXQoJywnKTtcbiAgICBpZiAoKGtleXNba2V5cy5sZW5ndGggLSAxXSkgPT0gJycpIHtcbiAgICAgIGtleXNba2V5cy5sZW5ndGggLSAyXSArPSAnLCc7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLy8gYWJzdHJhY3QgbW9kcyBsb2dpYyBmb3IgYXNzaWduIGFuZCB1bmFzc2lnblxuICBmdW5jdGlvbiBnZXRNb2RzKGtleSkge1xuICAgIHZhciBtb2RzID0ga2V5LnNsaWNlKDAsIGtleS5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBtaSA9IDA7IG1pIDwgbW9kcy5sZW5ndGg7IG1pKyspXG4gICAgbW9kc1ttaV0gPSBfTU9ESUZJRVJTW21vZHNbbWldXTtcbiAgICByZXR1cm4gbW9kcztcbiAgfVxuXG4gIC8vIGNyb3NzLWJyb3dzZXIgZXZlbnRzXG4gIGZ1bmN0aW9uIGFkZEV2ZW50KG9iamVjdCwgZXZlbnQsIG1ldGhvZCkge1xuICAgIGlmIChvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBtZXRob2QsIGZhbHNlKTtcbiAgICBlbHNlIGlmKG9iamVjdC5hdHRhY2hFdmVudClcbiAgICAgIG9iamVjdC5hdHRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpeyBtZXRob2Qod2luZG93LmV2ZW50KSB9KTtcbiAgfTtcblxuICAvLyBzZXQgdGhlIGhhbmRsZXJzIGdsb2JhbGx5IG9uIGRvY3VtZW50XG4gIGFkZEV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7IGRpc3BhdGNoKGV2ZW50KSB9KTsgLy8gUGFzc2luZyBfc2NvcGUgdG8gYSBjYWxsYmFjayB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBieSBleGVjdXRpb24uIEZpeGVzICM0OFxuICBhZGRFdmVudChkb2N1bWVudCwgJ2tleXVwJywgY2xlYXJNb2RpZmllcik7XG5cbiAgLy8gcmVzZXQgbW9kaWZpZXJzIHRvIGZhbHNlIHdoZW5ldmVyIHRoZSB3aW5kb3cgaXMgKHJlKWZvY3VzZWQuXG4gIGFkZEV2ZW50KHdpbmRvdywgJ2ZvY3VzJywgcmVzZXRNb2RpZmllcnMpO1xuXG4gIC8vIHN0b3JlIHByZXZpb3VzbHkgZGVmaW5lZCBrZXlcbiAgdmFyIHByZXZpb3VzS2V5ID0gZ2xvYmFsLmtleTtcblxuICAvLyByZXN0b3JlIHByZXZpb3VzbHkgZGVmaW5lZCBrZXkgYW5kIHJldHVybiByZWZlcmVuY2UgdG8gb3VyIGtleSBvYmplY3RcbiAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB2YXIgayA9IGdsb2JhbC5rZXk7XG4gICAgZ2xvYmFsLmtleSA9IHByZXZpb3VzS2V5O1xuICAgIHJldHVybiBrO1xuICB9XG5cbiAgLy8gc2V0IHdpbmRvdy5rZXkgYW5kIHdpbmRvdy5rZXkuc2V0L2dldC9kZWxldGVTY29wZSwgYW5kIHRoZSBkZWZhdWx0IGZpbHRlclxuICBnbG9iYWwua2V5ID0gYXNzaWduS2V5O1xuICBnbG9iYWwua2V5LnNldFNjb3BlID0gc2V0U2NvcGU7XG4gIGdsb2JhbC5rZXkuZ2V0U2NvcGUgPSBnZXRTY29wZTtcbiAgZ2xvYmFsLmtleS5kZWxldGVTY29wZSA9IGRlbGV0ZVNjb3BlO1xuICBnbG9iYWwua2V5LmZpbHRlciA9IGZpbHRlcjtcbiAgZ2xvYmFsLmtleS5pc1ByZXNzZWQgPSBpc1ByZXNzZWQ7XG4gIGdsb2JhbC5rZXkuZ2V0UHJlc3NlZEtleUNvZGVzID0gZ2V0UHJlc3NlZEtleUNvZGVzO1xuICBnbG9iYWwua2V5Lm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICBnbG9iYWwua2V5LnVuYmluZCA9IHVuYmluZEtleTtcblxuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25LZXk7XG5cbn0pKHRoaXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBudW1lcmljID0gKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiKT8oZnVuY3Rpb24gbnVtZXJpYygpIHt9KTooZXhwb3J0cyk7XG5pZih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7IGdsb2JhbC5udW1lcmljID0gbnVtZXJpYzsgfVxuXG5udW1lcmljLnZlcnNpb24gPSBcIjEuMi42XCI7XG5cbi8vIDEuIFV0aWxpdHkgZnVuY3Rpb25zXG5udW1lcmljLmJlbmNoID0gZnVuY3Rpb24gYmVuY2ggKGYsaW50ZXJ2YWwpIHtcbiAgICB2YXIgdDEsdDIsbixpO1xuICAgIGlmKHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJ1bmRlZmluZWRcIikgeyBpbnRlcnZhbCA9IDE1OyB9XG4gICAgbiA9IDAuNTtcbiAgICB0MSA9IG5ldyBEYXRlKCk7XG4gICAgd2hpbGUoMSkge1xuICAgICAgICBuKj0yO1xuICAgICAgICBmb3IoaT1uO2k+MztpLT00KSB7IGYoKTsgZigpOyBmKCk7IGYoKTsgfVxuICAgICAgICB3aGlsZShpPjApIHsgZigpOyBpLS07IH1cbiAgICAgICAgdDIgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZih0Mi10MSA+IGludGVydmFsKSBicmVhaztcbiAgICB9XG4gICAgZm9yKGk9bjtpPjM7aS09NCkgeyBmKCk7IGYoKTsgZigpOyBmKCk7IH1cbiAgICB3aGlsZShpPjApIHsgZigpOyBpLS07IH1cbiAgICB0MiA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIDEwMDAqKDMqbi0xKS8odDItdDEpO1xufVxuXG5udW1lcmljLl9teUluZGV4T2YgPSAoZnVuY3Rpb24gX215SW5kZXhPZih3KSB7XG4gICAgdmFyIG4gPSB0aGlzLmxlbmd0aCxrO1xuICAgIGZvcihrPTA7azxuOysraykgaWYodGhpc1trXT09PXcpIHJldHVybiBrO1xuICAgIHJldHVybiAtMTtcbn0pO1xubnVtZXJpYy5teUluZGV4T2YgPSAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpP0FycmF5LnByb3RvdHlwZS5pbmRleE9mOm51bWVyaWMuX215SW5kZXhPZjtcblxubnVtZXJpYy5GdW5jdGlvbiA9IEZ1bmN0aW9uO1xubnVtZXJpYy5wcmVjaXNpb24gPSA0O1xubnVtZXJpYy5sYXJnZUFycmF5ID0gNTA7XG5cbm51bWVyaWMucHJldHR5UHJpbnQgPSBmdW5jdGlvbiBwcmV0dHlQcmludCh4KSB7XG4gICAgZnVuY3Rpb24gZm10bnVtKHgpIHtcbiAgICAgICAgaWYoeCA9PT0gMCkgeyByZXR1cm4gJzAnOyB9XG4gICAgICAgIGlmKGlzTmFOKHgpKSB7IHJldHVybiAnTmFOJzsgfVxuICAgICAgICBpZih4PDApIHsgcmV0dXJuICctJytmbXRudW0oLXgpOyB9XG4gICAgICAgIGlmKGlzRmluaXRlKHgpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHgpIC8gTWF0aC5sb2coMTApKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0geCAvIE1hdGgucG93KDEwLHNjYWxlKTtcbiAgICAgICAgICAgIHZhciBiYXNpYyA9IG5vcm1hbGl6ZWQudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pO1xuICAgICAgICAgICAgaWYocGFyc2VGbG9hdChiYXNpYykgPT09IDEwKSB7IHNjYWxlKys7IG5vcm1hbGl6ZWQgPSAxOyBiYXNpYyA9IG5vcm1hbGl6ZWQudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pOyB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNpYykudG9TdHJpbmcoKSsnZScrc2NhbGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZ1bmN0aW9uIGZvbyh4KSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXQucHVzaChBcnJheShudW1lcmljLnByZWNpc2lvbis4KS5qb2luKCcgJykpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHsgcmV0LnB1c2goJ1wiJyt4KydcIicpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwiYm9vbGVhblwiKSB7IHJldC5wdXNoKHgudG9TdHJpbmcoKSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFyIGEgPSBmbXRudW0oeCk7XG4gICAgICAgICAgICB2YXIgYiA9IHgudG9QcmVjaXNpb24obnVtZXJpYy5wcmVjaXNpb24pO1xuICAgICAgICAgICAgdmFyIGMgPSBwYXJzZUZsb2F0KHgudG9TdHJpbmcoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBkID0gW2EsYixjLHBhcnNlRmxvYXQoYikudG9TdHJpbmcoKSxwYXJzZUZsb2F0KGMpLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgZm9yKGs9MTtrPGQubGVuZ3RoO2srKykgeyBpZihkW2tdLmxlbmd0aCA8IGEubGVuZ3RoKSBhID0gZFtrXTsgfVxuICAgICAgICAgICAgcmV0LnB1c2goQXJyYXkobnVtZXJpYy5wcmVjaXNpb24rOC1hLmxlbmd0aCkuam9pbignICcpK2EpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHggPT09IG51bGwpIHsgcmV0LnB1c2goXCJudWxsXCIpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYodHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikgeyBcbiAgICAgICAgICAgIHJldC5wdXNoKHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKGsgaW4geCkgeyBpZih4Lmhhc093blByb3BlcnR5KGspKSB7IFxuICAgICAgICAgICAgICAgIGlmKGZsYWcpIHJldC5wdXNoKCcsXFxuJyk7XG4gICAgICAgICAgICAgICAgZWxzZSByZXQucHVzaCgnXFxueycpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlOyBcbiAgICAgICAgICAgICAgICByZXQucHVzaChrKTsgXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goJzogXFxuJyk7IFxuICAgICAgICAgICAgICAgIGZvbyh4W2tdKTsgXG4gICAgICAgICAgICB9IH1cbiAgICAgICAgICAgIGlmKGZsYWcpIHJldC5wdXNoKCd9XFxuJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih4IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmKHgubGVuZ3RoID4gbnVtZXJpYy5sYXJnZUFycmF5KSB7IHJldC5wdXNoKCcuLi5MYXJnZSBBcnJheS4uLicpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldC5wdXNoKCdbJyk7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8eC5sZW5ndGg7aysrKSB7IGlmKGs+MCkgeyByZXQucHVzaCgnLCcpOyBpZihmbGFnKSByZXQucHVzaCgnXFxuICcpOyB9IGZsYWcgPSBmb28oeFtrXSk7IH1cbiAgICAgICAgICAgIHJldC5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXQucHVzaCgneycpO1xuICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IoayBpbiB4KSB7IGlmKHguaGFzT3duUHJvcGVydHkoaykpIHsgaWYoZmxhZykgcmV0LnB1c2goJyxcXG4nKTsgZmxhZyA9IHRydWU7IHJldC5wdXNoKGspOyByZXQucHVzaCgnOiBcXG4nKTsgZm9vKHhba10pOyB9IH1cbiAgICAgICAgcmV0LnB1c2goJ30nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvbyh4KTtcbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5udW1lcmljLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uIHBhcnNlRGF0ZShkKSB7XG4gICAgZnVuY3Rpb24gZm9vKGQpIHtcbiAgICAgICAgaWYodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBEYXRlLnBhcnNlKGQucmVwbGFjZSgvLS9nLCcvJykpOyB9XG4gICAgICAgIGlmKCEoZCBpbnN0YW5jZW9mIEFycmF5KSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZURhdGU6IHBhcmFtZXRlciBtdXN0IGJlIGFycmF5cyBvZiBzdHJpbmdzXCIpOyB9XG4gICAgICAgIHZhciByZXQgPSBbXSxrO1xuICAgICAgICBmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSB7IHJldFtrXSA9IGZvbyhkW2tdKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKGQpO1xufVxuXG5udW1lcmljLnBhcnNlRmxvYXQgPSBmdW5jdGlvbiBwYXJzZUZsb2F0XyhkKSB7XG4gICAgZnVuY3Rpb24gZm9vKGQpIHtcbiAgICAgICAgaWYodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBwYXJzZUZsb2F0KGQpOyB9XG4gICAgICAgIGlmKCEoZCBpbnN0YW5jZW9mIEFycmF5KSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZUZsb2F0OiBwYXJhbWV0ZXIgbXVzdCBiZSBhcnJheXMgb2Ygc3RyaW5nc1wiKTsgfVxuICAgICAgICB2YXIgcmV0ID0gW10saztcbiAgICAgICAgZm9yKGs9MDtrPGQubGVuZ3RoO2srKykgeyByZXRba10gPSBmb28oZFtrXSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyhkKTtcbn1cblxubnVtZXJpYy5wYXJzZUNTViA9IGZ1bmN0aW9uIHBhcnNlQ1NWKHQpIHtcbiAgICB2YXIgZm9vID0gdC5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIGosaztcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIHBhdCA9IC8oKFteJ1wiLF0qKXwoJ1teJ10qJyl8KFwiW15cIl0qXCIpKSwvZztcbiAgICB2YXIgcGF0bnVtID0gL15cXHMqKChbKy1dP1swLTldKyhcXC5bMC05XSopPyhlWystXT9bMC05XSspPyl8KFsrLV0/WzAtOV0qKFxcLlswLTldKyk/KGVbKy1dP1swLTldKyk/KSlcXHMqJC87XG4gICAgdmFyIHN0cmlwcGVyID0gZnVuY3Rpb24obikgeyByZXR1cm4gbi5zdWJzdHIoMCxuLmxlbmd0aC0xKTsgfVxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yKGs9MDtrPGZvby5sZW5ndGg7aysrKSB7XG4gICAgICB2YXIgYmFyID0gKGZvb1trXStcIixcIikubWF0Y2gocGF0KSxiYXo7XG4gICAgICBpZihiYXIubGVuZ3RoPjApIHtcbiAgICAgICAgICByZXRbY291bnRdID0gW107XG4gICAgICAgICAgZm9yKGo9MDtqPGJhci5sZW5ndGg7aisrKSB7XG4gICAgICAgICAgICAgIGJheiA9IHN0cmlwcGVyKGJhcltqXSk7XG4gICAgICAgICAgICAgIGlmKHBhdG51bS50ZXN0KGJheikpIHsgcmV0W2NvdW50XVtqXSA9IHBhcnNlRmxvYXQoYmF6KTsgfVxuICAgICAgICAgICAgICBlbHNlIHJldFtjb3VudF1bal0gPSBiYXo7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMudG9DU1YgPSBmdW5jdGlvbiB0b0NTVihBKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShBKTtcbiAgICB2YXIgaSxqLG0sbixyb3cscmV0O1xuICAgIG0gPSBzWzBdO1xuICAgIG4gPSBzWzFdO1xuICAgIHJldCA9IFtdO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqPG07aisrKSB7IHJvd1tqXSA9IEFbaV1bal0udG9TdHJpbmcoKTsgfVxuICAgICAgICByZXRbaV0gPSByb3cuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSsnXFxuJztcbn1cblxubnVtZXJpYy5nZXRVUkwgPSBmdW5jdGlvbiBnZXRVUkwodXJsKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNsaWVudC5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTtcbiAgICBjbGllbnQuc2VuZCgpO1xuICAgIHJldHVybiBjbGllbnQ7XG59XG5cbm51bWVyaWMuaW1hZ2VVUkwgPSBmdW5jdGlvbiBpbWFnZVVSTChpbWcpIHtcbiAgICBmdW5jdGlvbiBiYXNlNjQoQSkge1xuICAgICAgICB2YXIgbiA9IEEubGVuZ3RoLCBpLHgseSx6LHAscSxyLHM7XG4gICAgICAgIHZhciBrZXkgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IoaT0wO2k8bjtpKz0zKSB7XG4gICAgICAgICAgICB4ID0gQVtpXTtcbiAgICAgICAgICAgIHkgPSBBW2krMV07XG4gICAgICAgICAgICB6ID0gQVtpKzJdO1xuICAgICAgICAgICAgcCA9IHggPj4gMjtcbiAgICAgICAgICAgIHEgPSAoKHggJiAzKSA8PCA0KSArICh5ID4+IDQpO1xuICAgICAgICAgICAgciA9ICgoeSAmIDE1KSA8PCAyKSArICh6ID4+IDYpO1xuICAgICAgICAgICAgcyA9IHogJiA2MztcbiAgICAgICAgICAgIGlmKGkrMT49bikgeyByID0gcyA9IDY0OyB9XG4gICAgICAgICAgICBlbHNlIGlmKGkrMj49bikgeyBzID0gNjQ7IH1cbiAgICAgICAgICAgIHJldCArPSBrZXkuY2hhckF0KHApICsga2V5LmNoYXJBdChxKSArIGtleS5jaGFyQXQocikgKyBrZXkuY2hhckF0KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmMzMkFycmF5IChhLGZyb20sdG8pIHtcbiAgICAgICAgaWYodHlwZW9mIGZyb20gPT09IFwidW5kZWZpbmVkXCIpIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgaWYodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSB7IHRvID0gYS5sZW5ndGg7IH1cbiAgICAgICAgdmFyIHRhYmxlID0gWzB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4RUUwRTYxMkMsIDB4OTkwOTUxQkEsIDB4MDc2REM0MTksIDB4NzA2QUY0OEYsIDB4RTk2M0E1MzUsIDB4OUU2NDk1QTMsXG4gICAgICAgICAgICAgICAgICAgICAweDBFREI4ODMyLCAweDc5RENCOEE0LCAweEUwRDVFOTFFLCAweDk3RDJEOTg4LCAweDA5QjY0QzJCLCAweDdFQjE3Q0JELCAweEU3QjgyRDA3LCAweDkwQkYxRDkxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MURCNzEwNjQsIDB4NkFCMDIwRjIsIDB4RjNCOTcxNDgsIDB4ODRCRTQxREUsIDB4MUFEQUQ0N0QsIDB4NkREREU0RUIsIDB4RjRENEI1NTEsIDB4ODNEMzg1QzcsXG4gICAgICAgICAgICAgICAgICAgICAweDEzNkM5ODU2LCAweDY0NkJBOEMwLCAweEZENjJGOTdBLCAweDhBNjVDOUVDLCAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LCAweEZBMEYzRDYzLCAweDhEMDgwREY1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4M0I2RTIwQzgsIDB4NEM2OTEwNUUsIDB4RDU2MDQxRTQsIDB4QTI2NzcxNzIsIDB4M0MwM0U0RDEsIDB4NEIwNEQ0NDcsIDB4RDIwRDg1RkQsIDB4QTUwQUI1NkIsIFxuICAgICAgICAgICAgICAgICAgICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMywgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSwgXG4gICAgICAgICAgICAgICAgICAgICAweDI2RDkzMEFDLCAweDUxREUwMDNBLCAweEM4RDc1MTgwLCAweEJGRDA2MTE2LCAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LCAweEI4QkRBNTBGLFxuICAgICAgICAgICAgICAgICAgICAgMHgyODAyQjg5RSwgMHg1RjA1ODgwOCwgMHhDNjBDRDlCMiwgMHhCMTBCRTkyNCwgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCxcbiAgICAgICAgICAgICAgICAgICAgIDB4NzZEQzQxOTAsIDB4MDFEQjcxMDYsIDB4OThEMjIwQkMsIDB4RUZENTEwMkEsIDB4NzFCMTg1ODksIDB4MDZCNkI1MUYsIDB4OUZCRkU0QTUsIDB4RThCOEQ0MzMsXG4gICAgICAgICAgICAgICAgICAgICAweDc4MDdDOUEyLCAweDBGMDBGOTM0LCAweDk2MDlBODhFLCAweEUxMEU5ODE4LCAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NkI2QjUxRjQsIDB4MUM2QzYxNjIsIDB4ODU2NTMwRDgsIDB4RjI2MjAwNEUsIDB4NkMwNjk1RUQsIDB4MUIwMUE1N0IsIDB4ODIwOEY0QzEsIDB4RjUwRkM0NTcsIFxuICAgICAgICAgICAgICAgICAgICAgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCwgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMywgMHhGQkQ0NEM2NSwgXG4gICAgICAgICAgICAgICAgICAgICAweDREQjI2MTU4LCAweDNBQjU1MUNFLCAweEEzQkMwMDc0LCAweEQ0QkIzMEUyLCAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NDM2OUU5NkEsIDB4MzQ2RUQ5RkMsIDB4QUQ2Nzg4NDYsIDB4REE2MEI4RDAsIDB4NDQwNDJENzMsIDB4MzMwMzFERTUsIDB4QUEwQTRDNUYsIDB4REQwRDdDQzksIFxuICAgICAgICAgICAgICAgICAgICAgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCwgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RiwgXG4gICAgICAgICAgICAgICAgICAgICAweDVFREVGOTBFLCAweDI5RDlDOTk4LCAweEIwRDA5ODIyLCAweEM3RDdBOEI0LCAweDU5QjMzRDE3LCAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RURCODgzMjAsIDB4OUFCRkIzQjYsIDB4MDNCNkUyMEMsIDB4NzRCMUQyOUEsIDB4RUFENTQ3MzksIDB4OUREMjc3QUYsIDB4MDREQjI2MTUsIDB4NzNEQzE2ODMsIFxuICAgICAgICAgICAgICAgICAgICAgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCwgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSwgXG4gICAgICAgICAgICAgICAgICAgICAweEYwMEY5MzQ0LCAweDg3MDhBM0QyLCAweDFFMDFGMjY4LCAweDY5MDZDMkZFLCAweEY3NjI1NzVELCAweDgwNjU2N0NCLCAweDE5NkMzNjcxLCAweDZFNkIwNkU3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RkVENDFCNzYsIDB4ODlEMzJCRTAsIDB4MTBEQTdBNUEsIDB4NjdERDRBQ0MsIDB4RjlCOURGNkYsIDB4OEVCRUVGRjksIDB4MTdCN0JFNDMsIDB4NjBCMDhFRDUsIFxuICAgICAgICAgICAgICAgICAgICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSwgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QiwgXG4gICAgICAgICAgICAgICAgICAgICAweEQ4MEQyQkRBLCAweEFGMEExQjRDLCAweDM2MDM0QUY2LCAweDQxMDQ3QTYwLCAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLCAweDQ2NjlCRTc5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4Q0I2MUIzOEMsIDB4QkM2NjgzMUEsIDB4MjU2RkQyQTAsIDB4NTI2OEUyMzYsIDB4Q0MwQzc3OTUsIDB4QkIwQjQ3MDMsIDB4MjIwMjE2QjksIDB4NTUwNTI2MkYsIFxuICAgICAgICAgICAgICAgICAgICAgMHhDNUJBM0JCRSwgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSwgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCwgXG4gICAgICAgICAgICAgICAgICAgICAweDlCNjRDMkIwLCAweEVDNjNGMjI2LCAweDc1NkFBMzlDLCAweDAyNkQ5MzBBLCAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4OTVCRjRBODIsIDB4RTJCODdBMTQsIDB4N0JCMTJCQUUsIDB4MENCNjFCMzgsIDB4OTJEMjhFOUIsIDB4RTVENUJFMEQsIDB4N0NEQ0VGQjcsIDB4MEJEQkRGMjEsIFxuICAgICAgICAgICAgICAgICAgICAgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MiwgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSwgMHgxOEI3NDc3NywgXG4gICAgICAgICAgICAgICAgICAgICAweDg4MDg1QUU2LCAweEZGMEY2QTcwLCAweDY2MDYzQkNBLCAweDExMDEwQjVDLCAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QTAwQUUyNzgsIDB4RDcwREQyRUUsIDB4NEUwNDgzNTQsIDB4MzkwM0IzQzIsIDB4QTc2NzI2NjEsIDB4RDA2MDE2RjcsIDB4NDk2OTQ3NEQsIDB4M0U2RTc3REIsIFxuICAgICAgICAgICAgICAgICAgICAgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NiwgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSwgXG4gICAgICAgICAgICAgICAgICAgICAweEJEQkRGMjFDLCAweENBQkFDMjhBLCAweDUzQjM5MzMwLCAweDI0QjRBM0E2LCAweEJBRDAzNjA1LCAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QjM2NjdBMkUsIDB4QzQ2MTRBQjgsIDB4NUQ2ODFCMDIsIDB4MkE2RjJCOTQsIDB4QjQwQkJFMzcsIDB4QzMwQzhFQTEsIDB4NUEwNURGMUIsIDB4MkQwMkVGOERdO1xuICAgICBcbiAgICAgICAgdmFyIGNyYyA9IC0xLCB5ID0gMCwgbiA9IGEubGVuZ3RoLGk7XG5cbiAgICAgICAgZm9yIChpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIHkgPSAoY3JjIF4gYVtpXSkgJiAweEZGO1xuICAgICAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVt5XTtcbiAgICAgICAgfVxuICAgICBcbiAgICAgICAgcmV0dXJuIGNyYyBeICgtMSk7XG4gICAgfVxuXG4gICAgdmFyIGggPSBpbWdbMF0ubGVuZ3RoLCB3ID0gaW1nWzBdWzBdLmxlbmd0aCwgczEsIHMyLCBuZXh0LGssbGVuZ3RoLGEsYixpLGosYWRsZXIzMixjcmMzMjtcbiAgICB2YXIgc3RyZWFtID0gW1xuICAgICAgICAgICAgICAgICAgMTM3LCA4MCwgNzgsIDcxLCAxMywgMTAsIDI2LCAxMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMDogUE5HIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgMCwwLDAsMTMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgODogSUhEUiBDaHVuayBsZW5ndGhcbiAgICAgICAgICAgICAgICAgIDczLCA3MiwgNjgsIDgyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTI6IFwiSUhEUlwiIFxuICAgICAgICAgICAgICAgICAgKHcgPj4gMjQpICYgMjU1LCAodyA+PiAxNikgJiAyNTUsICh3ID4+IDgpICYgMjU1LCB3JjI1NSwgICAvLyAxNjogV2lkdGhcbiAgICAgICAgICAgICAgICAgIChoID4+IDI0KSAmIDI1NSwgKGggPj4gMTYpICYgMjU1LCAoaCA+PiA4KSAmIDI1NSwgaCYyNTUsICAgLy8gMjA6IEhlaWdodFxuICAgICAgICAgICAgICAgICAgOCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNDogYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI1OiBSR0JcbiAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjY6IGRlZmxhdGVcbiAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjc6IG5vIGZpbHRlclxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyODogbm8gaW50ZXJsYWNlXG4gICAgICAgICAgICAgICAgICAtMSwtMiwtMywtNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI5OiBDUkNcbiAgICAgICAgICAgICAgICAgIC01LC02LC03LC04LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzM6IElEQVQgQ2h1bmsgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICA3MywgNjgsIDY1LCA4NCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDM3OiBcIklEQVRcIlxuICAgICAgICAgICAgICAgICAgLy8gUkZDIDE5NTAgaGVhZGVyIHN0YXJ0cyBoZXJlXG4gICAgICAgICAgICAgICAgICA4LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQxOiBSRkMxOTUwIENNRlxuICAgICAgICAgICAgICAgICAgMjkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0MjogUkZDMTk1MCBGTEdcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgY3JjMzIgPSBjcmMzMkFycmF5KHN0cmVhbSwxMiwyOSk7XG4gICAgc3RyZWFtWzI5XSA9IChjcmMzMj4+MjQpJjI1NTtcbiAgICBzdHJlYW1bMzBdID0gKGNyYzMyPj4xNikmMjU1O1xuICAgIHN0cmVhbVszMV0gPSAoY3JjMzI+PjgpJjI1NTtcbiAgICBzdHJlYW1bMzJdID0gKGNyYzMyKSYyNTU7XG4gICAgczEgPSAxO1xuICAgIHMyID0gMDtcbiAgICBmb3IoaT0wO2k8aDtpKyspIHtcbiAgICAgICAgaWYoaTxoLTEpIHsgc3RyZWFtLnB1c2goMCk7IH1cbiAgICAgICAgZWxzZSB7IHN0cmVhbS5wdXNoKDEpOyB9XG4gICAgICAgIGEgPSAoMyp3KzErKGk9PT0wKSkmMjU1OyBiID0gKCgzKncrMSsoaT09PTApKT4+OCkmMjU1O1xuICAgICAgICBzdHJlYW0ucHVzaChhKTsgc3RyZWFtLnB1c2goYik7XG4gICAgICAgIHN0cmVhbS5wdXNoKCh+YSkmMjU1KTsgc3RyZWFtLnB1c2goKH5iKSYyNTUpO1xuICAgICAgICBpZihpPT09MCkgc3RyZWFtLnB1c2goMCk7XG4gICAgICAgIGZvcihqPTA7ajx3O2orKykge1xuICAgICAgICAgICAgZm9yKGs9MDtrPDM7aysrKSB7XG4gICAgICAgICAgICAgICAgYSA9IGltZ1trXVtpXVtqXTtcbiAgICAgICAgICAgICAgICBpZihhPjI1NSkgYSA9IDI1NTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGE8MCkgYT0wO1xuICAgICAgICAgICAgICAgIGVsc2UgYSA9IE1hdGgucm91bmQoYSk7XG4gICAgICAgICAgICAgICAgczEgPSAoczEgKyBhICklNjU1MjE7XG4gICAgICAgICAgICAgICAgczIgPSAoczIgKyBzMSklNjU1MjE7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2goYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnB1c2goMCk7XG4gICAgfVxuICAgIGFkbGVyMzIgPSAoczI8PDE2KStzMTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+MjQpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjE2KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj44KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyKSYyNTUpO1xuICAgIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGggLSA0MTtcbiAgICBzdHJlYW1bMzNdID0gKGxlbmd0aD4+MjQpJjI1NTtcbiAgICBzdHJlYW1bMzRdID0gKGxlbmd0aD4+MTYpJjI1NTtcbiAgICBzdHJlYW1bMzVdID0gKGxlbmd0aD4+OCkmMjU1O1xuICAgIHN0cmVhbVszNl0gPSAobGVuZ3RoKSYyNTU7XG4gICAgY3JjMzIgPSBjcmMzMkFycmF5KHN0cmVhbSwzNyk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj4yNCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjE2KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+OCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzIpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4gICAgc3RyZWFtLnB1c2goMCk7XG4vLyAgICBhID0gc3RyZWFtLmxlbmd0aDtcbiAgICBzdHJlYW0ucHVzaCg3Myk7ICAvLyBJXG4gICAgc3RyZWFtLnB1c2goNjkpOyAgLy8gRVxuICAgIHN0cmVhbS5wdXNoKDc4KTsgIC8vIE5cbiAgICBzdHJlYW0ucHVzaCg2OCk7ICAvLyBEXG4gICAgc3RyZWFtLnB1c2goMTc0KTsgLy8gQ1JDMVxuICAgIHN0cmVhbS5wdXNoKDY2KTsgIC8vIENSQzJcbiAgICBzdHJlYW0ucHVzaCg5Nik7ICAvLyBDUkMzXG4gICAgc3RyZWFtLnB1c2goMTMwKTsgLy8gQ1JDNFxuICAgIHJldHVybiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcrYmFzZTY0KHN0cmVhbSk7XG59XG5cbi8vIDIuIExpbmVhciBhbGdlYnJhIHdpdGggQXJyYXlzLlxubnVtZXJpYy5fZGltID0gZnVuY3Rpb24gX2RpbSh4KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHdoaWxlKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7IHJldC5wdXNoKHgubGVuZ3RoKTsgeCA9IHhbMF07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRpbSA9IGZ1bmN0aW9uIGRpbSh4KSB7XG4gICAgdmFyIHksejtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB5ID0geFswXTtcbiAgICAgICAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHogPSB5WzBdO1xuICAgICAgICAgICAgaWYodHlwZW9mIHogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtZXJpYy5fZGltKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt4Lmxlbmd0aCx5Lmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4Lmxlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxubnVtZXJpYy5tYXByZWR1Y2UgPSBmdW5jdGlvbiBtYXByZWR1Y2UoYm9keSxpbml0KSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd4JywnYWNjdW0nLCdfcycsJ19rJyxcbiAgICAgICAgICAgICdpZih0eXBlb2YgYWNjdW0gPT09IFwidW5kZWZpbmVkXCIpIGFjY3VtID0gJytpbml0Kyc7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikgeyB2YXIgeGkgPSB4OyAnK2JvZHkrJzsgcmV0dXJuIGFjY3VtOyB9XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX3MgPT09IFwidW5kZWZpbmVkXCIpIF9zID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX2sgPT09IFwidW5kZWZpbmVkXCIpIF9rID0gMDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBfbiA9IF9zW19rXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpLHhpO1xcbicrXG4gICAgICAgICAgICAnaWYoX2sgPCBfcy5sZW5ndGgtMSkge1xcbicrXG4gICAgICAgICAgICAnICAgIGZvcihpPV9uLTE7aT49MDtpLS0pIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAgICAgYWNjdW0gPSBhcmd1bWVudHMuY2FsbGVlKHhbaV0sYWNjdW0sX3MsX2srMSk7XFxuJytcbiAgICAgICAgICAgICcgICAgfScrXG4gICAgICAgICAgICAnICAgIHJldHVybiBhY2N1bTtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aT49MTtpLT0yKSB7IFxcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJztcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaS0xXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJztcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2lmKGkgPT09IDApIHtcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBhY2N1bTsnXG4gICAgICAgICAgICApO1xufVxubnVtZXJpYy5tYXByZWR1Y2UyID0gZnVuY3Rpb24gbWFwcmVkdWNlMihib2R5LHNldHVwKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd4JyxcbiAgICAgICAgICAgICd2YXIgbiA9IHgubGVuZ3RoO1xcbicrXG4gICAgICAgICAgICAndmFyIGkseGk7XFxuJytzZXR1cCsnO1xcbicrXG4gICAgICAgICAgICAnZm9yKGk9bi0xO2khPT0tMTstLWkpIHsgXFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIGFjY3VtOydcbiAgICAgICAgICAgICk7XG59XG5cblxubnVtZXJpYy5zYW1lID0gZnVuY3Rpb24gc2FtZSh4LHkpIHtcbiAgICB2YXIgaSxuO1xuICAgIGlmKCEoeCBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKHkgaW5zdGFuY2VvZiBBcnJheSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gIT09IHkubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBpZih4W2ldID09PSB5W2ldKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4W2ldID09PSBcIm9iamVjdFwiKSB7IGlmKCFzYW1lKHhbaV0seVtpXSkpIHJldHVybiBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5udW1lcmljLnJlcCA9IGZ1bmN0aW9uIHJlcChzLHYsaykge1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIHZhciBuID0gc1trXSwgcmV0ID0gQXJyYXkobiksIGk7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICBmb3IoaT1uLTI7aT49MDtpLT0yKSB7IHJldFtpKzFdID0gdjsgcmV0W2ldID0gdjsgfVxuICAgICAgICBpZihpPT09LTEpIHsgcmV0WzBdID0gdjsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgcmV0W2ldID0gbnVtZXJpYy5yZXAocyx2LGsrMSk7IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5cbm51bWVyaWMuZG90TU1zbWFsbCA9IGZ1bmN0aW9uIGRvdE1Nc21hbGwoeCx5KSB7XG4gICAgdmFyIGksaixrLHAscSxyLHJldCxmb28sYmFyLHdvbyxpMCxrMCxwMCxyMDtcbiAgICBwID0geC5sZW5ndGg7IHEgPSB5Lmxlbmd0aDsgciA9IHlbMF0ubGVuZ3RoO1xuICAgIHJldCA9IEFycmF5KHApO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkge1xuICAgICAgICBmb28gPSBBcnJheShyKTtcbiAgICAgICAgYmFyID0geFtpXTtcbiAgICAgICAgZm9yKGs9ci0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICB3b28gPSBiYXJbcS0xXSp5W3EtMV1ba107XG4gICAgICAgICAgICBmb3Ioaj1xLTI7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICAgICAgaTAgPSBqLTE7XG4gICAgICAgICAgICAgICAgd29vICs9IGJhcltqXSp5W2pdW2tdICsgYmFyW2kwXSp5W2kwXVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGo9PT0wKSB7IHdvbyArPSBiYXJbMF0qeVswXVtrXTsgfVxuICAgICAgICAgICAgZm9vW2tdID0gd29vO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSA9IGZvbztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuX2dldENvbCA9IGZ1bmN0aW9uIF9nZXRDb2woQSxqLHgpIHtcbiAgICB2YXIgbiA9IEEubGVuZ3RoLCBpO1xuICAgIGZvcihpPW4tMTtpPjA7LS1pKSB7XG4gICAgICAgIHhbaV0gPSBBW2ldW2pdO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhbaV0gPSBBW2ldW2pdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeFswXSA9IEFbMF1bal07XG59XG5udW1lcmljLmRvdE1NYmlnID0gZnVuY3Rpb24gZG90TU1iaWcoeCx5KXtcbiAgICB2YXIgZ2MgPSBudW1lcmljLl9nZXRDb2wsIHAgPSB5Lmxlbmd0aCwgdiA9IEFycmF5KHApO1xuICAgIHZhciBtID0geC5sZW5ndGgsIG4gPSB5WzBdLmxlbmd0aCwgQSA9IG5ldyBBcnJheShtKSwgeGo7XG4gICAgdmFyIFZWID0gbnVtZXJpYy5kb3RWVjtcbiAgICB2YXIgaSxqLGssejtcbiAgICAtLXA7XG4gICAgLS1tO1xuICAgIGZvcihpPW07aSE9PS0xOy0taSkgQVtpXSA9IEFycmF5KG4pO1xuICAgIC0tbjtcbiAgICBmb3IoaT1uO2khPT0tMTstLWkpIHtcbiAgICAgICAgZ2MoeSxpLHYpO1xuICAgICAgICBmb3Ioaj1tO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIHo9MDtcbiAgICAgICAgICAgIHhqID0geFtqXTtcbiAgICAgICAgICAgIEFbal1baV0gPSBWVih4aix2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxubnVtZXJpYy5kb3RNViA9IGZ1bmN0aW9uIGRvdE1WKHgseSkge1xuICAgIHZhciBwID0geC5sZW5ndGgsIHEgPSB5Lmxlbmd0aCxpO1xuICAgIHZhciByZXQgPSBBcnJheShwKSwgZG90VlYgPSBudW1lcmljLmRvdFZWO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBkb3RWVih4W2ldLHkpOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kb3RWTSA9IGZ1bmN0aW9uIGRvdFZNKHgseSkge1xuICAgIHZhciBpLGosayxwLHEscixyZXQsZm9vLGJhcix3b28saTAsazAscDAscjAsczEsczIsczMsYmF6LGFjY3VtO1xuICAgIHAgPSB4Lmxlbmd0aDsgcSA9IHlbMF0ubGVuZ3RoO1xuICAgIHJldCA9IEFycmF5KHEpO1xuICAgIGZvcihrPXEtMTtrPj0wO2stLSkge1xuICAgICAgICB3b28gPSB4W3AtMV0qeVtwLTFdW2tdO1xuICAgICAgICBmb3Ioaj1wLTI7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICBpMCA9IGotMTtcbiAgICAgICAgICAgIHdvbyArPSB4W2pdKnlbal1ba10gKyB4W2kwXSp5W2kwXVtrXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyB3b28gKz0geFswXSp5WzBdW2tdOyB9XG4gICAgICAgIHJldFtrXSA9IHdvbztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5kb3RWViA9IGZ1bmN0aW9uIGRvdFZWKHgseSkge1xuICAgIHZhciBpLG49eC5sZW5ndGgsaTEscmV0ID0geFtuLTFdKnlbbi0xXTtcbiAgICBmb3IoaT1uLTI7aT49MTtpLT0yKSB7XG4gICAgICAgIGkxID0gaS0xO1xuICAgICAgICByZXQgKz0geFtpXSp5W2ldICsgeFtpMV0qeVtpMV07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7IHJldCArPSB4WzBdKnlbMF07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdCA9IGZ1bmN0aW9uIGRvdCh4LHkpIHtcbiAgICB2YXIgZCA9IG51bWVyaWMuZGltO1xuICAgIHN3aXRjaChkKHgpLmxlbmd0aCoxMDAwK2QoeSkubGVuZ3RoKSB7XG4gICAgY2FzZSAyMDAyOlxuICAgICAgICBpZih5Lmxlbmd0aCA8IDEwKSByZXR1cm4gbnVtZXJpYy5kb3RNTXNtYWxsKHgseSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIG51bWVyaWMuZG90TU1iaWcoeCx5KTtcbiAgICBjYXNlIDIwMDE6IHJldHVybiBudW1lcmljLmRvdE1WKHgseSk7XG4gICAgY2FzZSAxMDAyOiByZXR1cm4gbnVtZXJpYy5kb3RWTSh4LHkpO1xuICAgIGNhc2UgMTAwMTogcmV0dXJuIG51bWVyaWMuZG90VlYoeCx5KTtcbiAgICBjYXNlIDEwMDA6IHJldHVybiBudW1lcmljLm11bFZTKHgseSk7XG4gICAgY2FzZSAxOiByZXR1cm4gbnVtZXJpYy5tdWxTVih4LHkpO1xuICAgIGNhc2UgMDogcmV0dXJuIHgqeTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWMuZG90IG9ubHkgd29ya3Mgb24gdmVjdG9ycyBhbmQgbWF0cmljZXMnKTtcbiAgICB9XG59XG5cbm51bWVyaWMuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIHZhciBpLGkxLGosbiA9IGQubGVuZ3RoLCBBID0gQXJyYXkobiksIEFpO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFycmF5KG4pO1xuICAgICAgICBpMSA9IGkrMjtcbiAgICAgICAgZm9yKGo9bi0xO2o+PWkxO2otPTIpIHtcbiAgICAgICAgICAgIEFpW2pdID0gMDtcbiAgICAgICAgICAgIEFpW2otMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo+aSkgeyBBaVtqXSA9IDA7IH1cbiAgICAgICAgQWlbaV0gPSBkW2ldO1xuICAgICAgICBmb3Ioaj1pLTE7aj49MTtqLT0yKSB7XG4gICAgICAgICAgICBBaVtqXSA9IDA7XG4gICAgICAgICAgICBBaVtqLTFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyBBaVswXSA9IDA7IH1cbiAgICAgICAgQVtpXSA9IEFpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cbm51bWVyaWMuZ2V0RGlhZyA9IGZ1bmN0aW9uKEEpIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKEEubGVuZ3RoLEFbMF0ubGVuZ3RoKSxpLHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0xOy0taSkge1xuICAgICAgICByZXRbaV0gPSBBW2ldW2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHJldFtpXSA9IEFbaV1baV07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7XG4gICAgICAgIHJldFswXSA9IEFbMF1bMF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoW25dLDEpKTsgfVxubnVtZXJpYy5wb2ludHdpc2UgPSBmdW5jdGlvbiBwb2ludHdpc2UocGFyYW1zLGJvZHksc2V0dXApIHtcbiAgICBpZih0eXBlb2Ygc2V0dXAgPT09IFwidW5kZWZpbmVkXCIpIHsgc2V0dXAgPSBcIlwiOyB9XG4gICAgdmFyIGZ1biA9IFtdO1xuICAgIHZhciBrO1xuICAgIHZhciBhdmVjID0gL1xcW2lcXF0kLyxwLHRoZXZlYyA9ICcnO1xuICAgIHZhciBoYXZlcmV0ID0gZmFsc2U7XG4gICAgZm9yKGs9MDtrPHBhcmFtcy5sZW5ndGg7aysrKSB7XG4gICAgICAgIGlmKGF2ZWMudGVzdChwYXJhbXNba10pKSB7XG4gICAgICAgICAgICBwID0gcGFyYW1zW2tdLnN1YnN0cmluZygwLHBhcmFtc1trXS5sZW5ndGgtMyk7XG4gICAgICAgICAgICB0aGV2ZWMgPSBwO1xuICAgICAgICB9IGVsc2UgeyBwID0gcGFyYW1zW2tdOyB9XG4gICAgICAgIGlmKHA9PT0ncmV0JykgaGF2ZXJldCA9IHRydWU7XG4gICAgICAgIGZ1bi5wdXNoKHApO1xuICAgIH1cbiAgICBmdW5bcGFyYW1zLmxlbmd0aF0gPSAnX3MnO1xuICAgIGZ1bltwYXJhbXMubGVuZ3RoKzFdID0gJ19rJztcbiAgICBmdW5bcGFyYW1zLmxlbmd0aCsyXSA9IChcbiAgICAgICAgICAgICdpZih0eXBlb2YgX3MgPT09IFwidW5kZWZpbmVkXCIpIF9zID0gbnVtZXJpYy5kaW0oJyt0aGV2ZWMrJyk7XFxuJytcbiAgICAgICAgICAgICdpZih0eXBlb2YgX2sgPT09IFwidW5kZWZpbmVkXCIpIF9rID0gMDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBfbiA9IF9zW19rXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpJysoaGF2ZXJldD8nJzonLCByZXQgPSBBcnJheShfbiknKSsnO1xcbicrXG4gICAgICAgICAgICAnaWYoX2sgPCBfcy5sZW5ndGgtMSkge1xcbicrXG4gICAgICAgICAgICAnICAgIGZvcihpPV9uLTE7aT49MDtpLS0pIHJldFtpXSA9IGFyZ3VtZW50cy5jYWxsZWUoJytwYXJhbXMuam9pbignLCcpKycsX3MsX2srMSk7XFxuJytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIHJldDtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgc2V0dXArJ1xcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpIT09LTE7LS1pKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiByZXQ7J1xuICAgICAgICAgICAgKTtcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCxmdW4pO1xufVxubnVtZXJpYy5wb2ludHdpc2UyID0gZnVuY3Rpb24gcG9pbnR3aXNlMihwYXJhbXMsYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyBzZXR1cCA9IFwiXCI7IH1cbiAgICB2YXIgZnVuID0gW107XG4gICAgdmFyIGs7XG4gICAgdmFyIGF2ZWMgPSAvXFxbaVxcXSQvLHAsdGhldmVjID0gJyc7XG4gICAgdmFyIGhhdmVyZXQgPSBmYWxzZTtcbiAgICBmb3Ioaz0wO2s8cGFyYW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoYXZlYy50ZXN0KHBhcmFtc1trXSkpIHtcbiAgICAgICAgICAgIHAgPSBwYXJhbXNba10uc3Vic3RyaW5nKDAscGFyYW1zW2tdLmxlbmd0aC0zKTtcbiAgICAgICAgICAgIHRoZXZlYyA9IHA7XG4gICAgICAgIH0gZWxzZSB7IHAgPSBwYXJhbXNba107IH1cbiAgICAgICAgaWYocD09PSdyZXQnKSBoYXZlcmV0ID0gdHJ1ZTtcbiAgICAgICAgZnVuLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bltwYXJhbXMubGVuZ3RoXSA9IChcbiAgICAgICAgICAgICd2YXIgX24gPSAnK3RoZXZlYysnLmxlbmd0aDtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBpJysoaGF2ZXJldD8nJzonLCByZXQgPSBBcnJheShfbiknKSsnO1xcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgYm9keSsnXFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gcmV0OydcbiAgICAgICAgICAgICk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KG51bGwsZnVuKTtcbn1cbm51bWVyaWMuX2JpZm9yZWFjaCA9IChmdW5jdGlvbiBfYmlmb3JlYWNoKHgseSxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZih4LHkpOyByZXR1cm47IH1cbiAgICB2YXIgaSxuPXNba107XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IF9iaWZvcmVhY2godHlwZW9mIHg9PT1cIm9iamVjdFwiP3hbaV06eCx0eXBlb2YgeT09PVwib2JqZWN0XCI/eVtpXTp5LHMsaysxLGYpOyB9XG59KTtcbm51bWVyaWMuX2JpZm9yZWFjaDIgPSAoZnVuY3Rpb24gX2JpZm9yZWFjaDIoeCx5LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyByZXR1cm4gZih4LHkpOyB9XG4gICAgdmFyIGksbj1zW2tdLHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0wOy0taSkgeyByZXRbaV0gPSBfYmlmb3JlYWNoMih0eXBlb2YgeD09PVwib2JqZWN0XCI/eFtpXTp4LHR5cGVvZiB5PT09XCJvYmplY3RcIj95W2ldOnkscyxrKzEsZik7IH1cbiAgICByZXR1cm4gcmV0O1xufSk7XG5udW1lcmljLl9mb3JlYWNoID0gKGZ1bmN0aW9uIF9mb3JlYWNoKHgscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IGYoeCk7IHJldHVybjsgfVxuICAgIHZhciBpLG49c1trXTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgX2ZvcmVhY2goeFtpXSxzLGsrMSxmKTsgfVxufSk7XG5udW1lcmljLl9mb3JlYWNoMiA9IChmdW5jdGlvbiBfZm9yZWFjaDIoeCxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgcmV0dXJuIGYoeCk7IH1cbiAgICB2YXIgaSxuPXNba10sIHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBfZm9yZWFjaDIoeFtpXSxzLGsrMSxmKTsgfVxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLypudW1lcmljLmFueVYgPSBudW1lcmljLm1hcHJlZHVjZSgnaWYoeGkpIHJldHVybiB0cnVlOycsJ2ZhbHNlJyk7XG5udW1lcmljLmFsbFYgPSBudW1lcmljLm1hcHJlZHVjZSgnaWYoIXhpKSByZXR1cm4gZmFsc2U7JywndHJ1ZScpO1xubnVtZXJpYy5hbnkgPSBmdW5jdGlvbih4KSB7IGlmKHR5cGVvZiB4Lmxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHg7IHJldHVybiBudW1lcmljLmFueVYoeCk7IH1cbm51bWVyaWMuYWxsID0gZnVuY3Rpb24oeCkgeyBpZih0eXBlb2YgeC5sZW5ndGggPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB4OyByZXR1cm4gbnVtZXJpYy5hbGxWKHgpOyB9Ki9cblxubnVtZXJpYy5vcHMyID0ge1xuICAgICAgICBhZGQ6ICcrJyxcbiAgICAgICAgc3ViOiAnLScsXG4gICAgICAgIG11bDogJyonLFxuICAgICAgICBkaXY6ICcvJyxcbiAgICAgICAgbW9kOiAnJScsXG4gICAgICAgIGFuZDogJyYmJyxcbiAgICAgICAgb3I6ICAnfHwnLFxuICAgICAgICBlcTogICc9PT0nLFxuICAgICAgICBuZXE6ICchPT0nLFxuICAgICAgICBsdDogICc8JyxcbiAgICAgICAgZ3Q6ICAnPicsXG4gICAgICAgIGxlcTogJzw9JyxcbiAgICAgICAgZ2VxOiAnPj0nLFxuICAgICAgICBiYW5kOiAnJicsXG4gICAgICAgIGJvcjogJ3wnLFxuICAgICAgICBieG9yOiAnXicsXG4gICAgICAgIGxzaGlmdDogJzw8JyxcbiAgICAgICAgcnNoaWZ0OiAnPj4nLFxuICAgICAgICBycnNoaWZ0OiAnPj4+J1xufTtcbm51bWVyaWMub3BzZXEgPSB7XG4gICAgICAgIGFkZGVxOiAnKz0nLFxuICAgICAgICBzdWJlcTogJy09JyxcbiAgICAgICAgbXVsZXE6ICcqPScsXG4gICAgICAgIGRpdmVxOiAnLz0nLFxuICAgICAgICBtb2RlcTogJyU9JyxcbiAgICAgICAgbHNoaWZ0ZXE6ICc8PD0nLFxuICAgICAgICByc2hpZnRlcTogJz4+PScsXG4gICAgICAgIHJyc2hpZnRlcTogJz4+Pj0nLFxuICAgICAgICBiYW5kZXE6ICcmPScsXG4gICAgICAgIGJvcmVxOiAnfD0nLFxuICAgICAgICBieG9yZXE6ICdePSdcbn07XG5udW1lcmljLm1hdGhmdW5zID0gWydhYnMnLCdhY29zJywnYXNpbicsJ2F0YW4nLCdjZWlsJywnY29zJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4cCcsJ2Zsb29yJywnbG9nJywncm91bmQnLCdzaW4nLCdzcXJ0JywndGFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzTmFOJywnaXNGaW5pdGUnXTtcbm51bWVyaWMubWF0aGZ1bnMyID0gWydhdGFuMicsJ3BvdycsJ21heCcsJ21pbiddO1xubnVtZXJpYy5vcHMxID0ge1xuICAgICAgICBuZWc6ICctJyxcbiAgICAgICAgbm90OiAnIScsXG4gICAgICAgIGJub3Q6ICd+JyxcbiAgICAgICAgY2xvbmU6ICcnXG59O1xubnVtZXJpYy5tYXByZWR1Y2VycyA9IHtcbiAgICAgICAgYW55OiBbJ2lmKHhpKSByZXR1cm4gdHJ1ZTsnLCd2YXIgYWNjdW0gPSBmYWxzZTsnXSxcbiAgICAgICAgYWxsOiBbJ2lmKCF4aSkgcmV0dXJuIGZhbHNlOycsJ3ZhciBhY2N1bSA9IHRydWU7J10sXG4gICAgICAgIHN1bTogWydhY2N1bSArPSB4aTsnLCd2YXIgYWNjdW0gPSAwOyddLFxuICAgICAgICBwcm9kOiBbJ2FjY3VtICo9IHhpOycsJ3ZhciBhY2N1bSA9IDE7J10sXG4gICAgICAgIG5vcm0yU3F1YXJlZDogWydhY2N1bSArPSB4aSp4aTsnLCd2YXIgYWNjdW0gPSAwOyddLFxuICAgICAgICBub3JtaW5mOiBbJ2FjY3VtID0gbWF4KGFjY3VtLGFicyh4aSkpOycsJ3ZhciBhY2N1bSA9IDAsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFiczsnXSxcbiAgICAgICAgbm9ybTE6IFsnYWNjdW0gKz0gYWJzKHhpKScsJ3ZhciBhY2N1bSA9IDAsIGFicyA9IE1hdGguYWJzOyddLFxuICAgICAgICBzdXA6IFsnYWNjdW0gPSBtYXgoYWNjdW0seGkpOycsJ3ZhciBhY2N1bSA9IC1JbmZpbml0eSwgbWF4ID0gTWF0aC5tYXg7J10sXG4gICAgICAgIGluZjogWydhY2N1bSA9IG1pbihhY2N1bSx4aSk7JywndmFyIGFjY3VtID0gSW5maW5pdHksIG1pbiA9IE1hdGgubWluOyddXG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLG87XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMyLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnMyW2ldO1xuICAgICAgICBudW1lcmljLm9wczJbb10gPSBvO1xuICAgIH1cbiAgICBmb3IoaSBpbiBudW1lcmljLm9wczIpIHtcbiAgICAgICAgaWYobnVtZXJpYy5vcHMyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5vcHMyW2ldO1xuICAgICAgICAgICAgdmFyIGNvZGUsIGNvZGVlcSwgc2V0dXAgPSAnJztcbiAgICAgICAgICAgIGlmKG51bWVyaWMubXlJbmRleE9mLmNhbGwobnVtZXJpYy5tYXRoZnVuczIsaSkhPT0tMSkge1xuICAgICAgICAgICAgICAgIHNldHVwID0gJ3ZhciAnK28rJyA9IE1hdGguJytvKyc7XFxuJztcbiAgICAgICAgICAgICAgICBjb2RlID0gZnVuY3Rpb24ocix4LHkpIHsgcmV0dXJuIHIrJyA9ICcrbysnKCcreCsnLCcreSsnKSc7IH07XG4gICAgICAgICAgICAgICAgY29kZWVxID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiB4KycgPSAnK28rJygnK3grJywnK3krJyknOyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gZnVuY3Rpb24ocix4LHkpIHsgcmV0dXJuIHIrJyA9ICcreCsnICcrbysnICcreTsgfTtcbiAgICAgICAgICAgICAgICBpZihudW1lcmljLm9wc2VxLmhhc093blByb3BlcnR5KGkrJ2VxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZWVxID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiB4KycgJytvKyc9ICcreTsgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyA9ICcreCsnICcrbysnICcreTsgfTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWVyaWNbaSsnVlYnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3hbaV0nLCd5W2ldJ10sY29kZSgncmV0W2ldJywneFtpXScsJ3lbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1NWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4JywneVtpXSddLGNvZGUoJ3JldFtpXScsJ3gnLCd5W2ldJyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydWUyddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXScsJ3knXSxjb2RlKCdyZXRbaV0nLCd4W2ldJywneScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgaSwgeCA9IGFyZ3VtZW50c1swXSwgeTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFZWID0gbnVtZXJpYy4nK2krJ1ZWLCBWUyA9IG51bWVyaWMuJytpKydWUywgU1YgPSBudW1lcmljLicraSsnU1Y7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBkaW0gPSBudW1lcmljLmRpbTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnZm9yKGk9MTtpIT09bjsrK2kpIHsgXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgeSA9IGFyZ3VtZW50c1tpXTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgeCA9IG51bWVyaWMuX2JpZm9yZWFjaDIoeCx5LGRpbSh4KSwwLFZWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgICAgZWxzZSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHgpLDAsVlMpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIH0gZWxzZSBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgeCA9IG51bWVyaWMuX2JpZm9yZWFjaDIoeCx5LGRpbSh5KSwwLFNWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBlbHNlICcrY29kZWVxKCd4JywneScpKydcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbnJldHVybiB4O1xcbicpO1xuICAgICAgICAgICAgbnVtZXJpY1tvXSA9IG51bWVyaWNbaV07XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJywneFtpXSddLCBjb2RlZXEoJ3JldFtpXScsJ3hbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxUyddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJywneCddLCBjb2RlZXEoJ3JldFtpXScsJ3gnKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxJ10gPSBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgaSwgeCA9IGFyZ3VtZW50c1swXSwgeTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnZXFWLCBTID0gbnVtZXJpYy4nK2krJ2VxU1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT0xO2khPT1uOysraSkgeyBcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB5ID0gYXJndW1lbnRzW2ldO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSBudW1lcmljLl9iaWZvcmVhY2goeCx5LHMsMCxWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICBlbHNlIG51bWVyaWMuX2JpZm9yZWFjaCh4LHkscywwLFMpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxucmV0dXJuIHg7XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMyLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnMyW2ldO1xuICAgICAgICBkZWxldGUgbnVtZXJpYy5vcHMyW29dO1xuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVucy5sZW5ndGg7KytpKSB7XG4gICAgICAgIG8gPSBudW1lcmljLm1hdGhmdW5zW2ldO1xuICAgICAgICBudW1lcmljLm9wczFbb10gPSBvO1xuICAgIH1cbiAgICBmb3IoaSBpbiBudW1lcmljLm9wczEpIHtcbiAgICAgICAgaWYobnVtZXJpYy5vcHMxLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBzZXR1cCA9ICcnO1xuICAgICAgICAgICAgbyA9IG51bWVyaWMub3BzMVtpXTtcbiAgICAgICAgICAgIGlmKG51bWVyaWMubXlJbmRleE9mLmNhbGwobnVtZXJpYy5tYXRoZnVucyxpKSE9PS0xKSB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5oYXNPd25Qcm9wZXJ0eShvKSkgc2V0dXAgPSAndmFyICcrbysnID0gTWF0aC4nK28rJztcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtZXJpY1tpKydlcVYnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3JldFtpXSddLCdyZXRbaV0gPSAnK28rJyhyZXRbaV0pOycsc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpKydlcSddID0gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHJldHVybiAnK28rJ3hcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBWID0gbnVtZXJpYy4nK2krJ2VxVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnbnVtZXJpYy5fZm9yZWFjaCh4LHMsMCxWKTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAncmV0dXJuIHg7XFxuJyk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1YnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3hbaV0nXSwncmV0W2ldID0gJytvKycoeFtpXSk7JyxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHJldHVybiAnK28rJyh4KVxcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAncmV0dXJuIG51bWVyaWMuX2ZvcmVhY2gyKHgscywwLFYpO1xcbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnNbaV07XG4gICAgICAgIGRlbGV0ZSBudW1lcmljLm9wczFbb107XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMubWFwcmVkdWNlcnMpIHtcbiAgICAgICAgaWYobnVtZXJpYy5tYXByZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbyA9IG51bWVyaWMubWFwcmVkdWNlcnNbaV07XG4gICAgICAgICAgICBudW1lcmljW2krJ1YnXSA9IG51bWVyaWMubWFwcmVkdWNlMihvWzBdLG9bMV0pO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKCd4JywncycsJ2snLFxuICAgICAgICAgICAgICAgICAgICBvWzFdK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHggIT09IFwib2JqZWN0XCIpIHsnK1xuICAgICAgICAgICAgICAgICAgICAnICAgIHhpID0geDtcXG4nK1xuICAgICAgICAgICAgICAgICAgICBvWzBdKyc7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICByZXR1cm4gYWNjdW07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ30nK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHMgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIGsgPSAwO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdpZihrID09PSBzLmxlbmd0aC0xKSByZXR1cm4gbnVtZXJpYy4nK2krJ1YoeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciB4aTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSB4Lmxlbmd0aCwgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgeGkgPSBhcmd1bWVudHMuY2FsbGVlKHhbaV0pO1xcbicrXG4gICAgICAgICAgICAgICAgICAgIG9bMF0rJztcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gYWNjdW07XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG5udW1lcmljLnRydW5jVlYgPSBudW1lcmljLnBvaW50d2lzZShbJ3hbaV0nLCd5W2ldJ10sJ3JldFtpXSA9IHJvdW5kKHhbaV0veVtpXSkqeVtpXTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuY1ZTID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4W2ldJywneSddLCdyZXRbaV0gPSByb3VuZCh4W2ldL3kpKnk7JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmNTViA9IG51bWVyaWMucG9pbnR3aXNlKFsneCcsJ3lbaV0nXSwncmV0W2ldID0gcm91bmQoeC95W2ldKSp5W2ldOycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCx5KSB7XG4gICAgaWYodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHJldHVybiBudW1lcmljLnRydW5jVlYoeCx5KTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMudHJ1bmNWUyh4LHkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIHJldHVybiBudW1lcmljLnRydW5jU1YoeCx5KTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4L3kpKnk7XG59XG5cbm51bWVyaWMuaW52ID0gZnVuY3Rpb24gaW52KHgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpLCBhYnMgPSBNYXRoLmFicywgbSA9IHNbMF0sIG4gPSBzWzFdO1xuICAgIHZhciBBID0gbnVtZXJpYy5jbG9uZSh4KSwgQWksIEFqO1xuICAgIHZhciBJID0gbnVtZXJpYy5pZGVudGl0eShtKSwgSWksIElqO1xuICAgIHZhciBpLGosayx4O1xuICAgIGZvcihqPTA7ajxuOysraikge1xuICAgICAgICB2YXIgaTAgPSAtMTtcbiAgICAgICAgdmFyIHYwID0gLTE7XG4gICAgICAgIGZvcihpPWo7aSE9PW07KytpKSB7IGsgPSBhYnMoQVtpXVtqXSk7IGlmKGs+djApIHsgaTAgPSBpOyB2MCA9IGs7IH0gfVxuICAgICAgICBBaiA9IEFbaTBdOyBBW2kwXSA9IEFbal07IEFbal0gPSBBajtcbiAgICAgICAgSWogPSBJW2kwXTsgSVtpMF0gPSBJW2pdOyBJW2pdID0gSWo7XG4gICAgICAgIHggPSBBaltqXTtcbiAgICAgICAgZm9yKGs9ajtrIT09bjsrK2spICAgIEFqW2tdIC89IHg7IFxuICAgICAgICBmb3Ioaz1uLTE7ayE9PS0xOy0taykgSWpba10gLz0geDtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGlmKGkhPT1qKSB7XG4gICAgICAgICAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICAgICAgICAgIElpID0gSVtpXTtcbiAgICAgICAgICAgICAgICB4ID0gQWlbal07XG4gICAgICAgICAgICAgICAgZm9yKGs9aisxO2shPT1uOysraykgIEFpW2tdIC09IEFqW2tdKng7XG4gICAgICAgICAgICAgICAgZm9yKGs9bi0xO2s+MDstLWspIHsgSWlba10gLT0gSWpba10qeDsgLS1rOyBJaVtrXSAtPSBJaltrXSp4OyB9XG4gICAgICAgICAgICAgICAgaWYoaz09PTApIElpWzBdIC09IElqWzBdKng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEk7XG59XG5cbm51bWVyaWMuZGV0ID0gZnVuY3Rpb24gZGV0KHgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGlmKHMubGVuZ3RoICE9PSAyIHx8IHNbMF0gIT09IHNbMV0pIHsgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiBkZXQoKSBvbmx5IHdvcmtzIG9uIHNxdWFyZSBtYXRyaWNlcycpOyB9XG4gICAgdmFyIG4gPSBzWzBdLCByZXQgPSAxLGksaixrLEEgPSBudW1lcmljLmNsb25lKHgpLEFqLEFpLGFscGhhLHRlbXAsazEsazIsazM7XG4gICAgZm9yKGo9MDtqPG4tMTtqKyspIHtcbiAgICAgICAgaz1qO1xuICAgICAgICBmb3IoaT1qKzE7aTxuO2krKykgeyBpZihNYXRoLmFicyhBW2ldW2pdKSA+IE1hdGguYWJzKEFba11bal0pKSB7IGsgPSBpOyB9IH1cbiAgICAgICAgaWYoayAhPT0gaikge1xuICAgICAgICAgICAgdGVtcCA9IEFba107IEFba10gPSBBW2pdOyBBW2pdID0gdGVtcDtcbiAgICAgICAgICAgIHJldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBBaiA9IEFbal07XG4gICAgICAgIGZvcihpPWorMTtpPG47aSsrKSB7XG4gICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICBhbHBoYSA9IEFpW2pdL0FqW2pdO1xuICAgICAgICAgICAgZm9yKGs9aisxO2s8bi0xO2srPTIpIHtcbiAgICAgICAgICAgICAgICBrMSA9IGsrMTtcbiAgICAgICAgICAgICAgICBBaVtrXSAtPSBBaltrXSphbHBoYTtcbiAgICAgICAgICAgICAgICBBaVtrMV0gLT0gQWpbazFdKmFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoayE9PW4pIHsgQWlba10gLT0gQWpba10qYWxwaGE7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihBaltqXSA9PT0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXQgKj0gQWpbal07XG4gICAgfVxuICAgIHJldHVybiByZXQqQVtqXVtqXTtcbn1cblxubnVtZXJpYy50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoeCkge1xuICAgIHZhciBpLGosbSA9IHgubGVuZ3RoLG4gPSB4WzBdLmxlbmd0aCwgcmV0PUFycmF5KG4pLEEwLEExLEJqO1xuICAgIGZvcihqPTA7ajxuO2orKykgcmV0W2pdID0gQXJyYXkobSk7XG4gICAgZm9yKGk9bS0xO2k+PTE7aS09Mikge1xuICAgICAgICBBMSA9IHhbaV07XG4gICAgICAgIEEwID0geFtpLTFdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IEExW2pdOyBCaltpLTFdID0gQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSBBMVtqXTsgQmpbaS0xXSA9IEEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7XG4gICAgICAgICAgICBCaiA9IHJldFswXTsgQmpbaV0gPSBBMVswXTsgQmpbaS0xXSA9IEEwWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKGk9PT0wKSB7XG4gICAgICAgIEEwID0geFswXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICByZXRbal1bMF0gPSBBMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IEEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHJldFswXVswXSA9IEEwWzBdOyB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLm5lZ3RyYW5zcG9zZSA9IGZ1bmN0aW9uIG5lZ3RyYW5zcG9zZSh4KSB7XG4gICAgdmFyIGksaixtID0geC5sZW5ndGgsbiA9IHhbMF0ubGVuZ3RoLCByZXQ9QXJyYXkobiksQTAsQTEsQmo7XG4gICAgZm9yKGo9MDtqPG47aisrKSByZXRbal0gPSBBcnJheShtKTtcbiAgICBmb3IoaT1tLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIEExID0geFtpXTtcbiAgICAgICAgQTAgPSB4W2ktMV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gLUExW2pdOyBCaltpLTFdID0gLUEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gLUExW2pdOyBCaltpLTFdID0gLUEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7XG4gICAgICAgICAgICBCaiA9IHJldFswXTsgQmpbaV0gPSAtQTFbMF07IEJqW2ktMV0gPSAtQTBbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgQTAgPSB4WzBdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IC1BMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IC1BMFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihqPT09MCkgeyByZXRbMF1bMF0gPSAtQTBbMF07IH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5fcmFuZG9tID0gZnVuY3Rpb24gX3JhbmRvbShzLGspIHtcbiAgICB2YXIgaSxuPXNba10scmV0PUFycmF5KG4pLCBybmQ7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICBybmQgPSBNYXRoLnJhbmRvbTtcbiAgICAgICAgZm9yKGk9bi0xO2k+PTE7aS09Mikge1xuICAgICAgICAgICAgcmV0W2ldID0gcm5kKCk7XG4gICAgICAgICAgICByZXRbaS0xXSA9IHJuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGk9PT0wKSB7IHJldFswXSA9IHJuZCgpOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgcmV0W2ldID0gX3JhbmRvbShzLGsrMSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMucmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKHMpIHsgcmV0dXJuIG51bWVyaWMuX3JhbmRvbShzLDApOyB9XG5cbm51bWVyaWMubm9ybTIgPSBmdW5jdGlvbiBub3JtMih4KSB7IHJldHVybiBNYXRoLnNxcnQobnVtZXJpYy5ub3JtMlNxdWFyZWQoeCkpOyB9XG5cbm51bWVyaWMubGluc3BhY2UgPSBmdW5jdGlvbiBsaW5zcGFjZShhLGIsbikge1xuICAgIGlmKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSBuID0gTWF0aC5tYXgoTWF0aC5yb3VuZChiLWEpKzEsMSk7XG4gICAgaWYobjwyKSB7IHJldHVybiBuPT09MT9bYV06W107IH1cbiAgICB2YXIgaSxyZXQgPSBBcnJheShuKTtcbiAgICBuLS07XG4gICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSAoaSpiKyhuLWkpKmEpL247IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmdldEJsb2NrID0gZnVuY3Rpb24gZ2V0QmxvY2soeCxmcm9tLHRvKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KTtcbiAgICBmdW5jdGlvbiBmb28oeCxrKSB7XG4gICAgICAgIHZhciBpLGEgPSBmcm9tW2tdLCBuID0gdG9ba10tYSwgcmV0ID0gQXJyYXkobik7XG4gICAgICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgcmV0W2ldID0geFtpK2FdOyB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgcmV0W2ldID0gZm9vKHhbaSthXSxrKzEpOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oeCwwKTtcbn1cblxubnVtZXJpYy5zZXRCbG9jayA9IGZ1bmN0aW9uIHNldEJsb2NrKHgsZnJvbSx0byxCKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbSh4KTtcbiAgICBmdW5jdGlvbiBmb28oeCx5LGspIHtcbiAgICAgICAgdmFyIGksYSA9IGZyb21ba10sIG4gPSB0b1trXS1hO1xuICAgICAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IGZvcihpPW47aT49MDtpLS0pIHsgeFtpK2FdID0geVtpXTsgfSB9XG4gICAgICAgIGZvcihpPW47aT49MDtpLS0pIHsgZm9vKHhbaSthXSx5W2ldLGsrMSk7IH1cbiAgICB9XG4gICAgZm9vKHgsQiwwKTtcbiAgICByZXR1cm4geDtcbn1cblxubnVtZXJpYy5nZXRSYW5nZSA9IGZ1bmN0aW9uIGdldFJhbmdlKEEsSSxKKSB7XG4gICAgdmFyIG0gPSBJLmxlbmd0aCwgbiA9IEoubGVuZ3RoO1xuICAgIHZhciBpLGo7XG4gICAgdmFyIEIgPSBBcnJheShtKSwgQmksIEFJO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIEJbaV0gPSBBcnJheShuKTtcbiAgICAgICAgQmkgPSBCW2ldO1xuICAgICAgICBBSSA9IEFbSVtpXV07XG4gICAgICAgIGZvcihqPW4tMTtqIT09LTE7LS1qKSBCaVtqXSA9IEFJW0pbal1dO1xuICAgIH1cbiAgICByZXR1cm4gQjtcbn1cblxubnVtZXJpYy5ibG9ja01hdHJpeCA9IGZ1bmN0aW9uIGJsb2NrTWF0cml4KFgpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKFgpO1xuICAgIGlmKHMubGVuZ3RoPDQpIHJldHVybiBudW1lcmljLmJsb2NrTWF0cml4KFtYXSk7XG4gICAgdmFyIG09c1swXSxuPXNbMV0sTSxOLGksaixYaWo7XG4gICAgTSA9IDA7IE4gPSAwO1xuICAgIGZvcihpPTA7aTxtOysraSkgTSs9WFtpXVswXS5sZW5ndGg7XG4gICAgZm9yKGo9MDtqPG47KytqKSBOKz1YWzBdW2pdWzBdLmxlbmd0aDtcbiAgICB2YXIgWiA9IEFycmF5KE0pO1xuICAgIGZvcihpPTA7aTxNOysraSkgWltpXSA9IEFycmF5KE4pO1xuICAgIHZhciBJPTAsSixaSSxrLGwsWGlqaztcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgSj1OO1xuICAgICAgICBmb3Ioaj1uLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgWGlqID0gWFtpXVtqXTtcbiAgICAgICAgICAgIEogLT0gWGlqWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihrPVhpai5sZW5ndGgtMTtrIT09LTE7LS1rKSB7XG4gICAgICAgICAgICAgICAgWGlqayA9IFhpaltrXTtcbiAgICAgICAgICAgICAgICBaSSA9IFpbSStrXTtcbiAgICAgICAgICAgICAgICBmb3IobCA9IFhpamsubGVuZ3RoLTE7bCE9PS0xOy0tbCkgWklbSitsXSA9IFhpamtbbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSSArPSBYW2ldWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFo7XG59XG5cbm51bWVyaWMudGVuc29yID0gZnVuY3Rpb24gdGVuc29yKHgseSkge1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSByZXR1cm4gbnVtZXJpYy5tdWwoeCx5KTtcbiAgICB2YXIgczEgPSBudW1lcmljLmRpbSh4KSwgczIgPSBudW1lcmljLmRpbSh5KTtcbiAgICBpZihzMS5sZW5ndGggIT09IDEgfHwgczIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogdGVuc29yIHByb2R1Y3QgaXMgb25seSBkZWZpbmVkIGZvciB2ZWN0b3JzJyk7XG4gICAgfVxuICAgIHZhciBtID0gczFbMF0sIG4gPSBzMlswXSwgQSA9IEFycmF5KG0pLCBBaSwgaSxqLHhpO1xuICAgIGZvcihpPW0tMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFycmF5KG4pO1xuICAgICAgICB4aSA9IHhbaV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0zOy0taikge1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoaj49MCkgeyBBaVtqXSA9IHhpICogeVtqXTsgLS1qOyB9XG4gICAgICAgIEFbaV0gPSBBaTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbi8vIDMuIFRoZSBUZW5zb3IgdHlwZSBUXG5udW1lcmljLlQgPSBmdW5jdGlvbiBUKHgseSkgeyB0aGlzLnggPSB4OyB0aGlzLnkgPSB5OyB9XG5udW1lcmljLnQgPSBmdW5jdGlvbiB0KHgseSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh4LHkpOyB9XG5cbm51bWVyaWMuVGJpbm9wID0gZnVuY3Rpb24gVGJpbm9wKHJyLHJjLGNyLGNjLHNldHVwKSB7XG4gICAgdmFyIGlvID0gbnVtZXJpYy5pbmRleE9mO1xuICAgIGlmKHR5cGVvZiBzZXR1cCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgc2V0dXAgPSAnJztcbiAgICAgICAgZm9yKGsgaW4gbnVtZXJpYykge1xuICAgICAgICAgICAgaWYobnVtZXJpYy5oYXNPd25Qcm9wZXJ0eShrKSAmJiAocnIuaW5kZXhPZihrKT49MCB8fCByYy5pbmRleE9mKGspPj0wIHx8IGNyLmluZGV4T2Yoayk+PTAgfHwgY2MuaW5kZXhPZihrKT49MCkgJiYgay5sZW5ndGg+MSkge1xuICAgICAgICAgICAgICAgIHNldHVwICs9ICd2YXIgJytrKycgPSBudW1lcmljLicraysnO1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZ1bmN0aW9uKFsneSddLFxuICAgICAgICAgICAgJ3ZhciB4ID0gdGhpcztcXG4nK1xuICAgICAgICAgICAgJ2lmKCEoeSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIHsgeSA9IG5ldyBudW1lcmljLlQoeSk7IH1cXG4nK1xuICAgICAgICAgICAgc2V0dXArJ1xcbicrXG4gICAgICAgICAgICAnaWYoeC55KSB7JytcbiAgICAgICAgICAgICcgIGlmKHkueSkgeycrXG4gICAgICAgICAgICAnICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrY2MrJyk7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytjcisnKTtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ2lmKHkueSkge1xcbicrXG4gICAgICAgICAgICAnICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK3JjKycpO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoJytycisnKTtcXG4nXG4gICAgKTtcbn1cblxubnVtZXJpYy5ULnByb3RvdHlwZS5hZGQgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ2FkZCh4LngseS54KScsXG4gICAgICAgICdhZGQoeC54LHkueCkseS55JyxcbiAgICAgICAgJ2FkZCh4LngseS54KSx4LnknLFxuICAgICAgICAnYWRkKHgueCx5LngpLGFkZCh4LnkseS55KScpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5zdWIgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ3N1Yih4LngseS54KScsXG4gICAgICAgICdzdWIoeC54LHkueCksbmVnKHkueSknLFxuICAgICAgICAnc3ViKHgueCx5LngpLHgueScsXG4gICAgICAgICdzdWIoeC54LHkueCksc3ViKHgueSx5LnkpJyk7XG5udW1lcmljLlQucHJvdG90eXBlLm11bCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnbXVsKHgueCx5LngpJyxcbiAgICAgICAgJ211bCh4LngseS54KSxtdWwoeC54LHkueSknLFxuICAgICAgICAnbXVsKHgueCx5LngpLG11bCh4LnkseS54KScsXG4gICAgICAgICdzdWIobXVsKHgueCx5LngpLG11bCh4LnkseS55KSksYWRkKG11bCh4LngseS55KSxtdWwoeC55LHkueCkpJyk7XG5cbm51bWVyaWMuVC5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uIHJlY2lwcm9jYWwoKSB7XG4gICAgdmFyIG11bCA9IG51bWVyaWMubXVsLCBkaXYgPSBudW1lcmljLmRpdjtcbiAgICBpZih0aGlzLnkpIHtcbiAgICAgICAgdmFyIGQgPSBudW1lcmljLmFkZChtdWwodGhpcy54LHRoaXMueCksbXVsKHRoaXMueSx0aGlzLnkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGl2KHRoaXMueCxkKSxkaXYobnVtZXJpYy5uZWcodGhpcy55KSxkKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVChkaXYoMSx0aGlzLngpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2KHkpIHtcbiAgICBpZighKHkgaW5zdGFuY2VvZiBudW1lcmljLlQpKSB5ID0gbmV3IG51bWVyaWMuVCh5KTtcbiAgICBpZih5LnkpIHsgcmV0dXJuIHRoaXMubXVsKHkucmVjaXByb2NhbCgpKTsgfVxuICAgIHZhciBkaXYgPSBudW1lcmljLmRpdjtcbiAgICBpZih0aGlzLnkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoZGl2KHRoaXMueCx5LngpLGRpdih0aGlzLnkseS54KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LHkueCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5kb3QgPSBudW1lcmljLlRiaW5vcChcbiAgICAgICAgJ2RvdCh4LngseS54KScsXG4gICAgICAgICdkb3QoeC54LHkueCksZG90KHgueCx5LnkpJyxcbiAgICAgICAgJ2RvdCh4LngseS54KSxkb3QoeC55LHkueCknLFxuICAgICAgICAnc3ViKGRvdCh4LngseS54KSxkb3QoeC55LHkueSkpLGFkZChkb3QoeC54LHkueSksZG90KHgueSx5LngpKSdcbiAgICAgICAgKTtcbm51bWVyaWMuVC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgIHZhciB0ID0gbnVtZXJpYy50cmFuc3Bvc2UsIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpLHQoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnRyYW5zanVnYXRlID0gZnVuY3Rpb24gdHJhbnNqdWdhdGUoKSB7XG4gICAgdmFyIHQgPSBudW1lcmljLnRyYW5zcG9zZSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCksbnVtZXJpYy5uZWd0cmFuc3Bvc2UoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSk7XG59XG5udW1lcmljLlR1bm9wID0gZnVuY3Rpb24gVHVub3AocixjLHMpIHtcbiAgICBpZih0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikgeyBzID0gJyc7IH1cbiAgICByZXR1cm4gRnVuY3Rpb24oXG4gICAgICAgICAgICAndmFyIHggPSB0aGlzO1xcbicrXG4gICAgICAgICAgICBzKydcXG4nK1xuICAgICAgICAgICAgJ2lmKHgueSkgeycrXG4gICAgICAgICAgICAnICAnK2MrJztcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgcisnO1xcbidcbiAgICApO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmV4cCA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChleCknLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobXVsKGNvcyh4LnkpLGV4KSxtdWwoc2luKHgueSksZXgpKScsXG4gICAgICAgICd2YXIgZXggPSBudW1lcmljLmV4cCh4LngpLCBjb3MgPSBudW1lcmljLmNvcywgc2luID0gbnVtZXJpYy5zaW4sIG11bCA9IG51bWVyaWMubXVsOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5jb25qID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKHgueCk7JyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKHgueCxudW1lcmljLm5lZyh4LnkpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubmVnID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG5lZyh4LngpKTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobmVnKHgueCksbmVnKHgueSkpOycsXG4gICAgICAgICd2YXIgbmVnID0gbnVtZXJpYy5uZWc7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLnNpbiA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLnNpbih4LngpKScsXG4gICAgICAgICdyZXR1cm4geC5leHAoKS5zdWIoeC5uZWcoKS5leHAoKSkuZGl2KG5ldyBudW1lcmljLlQoMCwyKSk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmNvcyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmNvcyh4LngpKScsXG4gICAgICAgICdyZXR1cm4geC5leHAoKS5hZGQoeC5uZWcoKS5leHAoKSkuZGl2KDIpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5hYnMgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5hYnMoeC54KSk7JyxcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuc3FydChudW1lcmljLmFkZChtdWwoeC54LHgueCksbXVsKHgueSx4LnkpKSkpOycsXG4gICAgICAgICd2YXIgbXVsID0gbnVtZXJpYy5tdWw7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmxvZyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmxvZyh4LngpKTsnLFxuICAgICAgICAndmFyIHRoZXRhID0gbmV3IG51bWVyaWMuVChudW1lcmljLmF0YW4yKHgueSx4LngpKSwgciA9IHguYWJzKCk7XFxuJytcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMubG9nKHIueCksdGhldGEueCk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLm5vcm0yID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBudW1lcmljLm5vcm0yKHgueCk7JyxcbiAgICAgICAgJ3ZhciBmID0gbnVtZXJpYy5ub3JtMlNxdWFyZWQ7XFxuJytcbiAgICAgICAgJ3JldHVybiBNYXRoLnNxcnQoZih4LngpK2YoeC55KSk7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmludiA9IGZ1bmN0aW9uIGludigpIHtcbiAgICB2YXIgQSA9IHRoaXM7XG4gICAgaWYodHlwZW9mIEEueSA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmludihBLngpKTsgfVxuICAgIHZhciBuID0gQS54Lmxlbmd0aCwgaSwgaiwgaztcbiAgICB2YXIgUnggPSBudW1lcmljLmlkZW50aXR5KG4pLFJ5ID0gbnVtZXJpYy5yZXAoW24sbl0sMCk7XG4gICAgdmFyIEF4ID0gbnVtZXJpYy5jbG9uZShBLngpLCBBeSA9IG51bWVyaWMuY2xvbmUoQS55KTtcbiAgICB2YXIgQWl4LCBBaXksIEFqeCwgQWp5LCBSaXgsIFJpeSwgUmp4LCBSank7XG4gICAgdmFyIGksaixrLGQsZDEsYXgsYXksYngsYnksdGVtcDtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgYXggPSBBeFtpXVtpXTsgYXkgPSBBeVtpXVtpXTtcbiAgICAgICAgZCA9IGF4KmF4K2F5KmF5O1xuICAgICAgICBrID0gaTtcbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGF4ID0gQXhbal1baV07IGF5ID0gQXlbal1baV07XG4gICAgICAgICAgICBkMSA9IGF4KmF4K2F5KmF5O1xuICAgICAgICAgICAgaWYoZDEgPiBkKSB7IGs9ajsgZCA9IGQxOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoayE9PWkpIHtcbiAgICAgICAgICAgIHRlbXAgPSBBeFtpXTsgQXhbaV0gPSBBeFtrXTsgQXhba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IEF5W2ldOyBBeVtpXSA9IEF5W2tdOyBBeVtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gUnhbaV07IFJ4W2ldID0gUnhba107IFJ4W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBSeVtpXTsgUnlbaV0gPSBSeVtrXTsgUnlba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIEFpeCA9IEF4W2ldOyBBaXkgPSBBeVtpXTtcbiAgICAgICAgUml4ID0gUnhbaV07IFJpeSA9IFJ5W2ldO1xuICAgICAgICBheCA9IEFpeFtpXTsgYXkgPSBBaXlbaV07XG4gICAgICAgIGZvcihqPWkrMTtqPG47aisrKSB7XG4gICAgICAgICAgICBieCA9IEFpeFtqXTsgYnkgPSBBaXlbal07XG4gICAgICAgICAgICBBaXhbal0gPSAoYngqYXgrYnkqYXkpL2Q7XG4gICAgICAgICAgICBBaXlbal0gPSAoYnkqYXgtYngqYXkpL2Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgICAgICBieCA9IFJpeFtqXTsgYnkgPSBSaXlbal07XG4gICAgICAgICAgICBSaXhbal0gPSAoYngqYXgrYnkqYXkpL2Q7XG4gICAgICAgICAgICBSaXlbal0gPSAoYnkqYXgtYngqYXkpL2Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIEFqeCA9IEF4W2pdOyBBankgPSBBeVtqXTtcbiAgICAgICAgICAgIFJqeCA9IFJ4W2pdOyBSankgPSBSeVtqXTtcbiAgICAgICAgICAgIGF4ID0gQWp4W2ldOyBheSA9IEFqeVtpXTtcbiAgICAgICAgICAgIGZvcihrPWkrMTtrPG47aysrKSB7XG4gICAgICAgICAgICAgICAgYnggPSBBaXhba107IGJ5ID0gQWl5W2tdO1xuICAgICAgICAgICAgICAgIEFqeFtrXSAtPSBieCpheC1ieSpheTtcbiAgICAgICAgICAgICAgICBBanlba10gLT0gYnkqYXgrYngqYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioaz0wO2s8bjtrKyspIHtcbiAgICAgICAgICAgICAgICBieCA9IFJpeFtrXTsgYnkgPSBSaXlba107XG4gICAgICAgICAgICAgICAgUmp4W2tdIC09IGJ4KmF4LWJ5KmF5O1xuICAgICAgICAgICAgICAgIFJqeVtrXSAtPSBieSpheCtieCpheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT1uLTE7aT4wO2ktLSkge1xuICAgICAgICBSaXggPSBSeFtpXTsgUml5ID0gUnlbaV07XG4gICAgICAgIGZvcihqPWktMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgUmp4ID0gUnhbal07IFJqeSA9IFJ5W2pdO1xuICAgICAgICAgICAgYXggPSBBeFtqXVtpXTsgYXkgPSBBeVtqXVtpXTtcbiAgICAgICAgICAgIGZvcihrPW4tMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgICAgIGJ4ID0gUml4W2tdOyBieSA9IFJpeVtrXTtcbiAgICAgICAgICAgICAgICBSanhba10gLT0gYXgqYnggLSBheSpieTtcbiAgICAgICAgICAgICAgICBSanlba10gLT0gYXgqYnkgKyBheSpieDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChSeCxSeSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGsgPSAwLCBpaywgbiA9IGkubGVuZ3RoO1xuICAgIGlmKHkpIHtcbiAgICAgICAgd2hpbGUoazxuKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeCx5KTtcbiAgICB9XG4gICAgd2hpbGUoazxuKSB7XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHgpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSx2KSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGsgPSAwLCBpaywgbiA9IGkubGVuZ3RoLCB2eCA9IHYueCwgdnkgPSB2Lnk7XG4gICAgaWYobj09PTApIHtcbiAgICAgICAgaWYodnkpIHsgdGhpcy55ID0gdnk7IH1cbiAgICAgICAgZWxzZSBpZih5KSB7IHRoaXMueSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYodnkpIHtcbiAgICAgICAgaWYoeSkgeyAvKiBvayAqLyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHgpLDApO1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeFtpa10gPSB2eDtcbiAgICAgICAgeVtpa10gPSB2eTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBpayA9IGlba107XG4gICAgICAgIHhbaWtdID0gdng7XG4gICAgICAgIGlmKHZ4IGluc3RhbmNlb2YgQXJyYXkpIHlbaWtdID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0odngpLDApO1xuICAgICAgICBlbHNlIHlbaWtdID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIGlrID0gaVtrXTtcbiAgICB4W2lrXSA9IHZ4O1xuICAgIHJldHVybiB0aGlzO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24gZ2V0Um93cyhpMCxpMSkge1xuICAgIHZhciBuID0gaTEtaTArMSwgajtcbiAgICB2YXIgcnggPSBBcnJheShuKSwgcnksIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ4W2otaTBdID0geFtqXTsgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgcnkgPSBBcnJheShuKTtcbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2otaTBdID0geVtqXTsgfVxuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVChyeCxyeSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHJ4KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0Um93cyA9IGZ1bmN0aW9uIHNldFJvd3MoaTAsaTEsQSkge1xuICAgIHZhciBqO1xuICAgIHZhciByeCA9IHRoaXMueCwgcnkgPSB0aGlzLnksIHggPSBBLngsIHkgPSBBLnk7XG4gICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ4W2pdID0geFtqLWkwXTsgfVxuICAgIGlmKHkpIHtcbiAgICAgICAgaWYoIXJ5KSB7IHJ5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0ocngpLDApOyB0aGlzLnkgPSByeTsgfVxuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbal0gPSB5W2otaTBdOyB9XG4gICAgfSBlbHNlIGlmKHJ5KSB7XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqXSA9IG51bWVyaWMucmVwKFt4W2otaTBdLmxlbmd0aF0sMCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uIGdldFJvdyhrKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVCh4W2tdLHlba10pOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeFtrXSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uIHNldFJvdyhpLHYpIHtcbiAgICB2YXIgcnggPSB0aGlzLngsIHJ5ID0gdGhpcy55LCB4ID0gdi54LCB5ID0gdi55O1xuICAgIHJ4W2ldID0geDtcbiAgICBpZih5KSB7XG4gICAgICAgIGlmKCFyeSkgeyByeSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHJ4KSwwKTsgdGhpcy55ID0gcnk7IH1cbiAgICAgICAgcnlbaV0gPSB5O1xuICAgIH0gZWxzZSBpZihyeSkge1xuICAgICAgICByeSA9IG51bWVyaWMucmVwKFt4Lmxlbmd0aF0sMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24gZ2V0QmxvY2soZnJvbSx0bykge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBiID0gbnVtZXJpYy5nZXRCbG9jaztcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKGIoeCxmcm9tLHRvKSxiKHksZnJvbSx0bykpOyB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoYih4LGZyb20sdG8pKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0QmxvY2sgPSBmdW5jdGlvbiBzZXRCbG9jayhmcm9tLHRvLEEpIHtcbiAgICBpZighKEEgaW5zdGFuY2VvZiBudW1lcmljLlQpKSBBID0gbmV3IG51bWVyaWMuVChBKTtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgYiA9IG51bWVyaWMuc2V0QmxvY2ssIEF4ID0gQS54LCBBeSA9IEEueTtcbiAgICBpZihBeSkge1xuICAgICAgICBpZigheSkgeyB0aGlzLnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh0aGlzKSwwKTsgeSA9IHRoaXMueTsgfVxuICAgICAgICBiKHgsZnJvbSx0byxBeCk7XG4gICAgICAgIGIoeSxmcm9tLHRvLEF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGIoeCxmcm9tLHRvLEF4KTtcbiAgICBpZih5KSBiKHksZnJvbSx0byxudW1lcmljLnJlcChudW1lcmljLmRpbShBeCksMCkpO1xufVxubnVtZXJpYy5ULnJlcCA9IGZ1bmN0aW9uIHJlcChzLHYpIHtcbiAgICB2YXIgVCA9IG51bWVyaWMuVDtcbiAgICBpZighKHYgaW5zdGFuY2VvZiBUKSkgdiA9IG5ldyBUKHYpO1xuICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCByID0gbnVtZXJpYy5yZXA7XG4gICAgaWYoeSkgcmV0dXJuIG5ldyBUKHIocyx4KSxyKHMseSkpO1xuICAgIHJldHVybiBuZXcgVChyKHMseCkpO1xufVxubnVtZXJpYy5ULmRpYWcgPSBmdW5jdGlvbiBkaWFnKGQpIHtcbiAgICBpZighKGQgaW5zdGFuY2VvZiBudW1lcmljLlQpKSBkID0gbmV3IG51bWVyaWMuVChkKTtcbiAgICB2YXIgeCA9IGQueCwgeSA9IGQueSwgZGlhZyA9IG51bWVyaWMuZGlhZztcbiAgICBpZih5KSByZXR1cm4gbmV3IG51bWVyaWMuVChkaWFnKHgpLGRpYWcoeSkpO1xuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpYWcoeCkpO1xufVxubnVtZXJpYy5ULmVpZyA9IGZ1bmN0aW9uIGVpZygpIHtcbiAgICBpZih0aGlzLnkpIHsgdGhyb3cgbmV3IEVycm9yKCdlaWc6IG5vdCBpbXBsZW1lbnRlZCBmb3IgY29tcGxleCBtYXRyaWNlcy4nKTsgfVxuICAgIHJldHVybiBudW1lcmljLmVpZyh0aGlzLngpO1xufVxubnVtZXJpYy5ULmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmlkZW50aXR5KG4pKTsgfVxubnVtZXJpYy5ULnByb3RvdHlwZS5nZXREaWFnID0gZnVuY3Rpb24gZ2V0RGlhZygpIHtcbiAgICB2YXIgbiA9IG51bWVyaWM7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG4gICAgaWYoeSkgeyByZXR1cm4gbmV3IG4uVChuLmdldERpYWcoeCksbi5nZXREaWFnKHkpKTsgfVxuICAgIHJldHVybiBuZXcgbi5UKG4uZ2V0RGlhZyh4KSk7XG59XG5cbi8vIDQuIEVpZ2VudmFsdWVzIG9mIHJlYWwgbWF0cmljZXNcblxubnVtZXJpYy5ob3VzZSA9IGZ1bmN0aW9uIGhvdXNlKHgpIHtcbiAgICB2YXIgdiA9IG51bWVyaWMuY2xvbmUoeCk7XG4gICAgdmFyIHMgPSB4WzBdID49IDAgPyAxIDogLTE7XG4gICAgdmFyIGFscGhhID0gcypudW1lcmljLm5vcm0yKHgpO1xuICAgIHZbMF0gKz0gYWxwaGE7XG4gICAgdmFyIGZvbyA9IG51bWVyaWMubm9ybTIodik7XG4gICAgaWYoZm9vID09PSAwKSB7IC8qIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gKi8gdGhyb3cgbmV3IEVycm9yKCdlaWc6IGludGVybmFsIGVycm9yJyk7IH1cbiAgICByZXR1cm4gbnVtZXJpYy5kaXYodixmb28pO1xufVxuXG5udW1lcmljLnRvVXBwZXJIZXNzZW5iZXJnID0gZnVuY3Rpb24gdG9VcHBlckhlc3NlbmJlcmcobWUpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKG1lKTtcbiAgICBpZihzLmxlbmd0aCAhPT0gMiB8fCBzWzBdICE9PSBzWzFdKSB7IHRocm93IG5ldyBFcnJvcignbnVtZXJpYzogdG9VcHBlckhlc3NlbmJlcmcoKSBvbmx5IHdvcmtzIG9uIHNxdWFyZSBtYXRyaWNlcycpOyB9XG4gICAgdmFyIG0gPSBzWzBdLCBpLGosayx4LHYsQSA9IG51bWVyaWMuY2xvbmUobWUpLEIsQyxBaSxDaSxRID0gbnVtZXJpYy5pZGVudGl0eShtKSxRaTtcbiAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICB4ID0gQXJyYXkobS1qLTEpO1xuICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyB4W2ktai0xXSA9IEFbaV1bal07IH1cbiAgICAgICAgaWYobnVtZXJpYy5ub3JtMih4KT4wKSB7XG4gICAgICAgICAgICB2ID0gbnVtZXJpYy5ob3VzZSh4KTtcbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEEsW2orMSxqXSxbbS0xLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBBaSA9IEFbaV07IENpID0gQ1tpLWotMV07IGZvcihrPWo7azxtO2srKykgQWlba10gLT0gMipDaVtrLWpdOyB9XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhBLFswLGorMV0sW20tMSxtLTFdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEFpID0gQVtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz1qKzE7azxtO2srKykgQWlba10gLT0gMipDaVtrLWotMV07IH1cbiAgICAgICAgICAgIEIgPSBBcnJheShtLWotMSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgQltpLWotMV0gPSBRW2ldO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpLWotMV07IGZvcihrPTA7azxtO2srKykgUWlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7SDpBLCBROlF9O1xufVxuXG5udW1lcmljLmVwc2lsb24gPSAyLjIyMDQ0NjA0OTI1MDMxM2UtMTY7XG5cbm51bWVyaWMuUVJGcmFuY2lzID0gZnVuY3Rpb24oSCxtYXhpdGVyKSB7XG4gICAgaWYodHlwZW9mIG1heGl0ZXIgPT09IFwidW5kZWZpbmVkXCIpIHsgbWF4aXRlciA9IDEwMDAwOyB9XG4gICAgSCA9IG51bWVyaWMuY2xvbmUoSCk7XG4gICAgdmFyIEgwID0gbnVtZXJpYy5jbG9uZShIKTtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEgpLG09c1swXSx4LHYsYSxiLGMsZCxkZXQsdHIsIEhsb2MsIFEgPSBudW1lcmljLmlkZW50aXR5KG0pLCBRaSwgSGksIEIsIEMsIENpLGksaixrLGl0ZXI7XG4gICAgaWYobTwzKSB7IHJldHVybiB7UTpRLCBCOlsgWzAsbS0xXSBdfTsgfVxuICAgIHZhciBlcHNpbG9uID0gbnVtZXJpYy5lcHNpbG9uO1xuICAgIGZvcihpdGVyPTA7aXRlcjxtYXhpdGVyO2l0ZXIrKykge1xuICAgICAgICBmb3Ioaj0wO2o8bS0xO2orKykge1xuICAgICAgICAgICAgaWYoTWF0aC5hYnMoSFtqKzFdW2pdKSA8IGVwc2lsb24qKE1hdGguYWJzKEhbal1bal0pK01hdGguYWJzKEhbaisxXVtqKzFdKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgUUgxID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFswLDBdLFtqLGpdKSxtYXhpdGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgUUgyID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFtqKzEsaisxXSxbbS0xLG0tMV0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgIEIgPSBBcnJheShqKzEpO1xuICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9ajtpKyspIHsgQltpXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgxLlEsQik7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1qO2krKykgeyBRW2ldID0gQ1tpXTsgfVxuICAgICAgICAgICAgICAgIEIgPSBBcnJheShtLWotMSk7XG4gICAgICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgQltpLWotMV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMi5RLEIpO1xuICAgICAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IFFbaV0gPSBDW2ktai0xXTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7UTpRLEI6UUgxLkIuY29uY2F0KG51bWVyaWMuYWRkKFFIMi5CLGorMSkpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhID0gSFttLTJdW20tMl07IGIgPSBIW20tMl1bbS0xXTtcbiAgICAgICAgYyA9IEhbbS0xXVttLTJdOyBkID0gSFttLTFdW20tMV07XG4gICAgICAgIHRyID0gYStkO1xuICAgICAgICBkZXQgPSAoYSpkLWIqYyk7XG4gICAgICAgIEhsb2MgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLDBdLCBbMiwyXSk7XG4gICAgICAgIGlmKHRyKnRyPj00KmRldCkge1xuICAgICAgICAgICAgdmFyIHMxLHMyO1xuICAgICAgICAgICAgczEgPSAwLjUqKHRyK01hdGguc3FydCh0cip0ci00KmRldCkpO1xuICAgICAgICAgICAgczIgPSAwLjUqKHRyLU1hdGguc3FydCh0cip0ci00KmRldCkpO1xuICAgICAgICAgICAgSGxvYyA9IG51bWVyaWMuYWRkKG51bWVyaWMuc3ViKG51bWVyaWMuZG90KEhsb2MsSGxvYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5tdWwoSGxvYyxzMStzMikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbM10sczEqczIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIbG9jID0gbnVtZXJpYy5hZGQobnVtZXJpYy5zdWIobnVtZXJpYy5kb3QoSGxvYyxIbG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLm11bChIbG9jLHRyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFszXSxkZXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IFtIbG9jWzBdWzBdLEhsb2NbMV1bMF0sSGxvY1syXVswXV07XG4gICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICBCID0gW0hbMF0sSFsxXSxIWzJdXTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgIGZvcihpPTA7aTwzO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPG07aysrKSBIaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLDBdLFttLTEsMl0pO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IobnVtZXJpYy5kb3QoQix2KSx2KTtcbiAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8MztrKyspIEhpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgQiA9IFtRWzBdLFFbMV0sUVsyXV07XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICBmb3IoaT0wO2k8MztpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azxtO2srKykgUWlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICB2YXIgSjtcbiAgICAgICAgZm9yKGo9MDtqPG0tMjtqKyspIHtcbiAgICAgICAgICAgIGZvcihrPWo7azw9aisxO2srKykge1xuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKEhbaysxXVtrXSkgPCBlcHNpbG9uKihNYXRoLmFicyhIW2tdW2tdKStNYXRoLmFicyhIW2srMV1baysxXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBRSDEgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsWzAsMF0sW2ssa10pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgUUgyID0gbnVtZXJpYy5RUkZyYW5jaXMobnVtZXJpYy5nZXRCbG9jayhILFtrKzEsaysxXSxbbS0xLG0tMV0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBCID0gQXJyYXkoaysxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1rO2krKykgeyBCW2ldID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgxLlEsQik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTw9aztpKyspIHsgUVtpXSA9IENbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQiA9IEFycmF5KG0tay0xKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9aysxO2k8bTtpKyspIHsgQltpLWstMV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDIuUSxCKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9aysxO2k8bTtpKyspIHsgUVtpXSA9IENbaS1rLTFdOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7UTpRLEI6UUgxLkIuY29uY2F0KG51bWVyaWMuYWRkKFFIMi5CLGsrMSkpfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBKID0gTWF0aC5taW4obS0xLGorMyk7XG4gICAgICAgICAgICB4ID0gQXJyYXkoSi1qKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgeyB4W2ktai0xXSA9IEhbaV1bal07IH1cbiAgICAgICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgW2orMSxqXSxbSixtLTFdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9ajtrPG07aysrKSBIaVtrXSAtPSAyKkNpW2stal07IH1cbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEgsIFswLGorMV0sW20tMSxKXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IobnVtZXJpYy5kb3QoQix2KSx2KTtcbiAgICAgICAgICAgIGZvcihpPTA7aTxtO2krKykgeyBIaSA9IEhbaV07IENpID0gQ1tpXTsgZm9yKGs9aisxO2s8PUo7aysrKSBIaVtrXSAtPSAyKkNpW2stai0xXTsgfVxuICAgICAgICAgICAgQiA9IEFycmF5KEotaik7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIEJbaS1qLTFdID0gUVtpXTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcih2LG51bWVyaWMuZG90KHYsQikpO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiBlaWdlbnZhbHVlIGl0ZXJhdGlvbiBkb2VzIG5vdCBjb252ZXJnZSAtLSBpbmNyZWFzZSBtYXhpdGVyPycpO1xufVxuXG5udW1lcmljLmVpZyA9IGZ1bmN0aW9uIGVpZyhBLG1heGl0ZXIpIHtcbiAgICB2YXIgUUggPSBudW1lcmljLnRvVXBwZXJIZXNzZW5iZXJnKEEpO1xuICAgIHZhciBRQiA9IG51bWVyaWMuUVJGcmFuY2lzKFFILkgsbWF4aXRlcik7XG4gICAgdmFyIFQgPSBudW1lcmljLlQ7XG4gICAgdmFyIG4gPSBBLmxlbmd0aCxpLGssZmxhZyA9IGZhbHNlLEIgPSBRQi5CLEggPSBudW1lcmljLmRvdChRQi5RLG51bWVyaWMuZG90KFFILkgsbnVtZXJpYy50cmFuc3Bvc2UoUUIuUSkpKTtcbiAgICB2YXIgUSA9IG5ldyBUKG51bWVyaWMuZG90KFFCLlEsUUguUSkpLFEwO1xuICAgIHZhciBtID0gQi5sZW5ndGgsajtcbiAgICB2YXIgYSxiLGMsZCxwMSxwMixkaXNjLHgseSxwLHEsbjEsbjI7XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgZm9yKGs9MDtrPG07aysrKSB7XG4gICAgICAgIGkgPSBCW2tdWzBdO1xuICAgICAgICBpZihpID09PSBCW2tdWzFdKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqID0gaSsxO1xuICAgICAgICAgICAgYSA9IEhbaV1baV07XG4gICAgICAgICAgICBiID0gSFtpXVtqXTtcbiAgICAgICAgICAgIGMgPSBIW2pdW2ldO1xuICAgICAgICAgICAgZCA9IEhbal1bal07XG4gICAgICAgICAgICBpZihiID09PSAwICYmIGMgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgcDEgPSAtYS1kO1xuICAgICAgICAgICAgcDIgPSBhKmQtYipjO1xuICAgICAgICAgICAgZGlzYyA9IHAxKnAxLTQqcDI7XG4gICAgICAgICAgICBpZihkaXNjPj0wKSB7XG4gICAgICAgICAgICAgICAgaWYocDE8MCkgeCA9IC0wLjUqKHAxLXNxcnQoZGlzYykpO1xuICAgICAgICAgICAgICAgIGVsc2UgICAgIHggPSAtMC41KihwMStzcXJ0KGRpc2MpKTtcbiAgICAgICAgICAgICAgICBuMSA9IChhLXgpKihhLXgpK2IqYjtcbiAgICAgICAgICAgICAgICBuMiA9IGMqYysoZC14KSooZC14KTtcbiAgICAgICAgICAgICAgICBpZihuMT5uMikge1xuICAgICAgICAgICAgICAgICAgICBuMSA9IHNxcnQobjEpO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGEteCkvbjE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBiL24xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gc3FydChuMik7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjL24yO1xuICAgICAgICAgICAgICAgICAgICBxID0gKGQteCkvbjI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFEwID0gbmV3IFQoW1txLC1wXSxbcCxxXV0pO1xuICAgICAgICAgICAgICAgIFEuc2V0Um93cyhpLGosUTAuZG90KFEuZ2V0Um93cyhpLGopKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSAtMC41KnAxO1xuICAgICAgICAgICAgICAgIHkgPSAwLjUqc3FydCgtZGlzYyk7XG4gICAgICAgICAgICAgICAgbjEgPSAoYS14KSooYS14KStiKmI7XG4gICAgICAgICAgICAgICAgbjIgPSBjKmMrKGQteCkqKGQteCk7XG4gICAgICAgICAgICAgICAgaWYobjE+bjIpIHtcbiAgICAgICAgICAgICAgICAgICAgbjEgPSBzcXJ0KG4xK3kqeSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYS14KS9uMTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IGIvbjE7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB5IC89IG4xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gc3FydChuMit5KnkpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYy9uMjtcbiAgICAgICAgICAgICAgICAgICAgcSA9IChkLXgpL24yO1xuICAgICAgICAgICAgICAgICAgICB4ID0geS9uMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFEwID0gbmV3IFQoW1txLC1wXSxbcCxxXV0sW1t4LHldLFt5LC14XV0pO1xuICAgICAgICAgICAgICAgIFEuc2V0Um93cyhpLGosUTAuZG90KFEuZ2V0Um93cyhpLGopKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIFIgPSBRLmRvdChBKS5kb3QoUS50cmFuc2p1Z2F0ZSgpKSwgbiA9IEEubGVuZ3RoLCBFID0gbnVtZXJpYy5ULmlkZW50aXR5KG4pO1xuICAgIGZvcihqPTA7ajxuO2orKykge1xuICAgICAgICBpZihqPjApIHtcbiAgICAgICAgICAgIGZvcihrPWotMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgICAgIHZhciBSayA9IFIuZ2V0KFtrLGtdKSwgUmogPSBSLmdldChbaixqXSk7XG4gICAgICAgICAgICAgICAgaWYobnVtZXJpYy5uZXEoUmsueCxSai54KSB8fCBudW1lcmljLm5lcShSay55LFJqLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBSLmdldFJvdyhrKS5nZXRCbG9jayhba10sW2otMV0pO1xuICAgICAgICAgICAgICAgICAgICB5ID0gRS5nZXRSb3coaikuZ2V0QmxvY2soW2tdLFtqLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgRS5zZXQoW2osa10sKFIuZ2V0KFtrLGpdKS5uZWcoKS5zdWIoeC5kb3QoeSkpKS5kaXYoUmsuc3ViKFJqKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEUuc2V0Um93KGosRS5nZXRSb3coaykpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgIHggPSBFLmdldFJvdyhqKTtcbiAgICAgICAgRS5zZXRSb3coaix4LmRpdih4Lm5vcm0yKCkpKTtcbiAgICB9XG4gICAgRSA9IEUudHJhbnNwb3NlKCk7XG4gICAgRSA9IFEudHJhbnNqdWdhdGUoKS5kb3QoRSk7XG4gICAgcmV0dXJuIHsgbGFtYmRhOlIuZ2V0RGlhZygpLCBFOkUgfTtcbn07XG5cbi8vIDUuIENvbXByZXNzZWQgQ29sdW1uIFN0b3JhZ2UgbWF0cmljZXNcbm51bWVyaWMuY2NzU3BhcnNlID0gZnVuY3Rpb24gY2NzU3BhcnNlKEEpIHtcbiAgICB2YXIgbSA9IEEubGVuZ3RoLG4sZm9vLCBpLGosIGNvdW50cyA9IFtdO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGZvbyA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIGZvbykge1xuICAgICAgICAgICAgaiA9IHBhcnNlSW50KGopO1xuICAgICAgICAgICAgd2hpbGUoaj49Y291bnRzLmxlbmd0aCkgY291bnRzW2NvdW50cy5sZW5ndGhdID0gMDtcbiAgICAgICAgICAgIGlmKGZvb1tqXSE9PTApIGNvdW50c1tqXSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBuID0gY291bnRzLmxlbmd0aDtcbiAgICB2YXIgQWkgPSBBcnJheShuKzEpO1xuICAgIEFpWzBdID0gMDtcbiAgICBmb3IoaT0wO2k8bjsrK2kpIEFpW2krMV0gPSBBaVtpXSArIGNvdW50c1tpXTtcbiAgICB2YXIgQWogPSBBcnJheShBaVtuXSksIEF2ID0gQXJyYXkoQWlbbl0pO1xuICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGZvbyA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIGZvbykge1xuICAgICAgICAgICAgaWYoZm9vW2pdIT09MCkge1xuICAgICAgICAgICAgICAgIGNvdW50c1tqXS0tO1xuICAgICAgICAgICAgICAgIEFqW0FpW2pdK2NvdW50c1tqXV0gPSBpO1xuICAgICAgICAgICAgICAgIEF2W0FpW2pdK2NvdW50c1tqXV0gPSBmb29bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtBaSxBaixBdl07XG59XG5udW1lcmljLmNjc0Z1bGwgPSBmdW5jdGlvbiBjY3NGdWxsKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSwgcyA9IG51bWVyaWMuY2NzRGltKEEpLCBtID0gc1swXSwgbiA9IHNbMV0sIGksaixqMCxqMSxrO1xuICAgIHZhciBCID0gbnVtZXJpYy5yZXAoW20sbl0sMCk7XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGowID0gQWlbaV07XG4gICAgICAgIGoxID0gQWlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHsgQltBaltqXV1baV0gPSBBdltqXTsgfVxuICAgIH1cbiAgICByZXR1cm4gQjtcbn1cbm51bWVyaWMuY2NzVFNvbHZlID0gZnVuY3Rpb24gY2NzVFNvbHZlKEEsYix4LGJqLHhqKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sbSA9IEFpLmxlbmd0aC0xLCBtYXggPSBNYXRoLm1heCxuPTA7XG4gICAgaWYodHlwZW9mIGJqID09PSBcInVuZGVmaW5lZFwiKSB4ID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIGlmKHR5cGVvZiBiaiA9PT0gXCJ1bmRlZmluZWRcIikgYmogPSBudW1lcmljLmxpbnNwYWNlKDAseC5sZW5ndGgtMSk7XG4gICAgaWYodHlwZW9mIHhqID09PSBcInVuZGVmaW5lZFwiKSB4aiA9IFtdO1xuICAgIGZ1bmN0aW9uIGRmcyhqKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZih4W2pdICE9PSAwKSByZXR1cm47XG4gICAgICAgIHhbal0gPSAxO1xuICAgICAgICBmb3Ioaz1BaVtqXTtrPEFpW2orMV07KytrKSBkZnMoQWpba10pO1xuICAgICAgICB4altuXSA9IGo7XG4gICAgICAgICsrbjtcbiAgICB9XG4gICAgdmFyIGksaixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBmb3IoaT1iai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGRmcyhialtpXSk7IH1cbiAgICB4ai5sZW5ndGggPSBuO1xuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgeFt4altpXV0gPSAwOyB9XG4gICAgZm9yKGk9YmoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyBqID0gYmpbaV07IHhbal0gPSBiW2pdOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBqID0geGpbaV07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gbWF4KEFpW2orMV0sajApO1xuICAgICAgICBmb3Ioaz1qMDtrIT09ajE7KytrKSB7IGlmKEFqW2tdID09PSBqKSB7IHhbal0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHhbal07XG4gICAgICAgIGZvcihrPWowO2shPT1qMTsrK2spIHtcbiAgICAgICAgICAgIGwgPSBBaltrXTtcbiAgICAgICAgICAgIGlmKGwgIT09IGopIHhbbF0gLT0gYSpBdltrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbm51bWVyaWMuY2NzREZTID0gZnVuY3Rpb24gY2NzREZTKG4pIHtcbiAgICB0aGlzLmsgPSBBcnJheShuKTtcbiAgICB0aGlzLmsxID0gQXJyYXkobik7XG4gICAgdGhpcy5qID0gQXJyYXkobik7XG59XG5udW1lcmljLmNjc0RGUy5wcm90b3R5cGUuZGZzID0gZnVuY3Rpb24gZGZzKEosQWksQWoseCx4aixQaW52KSB7XG4gICAgdmFyIG0gPSAwLGZvbyxuPXhqLmxlbmd0aDtcbiAgICB2YXIgayA9IHRoaXMuaywgazEgPSB0aGlzLmsxLCBqID0gdGhpcy5qLGttLGsxMTtcbiAgICBpZih4W0pdIT09MCkgcmV0dXJuO1xuICAgIHhbSl0gPSAxO1xuICAgIGpbMF0gPSBKO1xuICAgIGtbMF0gPSBrbSA9IEFpW0pdO1xuICAgIGsxWzBdID0gazExID0gQWlbSisxXTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIGlmKGttID49IGsxMSkge1xuICAgICAgICAgICAgeGpbbl0gPSBqW21dO1xuICAgICAgICAgICAgaWYobT09PTApIHJldHVybjtcbiAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIC0tbTtcbiAgICAgICAgICAgIGttID0ga1ttXTtcbiAgICAgICAgICAgIGsxMSA9IGsxW21dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9vID0gUGludltBaltrbV1dO1xuICAgICAgICAgICAgaWYoeFtmb29dID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeFtmb29dID0gMTtcbiAgICAgICAgICAgICAgICBrW21dID0ga207XG4gICAgICAgICAgICAgICAgKyttO1xuICAgICAgICAgICAgICAgIGpbbV0gPSBmb287XG4gICAgICAgICAgICAgICAga20gPSBBaVtmb29dO1xuICAgICAgICAgICAgICAgIGsxW21dID0gazExID0gQWlbZm9vKzFdO1xuICAgICAgICAgICAgfSBlbHNlICsra207XG4gICAgICAgIH1cbiAgICB9XG59XG5udW1lcmljLmNjc0xQU29sdmUgPSBmdW5jdGlvbiBjY3NMUFNvbHZlKEEsQix4LHhqLEksUGludixkZnMpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG49MDtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICBcbiAgICB2YXIgaSxpMCxpMSxqLEosajAsajEsayxsLGwwLGwxLGE7XG4gICAgaTAgPSBCaVtJXTtcbiAgICBpMSA9IEJpW0krMV07XG4gICAgeGoubGVuZ3RoID0gMDtcbiAgICBmb3IoaT1pMDtpPGkxOysraSkgeyBkZnMuZGZzKFBpbnZbQmpbaV1dLEFpLEFqLHgseGosUGludik7IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IHhbeGpbaV1dID0gMDsgfVxuICAgIGZvcihpPWkwO2khPT1pMTsrK2kpIHsgaiA9IFBpbnZbQmpbaV1dOyB4W2pdID0gQnZbaV07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBBaVtqKzFdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykgeyBpZihQaW52W0FqW2tdXSA9PT0gaikgeyB4W2pdIC89IEF2W2tdOyBicmVhazsgfSB9XG4gICAgICAgIGEgPSB4W2pdO1xuICAgICAgICBmb3Ioaz1qMDtrPGoxOysraykge1xuICAgICAgICAgICAgbCA9IFBpbnZbQWpba11dO1xuICAgICAgICAgICAgaWYobCAhPT0gaikgeFtsXSAtPSBhKkF2W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxubnVtZXJpYy5jY3NMVVAxID0gZnVuY3Rpb24gY2NzTFVQMShBLHRocmVzaG9sZCkge1xuICAgIHZhciBtID0gQVswXS5sZW5ndGgtMTtcbiAgICB2YXIgTCA9IFtudW1lcmljLnJlcChbbSsxXSwwKSxbXSxbXV0sIFUgPSBbbnVtZXJpYy5yZXAoW20rMV0sIDApLFtdLFtdXTtcbiAgICB2YXIgTGkgPSBMWzBdLCBMaiA9IExbMV0sIEx2ID0gTFsyXSwgVWkgPSBVWzBdLCBVaiA9IFVbMV0sIFV2ID0gVVsyXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgdmFyIGksaixrLGowLGoxLGEsZSxjLGQsSztcbiAgICB2YXIgc29sID0gbnVtZXJpYy5jY3NMUFNvbHZlLCBtYXggPSBNYXRoLm1heCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIFAgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSxQaW52ID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7XG4gICAgdmFyIGRmcyA9IG5ldyBudW1lcmljLmNjc0RGUyhtKTtcbiAgICBpZih0eXBlb2YgdGhyZXNob2xkID09PSBcInVuZGVmaW5lZFwiKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgc29sKEwsQSx4LHhqLGksUGludixkZnMpO1xuICAgICAgICBhID0gLTE7XG4gICAgICAgIGUgPSAtMTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgaWYoayA8PSBpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBhYnMoeFtrXSk7XG4gICAgICAgICAgICBpZihjID4gYSkgeyBlID0gazsgYSA9IGM7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihhYnMoeFtpXSk8dGhyZXNob2xkKmEpIHtcbiAgICAgICAgICAgIGogPSBQW2ldO1xuICAgICAgICAgICAgYSA9IFBbZV07XG4gICAgICAgICAgICBQW2ldID0gYTsgUGludlthXSA9IGk7XG4gICAgICAgICAgICBQW2VdID0gajsgUGludltqXSA9IGU7XG4gICAgICAgICAgICBhID0geFtpXTsgeFtpXSA9IHhbZV07IHhbZV0gPSBhO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBMaVtpXTtcbiAgICAgICAgZSA9IFVpW2ldO1xuICAgICAgICBkID0geFtpXTtcbiAgICAgICAgTGpbYV0gPSBQW2ldO1xuICAgICAgICBMdlthXSA9IDE7XG4gICAgICAgICsrYTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgYyA9IHhba107XG4gICAgICAgICAgICB4altqXSA9IDA7XG4gICAgICAgICAgICB4W2tdID0gMDtcbiAgICAgICAgICAgIGlmKGs8PWkpIHsgVWpbZV0gPSBrOyBVdltlXSA9IGM7ICAgKytlOyB9XG4gICAgICAgICAgICBlbHNlICAgICB7IExqW2FdID0gUFtrXTsgTHZbYV0gPSBjL2Q7ICsrYTsgfVxuICAgICAgICB9XG4gICAgICAgIExpW2krMV0gPSBhO1xuICAgICAgICBVaVtpKzFdID0gZTtcbiAgICB9XG4gICAgZm9yKGo9TGoubGVuZ3RoLTE7aiE9PS0xOy0taikgeyBMaltqXSA9IFBpbnZbTGpbal1dOyB9XG4gICAgcmV0dXJuIHtMOkwsIFU6VSwgUDpQLCBQaW52OlBpbnZ9O1xufVxubnVtZXJpYy5jY3NERlMwID0gZnVuY3Rpb24gY2NzREZTMChuKSB7XG4gICAgdGhpcy5rID0gQXJyYXkobik7XG4gICAgdGhpcy5rMSA9IEFycmF5KG4pO1xuICAgIHRoaXMuaiA9IEFycmF5KG4pO1xufVxubnVtZXJpYy5jY3NERlMwLnByb3RvdHlwZS5kZnMgPSBmdW5jdGlvbiBkZnMoSixBaSxBaix4LHhqLFBpbnYsUCkge1xuICAgIHZhciBtID0gMCxmb28sbj14ai5sZW5ndGg7XG4gICAgdmFyIGsgPSB0aGlzLmssIGsxID0gdGhpcy5rMSwgaiA9IHRoaXMuaixrbSxrMTE7XG4gICAgaWYoeFtKXSE9PTApIHJldHVybjtcbiAgICB4W0pdID0gMTtcbiAgICBqWzBdID0gSjtcbiAgICBrWzBdID0ga20gPSBBaVtQaW52W0pdXTtcbiAgICBrMVswXSA9IGsxMSA9IEFpW1BpbnZbSl0rMV07XG4gICAgd2hpbGUoMSkge1xuICAgICAgICBpZihpc05hTihrbSkpIHRocm93IG5ldyBFcnJvcihcIk93IVwiKTtcbiAgICAgICAgaWYoa20gPj0gazExKSB7XG4gICAgICAgICAgICB4altuXSA9IFBpbnZbalttXV07XG4gICAgICAgICAgICBpZihtPT09MCkgcmV0dXJuO1xuICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAga20gPSBrW21dO1xuICAgICAgICAgICAgazExID0gazFbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb28gPSBBaltrbV07XG4gICAgICAgICAgICBpZih4W2Zvb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB4W2Zvb10gPSAxO1xuICAgICAgICAgICAgICAgIGtbbV0gPSBrbTtcbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgalttXSA9IGZvbztcbiAgICAgICAgICAgICAgICBmb28gPSBQaW52W2Zvb107XG4gICAgICAgICAgICAgICAga20gPSBBaVtmb29dO1xuICAgICAgICAgICAgICAgIGsxW21dID0gazExID0gQWlbZm9vKzFdO1xuICAgICAgICAgICAgfSBlbHNlICsra207XG4gICAgICAgIH1cbiAgICB9XG59XG5udW1lcmljLmNjc0xQU29sdmUwID0gZnVuY3Rpb24gY2NzTFBTb2x2ZTAoQSxCLHkseGosSSxQaW52LFAsZGZzKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sbSA9IEFpLmxlbmd0aC0xLCBuPTA7XG4gICAgdmFyIEJpID0gQlswXSwgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgXG4gICAgdmFyIGksaTAsaTEsaixKLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGkwID0gQmlbSV07XG4gICAgaTEgPSBCaVtJKzFdO1xuICAgIHhqLmxlbmd0aCA9IDA7XG4gICAgZm9yKGk9aTA7aTxpMTsrK2kpIHsgZGZzLmRmcyhCaltpXSxBaSxBaix5LHhqLFBpbnYsUCk7IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGogPSB4altpXTsgeVtQW2pdXSA9IDA7IH1cbiAgICBmb3IoaT1pMDtpIT09aTE7KytpKSB7IGogPSBCaltpXTsgeVtqXSA9IEJ2W2ldOyB9XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBqID0geGpbaV07XG4gICAgICAgIGwgPSBQW2pdO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IEFpW2orMV07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7IGlmKEFqW2tdID09PSBsKSB7IHlbbF0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHlbbF07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB5W0FqW2tdXSAtPSBhKkF2W2tdO1xuICAgICAgICB5W2xdID0gYTtcbiAgICB9XG59XG5udW1lcmljLmNjc0xVUDAgPSBmdW5jdGlvbiBjY3NMVVAwKEEsdGhyZXNob2xkKSB7XG4gICAgdmFyIG0gPSBBWzBdLmxlbmd0aC0xO1xuICAgIHZhciBMID0gW251bWVyaWMucmVwKFttKzFdLDApLFtdLFtdXSwgVSA9IFtudW1lcmljLnJlcChbbSsxXSwgMCksW10sW11dO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdLCBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciB5ID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICB2YXIgaSxqLGssajAsajEsYSxlLGMsZCxLO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc0xQU29sdmUwLCBtYXggPSBNYXRoLm1heCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIFAgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSxQaW52ID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7XG4gICAgdmFyIGRmcyA9IG5ldyBudW1lcmljLmNjc0RGUzAobSk7XG4gICAgaWYodHlwZW9mIHRocmVzaG9sZCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJlc2hvbGQgPSAxOyB9XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIHNvbChMLEEseSx4aixpLFBpbnYsUCxkZnMpO1xuICAgICAgICBhID0gLTE7XG4gICAgICAgIGUgPSAtMTtcbiAgICAgICAgZm9yKGo9eGoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgayA9IHhqW2pdO1xuICAgICAgICAgICAgaWYoayA8PSBpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBhYnMoeVtQW2tdXSk7XG4gICAgICAgICAgICBpZihjID4gYSkgeyBlID0gazsgYSA9IGM7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihhYnMoeVtQW2ldXSk8dGhyZXNob2xkKmEpIHtcbiAgICAgICAgICAgIGogPSBQW2ldO1xuICAgICAgICAgICAgYSA9IFBbZV07XG4gICAgICAgICAgICBQW2ldID0gYTsgUGludlthXSA9IGk7XG4gICAgICAgICAgICBQW2VdID0gajsgUGludltqXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IExpW2ldO1xuICAgICAgICBlID0gVWlbaV07XG4gICAgICAgIGQgPSB5W1BbaV1dO1xuICAgICAgICBMalthXSA9IFBbaV07XG4gICAgICAgIEx2W2FdID0gMTtcbiAgICAgICAgKythO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBjID0geVtQW2tdXTtcbiAgICAgICAgICAgIHhqW2pdID0gMDtcbiAgICAgICAgICAgIHlbUFtrXV0gPSAwO1xuICAgICAgICAgICAgaWYoazw9aSkgeyBValtlXSA9IGs7IFV2W2VdID0gYzsgICArK2U7IH1cbiAgICAgICAgICAgIGVsc2UgICAgIHsgTGpbYV0gPSBQW2tdOyBMdlthXSA9IGMvZDsgKythOyB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbaSsxXSA9IGE7XG4gICAgICAgIFVpW2krMV0gPSBlO1xuICAgIH1cbiAgICBmb3Ioaj1Mai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7IExqW2pdID0gUGludltMaltqXV07IH1cbiAgICByZXR1cm4ge0w6TCwgVTpVLCBQOlAsIFBpbnY6UGludn07XG59XG5udW1lcmljLmNjc0xVUCA9IG51bWVyaWMuY2NzTFVQMDtcblxubnVtZXJpYy5jY3NEaW0gPSBmdW5jdGlvbiBjY3NEaW0oQSkgeyByZXR1cm4gW251bWVyaWMuc3VwKEFbMV0pKzEsQVswXS5sZW5ndGgtMV07IH1cbm51bWVyaWMuY2NzR2V0QmxvY2sgPSBmdW5jdGlvbiBjY3NHZXRCbG9jayhBLGksaikge1xuICAgIHZhciBzID0gbnVtZXJpYy5jY3NEaW0oQSksbT1zWzBdLG49c1sxXTtcbiAgICBpZih0eXBlb2YgaSA9PT0gXCJ1bmRlZmluZWRcIikgeyBpID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSk7IH1cbiAgICBlbHNlIGlmKHR5cGVvZiBpID09PSBcIm51bWJlclwiKSB7IGkgPSBbaV07IH1cbiAgICBpZih0eXBlb2YgaiA9PT0gXCJ1bmRlZmluZWRcIikgeyBqID0gbnVtZXJpYy5saW5zcGFjZSgwLG4tMSk7IH1cbiAgICBlbHNlIGlmKHR5cGVvZiBqID09PSBcIm51bWJlclwiKSB7IGogPSBbal07IH1cbiAgICB2YXIgcCxwMCxwMSxQID0gaS5sZW5ndGgscSxRID0gai5sZW5ndGgscixqcSxpcDtcbiAgICB2YXIgQmkgPSBudW1lcmljLnJlcChbbl0sMCksIEJqPVtdLCBCdj1bXSwgQiA9IFtCaSxCaixCdl07XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbV0sMCksY291bnQ9MCxmbGFncyA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICBmb3IocT0wO3E8UTsrK3EpIHtcbiAgICAgICAganEgPSBqW3FdO1xuICAgICAgICB2YXIgcTAgPSBBaVtqcV07XG4gICAgICAgIHZhciBxMSA9IEFpW2pxKzFdO1xuICAgICAgICBmb3IocD1xMDtwPHExOysrcCkge1xuICAgICAgICAgICAgciA9IEFqW3BdO1xuICAgICAgICAgICAgZmxhZ3Nbcl0gPSAxO1xuICAgICAgICAgICAgeFtyXSA9IEF2W3BdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihwPTA7cDxQOysrcCkge1xuICAgICAgICAgICAgaXAgPSBpW3BdO1xuICAgICAgICAgICAgaWYoZmxhZ3NbaXBdKSB7XG4gICAgICAgICAgICAgICAgQmpbY291bnRdID0gcDtcbiAgICAgICAgICAgICAgICBCdltjb3VudF0gPSB4W2lbcF1dO1xuICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHA9cTA7cDxxMTsrK3ApIHtcbiAgICAgICAgICAgIHIgPSBBaltwXTtcbiAgICAgICAgICAgIGZsYWdzW3JdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBCaVtxKzFdID0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxuXG5udW1lcmljLmNjc0RvdCA9IGZ1bmN0aW9uIGNjc0RvdChBLEIpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICB2YXIgc0EgPSBudW1lcmljLmNjc0RpbShBKSwgc0IgPSBudW1lcmljLmNjc0RpbShCKTtcbiAgICB2YXIgbSA9IHNBWzBdLCBuID0gc0FbMV0sIG8gPSBzQlsxXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSwgZmxhZ3MgPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gQXJyYXkobSk7XG4gICAgdmFyIENpID0gbnVtZXJpYy5yZXAoW29dLDApLCBDaiA9IFtdLCBDdiA9IFtdLCBDID0gW0NpLENqLEN2XTtcbiAgICB2YXIgaSxqLGssajAsajEsaTAsaTEsbCxwLGEsYjtcbiAgICBmb3Ioaz0wO2shPT1vOysraykge1xuICAgICAgICBqMCA9IEJpW2tdO1xuICAgICAgICBqMSA9IEJpW2srMV07XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikge1xuICAgICAgICAgICAgYSA9IEJqW2pdO1xuICAgICAgICAgICAgYiA9IEJ2W2pdO1xuICAgICAgICAgICAgaTAgPSBBaVthXTtcbiAgICAgICAgICAgIGkxID0gQWlbYSsxXTtcbiAgICAgICAgICAgIGZvcihpPWkwO2k8aTE7KytpKSB7XG4gICAgICAgICAgICAgICAgbCA9IEFqW2ldO1xuICAgICAgICAgICAgICAgIGlmKGZsYWdzW2xdPT09MCkge1xuICAgICAgICAgICAgICAgICAgICB4altwXSA9IGw7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2xdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHArMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeFtsXSA9IHhbbF0gKyBBdltpXSpiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGowID0gQ2lba107XG4gICAgICAgIGoxID0gajArcDtcbiAgICAgICAgQ2lbaysxXSA9IGoxO1xuICAgICAgICBmb3Ioaj1wLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgYiA9IGowK2o7XG4gICAgICAgICAgICBpID0geGpbal07XG4gICAgICAgICAgICBDaltiXSA9IGk7XG4gICAgICAgICAgICBDdltiXSA9IHhbaV07XG4gICAgICAgICAgICBmbGFnc1tpXSA9IDA7XG4gICAgICAgICAgICB4W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBDaVtrKzFdID0gQ2lba10rcDtcbiAgICB9XG4gICAgcmV0dXJuIEM7XG59XG5cbm51bWVyaWMuY2NzTFVQU29sdmUgPSBmdW5jdGlvbiBjY3NMVVBTb2x2ZShMVVAsQikge1xuICAgIHZhciBMID0gTFVQLkwsIFUgPSBMVVAuVSwgUCA9IExVUC5QO1xuICAgIHZhciBCaSA9IEJbMF07XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICBpZih0eXBlb2YgQmkgIT09IFwib2JqZWN0XCIpIHsgQiA9IFtbMCxCLmxlbmd0aF0sbnVtZXJpYy5saW5zcGFjZSgwLEIubGVuZ3RoLTEpLEJdOyBCaSA9IEJbMF07IGZsYWcgPSB0cnVlOyB9XG4gICAgdmFyIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIHZhciBuID0gTFswXS5sZW5ndGgtMSwgbSA9IEJpLmxlbmd0aC0xO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW25dLDApLCB4aiA9IEFycmF5KG4pO1xuICAgIHZhciBiID0gbnVtZXJpYy5yZXAoW25dLDApLCBiaiA9IEFycmF5KG4pO1xuICAgIHZhciBYaSA9IG51bWVyaWMucmVwKFttKzFdLDApLCBYaiA9IFtdLCBYdiA9IFtdO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc1RTb2x2ZTtcbiAgICB2YXIgaSxqLGowLGoxLGssSixOPTA7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBqMCA9IEJpW2ldO1xuICAgICAgICBqMSA9IEJpW2krMV07XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7IFxuICAgICAgICAgICAgSiA9IExVUC5QaW52W0JqW2pdXTtcbiAgICAgICAgICAgIGJqW2tdID0gSjtcbiAgICAgICAgICAgIGJbSl0gPSBCdltqXTtcbiAgICAgICAgICAgICsraztcbiAgICAgICAgfVxuICAgICAgICBiai5sZW5ndGggPSBrO1xuICAgICAgICBzb2woTCxiLHgsYmoseGopO1xuICAgICAgICBmb3Ioaj1iai5sZW5ndGgtMTtqIT09LTE7LS1qKSBiW2JqW2pdXSA9IDA7XG4gICAgICAgIHNvbChVLHgsYix4aixiaik7XG4gICAgICAgIGlmKGZsYWcpIHJldHVybiBiO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB4W3hqW2pdXSA9IDA7XG4gICAgICAgIGZvcihqPWJqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIEogPSBialtqXTtcbiAgICAgICAgICAgIFhqW05dID0gSjtcbiAgICAgICAgICAgIFh2W05dID0gYltKXTtcbiAgICAgICAgICAgIGJbSl0gPSAwO1xuICAgICAgICAgICAgKytOO1xuICAgICAgICB9XG4gICAgICAgIFhpW2krMV0gPSBOO1xuICAgIH1cbiAgICByZXR1cm4gW1hpLFhqLFh2XTtcbn1cblxubnVtZXJpYy5jY3NiaW5vcCA9IGZ1bmN0aW9uIGNjc2Jpbm9wKGJvZHksc2V0dXApIHtcbiAgICBpZih0eXBlb2Ygc2V0dXAgPT09IFwidW5kZWZpbmVkXCIpIHNldHVwPScnO1xuICAgIHJldHVybiBGdW5jdGlvbignWCcsJ1knLFxuICAgICAgICAgICAgJ3ZhciBYaSA9IFhbMF0sIFhqID0gWFsxXSwgWHYgPSBYWzJdO1xcbicrXG4gICAgICAgICAgICAndmFyIFlpID0gWVswXSwgWWogPSBZWzFdLCBZdiA9IFlbMl07XFxuJytcbiAgICAgICAgICAgICd2YXIgbiA9IFhpLmxlbmd0aC0xLG0gPSBNYXRoLm1heChudW1lcmljLnN1cChYaiksbnVtZXJpYy5zdXAoWWopKSsxO1xcbicrXG4gICAgICAgICAgICAndmFyIFppID0gbnVtZXJpYy5yZXAoW24rMV0sMCksIFpqID0gW10sIFp2ID0gW107XFxuJytcbiAgICAgICAgICAgICd2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSx5ID0gbnVtZXJpYy5yZXAoW21dLDApO1xcbicrXG4gICAgICAgICAgICAndmFyIHhrLHlrLHprO1xcbicrXG4gICAgICAgICAgICAndmFyIGksaixqMCxqMSxrLHA9MDtcXG4nK1xuICAgICAgICAgICAgc2V0dXArXG4gICAgICAgICAgICAnZm9yKGk9MDtpPG47KytpKSB7XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBYaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB4W2tdID0gMTtcXG4nK1xuICAgICAgICAgICAgJyAgICBaaltwXSA9IGs7XFxuJytcbiAgICAgICAgICAgICcgICAgKytwO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWWlbaV07IGoxID0gWWlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBZaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB5W2tdID0gWXZbal07XFxuJytcbiAgICAgICAgICAgICcgICAgaWYoeFtrXSA9PT0gMCkge1xcbicrXG4gICAgICAgICAgICAnICAgICAgWmpbcF0gPSBrO1xcbicrXG4gICAgICAgICAgICAnICAgICAgKytwO1xcbicrXG4gICAgICAgICAgICAnICAgIH1cXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICBaaVtpKzFdID0gcDtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB4W1hqW2pdXSA9IFh2W2pdO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFppW2ldOyBqMSA9IFppW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcXG4nK1xuICAgICAgICAgICAgJyAgICBrID0gWmpbal07XFxuJytcbiAgICAgICAgICAgICcgICAgeGsgPSB4W2tdO1xcbicrXG4gICAgICAgICAgICAnICAgIHlrID0geVtrXTtcXG4nK1xuICAgICAgICAgICAgYm9keSsnXFxuJytcbiAgICAgICAgICAgICcgICAgWnZbal0gPSB6aztcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHhbWGpbal1dID0gMDtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBZaVtpXTsgajEgPSBZaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB5W1lqW2pdXSA9IDA7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gW1ppLFpqLFp2XTsnXG4gICAgICAgICAgICApO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLEEsQixDO1xuICAgIGZvcihrIGluIG51bWVyaWMub3BzMikge1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcxJytudW1lcmljLm9wczJba10rJzAnKSkpIEEgPSAnW1lbMF0sWVsxXSxudW1lcmljLicraysnKFgsWVsyXSldJztcbiAgICAgICAgZWxzZSBBID0gJ05hTic7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzAnK251bWVyaWMub3BzMltrXSsnMScpKSkgQiA9ICdbWFswXSxYWzFdLG51bWVyaWMuJytrKycoWFsyXSxZKV0nO1xuICAgICAgICBlbHNlIEIgPSAnTmFOJztcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMScrbnVtZXJpYy5vcHMyW2tdKycwJykpICYmIGlzRmluaXRlKGV2YWwoJzAnK251bWVyaWMub3BzMltrXSsnMScpKSkgQyA9ICdudW1lcmljLmNjcycraysnTU0oWCxZKSc7XG4gICAgICAgIGVsc2UgQyA9ICdOYU4nO1xuICAgICAgICBudW1lcmljWydjY3MnK2srJ01NJ10gPSBudW1lcmljLmNjc2Jpbm9wKCd6ayA9IHhrICcrbnVtZXJpYy5vcHMyW2tdKyd5azsnKTtcbiAgICAgICAgbnVtZXJpY1snY2NzJytrXSA9IEZ1bmN0aW9uKCdYJywnWScsXG4gICAgICAgICAgICAgICAgJ2lmKHR5cGVvZiBYID09PSBcIm51bWJlclwiKSByZXR1cm4gJytBKyc7XFxuJytcbiAgICAgICAgICAgICAgICAnaWYodHlwZW9mIFkgPT09IFwibnVtYmVyXCIpIHJldHVybiAnK0IrJztcXG4nK1xuICAgICAgICAgICAgICAgICdyZXR1cm4gJytDKyc7XFxuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgfVxufSgpKTtcblxubnVtZXJpYy5jY3NTY2F0dGVyID0gZnVuY3Rpb24gY2NzU2NhdHRlcihBKSB7XG4gICAgdmFyIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl07XG4gICAgdmFyIG4gPSBudW1lcmljLnN1cChBaikrMSxtPUFpLmxlbmd0aDtcbiAgICB2YXIgUmkgPSBudW1lcmljLnJlcChbbl0sMCksUmo9QXJyYXkobSksIFJ2ID0gQXJyYXkobSk7XG4gICAgdmFyIGNvdW50cyA9IG51bWVyaWMucmVwKFtuXSwwKSxpO1xuICAgIGZvcihpPTA7aTxtOysraSkgY291bnRzW0FqW2ldXSsrO1xuICAgIGZvcihpPTA7aTxuOysraSkgUmlbaSsxXSA9IFJpW2ldICsgY291bnRzW2ldO1xuICAgIHZhciBwdHIgPSBSaS5zbGljZSgwKSxrLEFpaTtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgQWlpID0gQWpbaV07XG4gICAgICAgIGsgPSBwdHJbQWlpXTtcbiAgICAgICAgUmpba10gPSBBaVtpXTtcbiAgICAgICAgUnZba10gPSBBdltpXTtcbiAgICAgICAgcHRyW0FpaV09cHRyW0FpaV0rMTtcbiAgICB9XG4gICAgcmV0dXJuIFtSaSxSaixSdl07XG59XG5cbm51bWVyaWMuY2NzR2F0aGVyID0gZnVuY3Rpb24gY2NzR2F0aGVyKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgbiA9IEFpLmxlbmd0aC0xLG0gPSBBai5sZW5ndGg7XG4gICAgdmFyIFJpID0gQXJyYXkobSksIFJqID0gQXJyYXkobSksIFJ2ID0gQXJyYXkobSk7XG4gICAgdmFyIGksaixqMCxqMSxwO1xuICAgIHA9MDtcbiAgICBmb3IoaT0wO2k8bjsrK2kpIHtcbiAgICAgICAgajAgPSBBaVtpXTtcbiAgICAgICAgajEgPSBBaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XG4gICAgICAgICAgICBSaltwXSA9IGk7XG4gICAgICAgICAgICBSaVtwXSA9IEFqW2pdO1xuICAgICAgICAgICAgUnZbcF0gPSBBdltqXTtcbiAgICAgICAgICAgICsrcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1JpLFJqLFJ2XTtcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBzcGFyc2UgbGluZWFyIGFsZ2VicmEgcm91dGluZXMgYXJlIGRlcHJlY2F0ZWQuXG5cbm51bWVyaWMuc2RpbSA9IGZ1bmN0aW9uIGRpbShBLHJldCxrKSB7XG4gICAgaWYodHlwZW9mIHJldCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXQgPSBbXTsgfVxuICAgIGlmKHR5cGVvZiBBICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmV0O1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIGlmKCEoayBpbiByZXQpKSB7IHJldFtrXSA9IDA7IH1cbiAgICBpZihBLmxlbmd0aCA+IHJldFtrXSkgcmV0W2tdID0gQS5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSBkaW0oQVtpXSxyZXQsaysxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm51bWVyaWMuc2Nsb25lID0gZnVuY3Rpb24gY2xvbmUoQSxrLG4pIHtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgeyBrPTA7IH1cbiAgICBpZih0eXBlb2YgbiA9PT0gXCJ1bmRlZmluZWRcIikgeyBuID0gbnVtZXJpYy5zZGltKEEpLmxlbmd0aDsgfVxuICAgIHZhciBpLHJldCA9IEFycmF5KEEubGVuZ3RoKTtcbiAgICBpZihrID09PSBuLTEpIHtcbiAgICAgICAgZm9yKGkgaW4gQSkgeyBpZihBLmhhc093blByb3BlcnR5KGkpKSByZXRbaV0gPSBBW2ldOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0W2ldID0gY2xvbmUoQVtpXSxrKzEsbik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RpYWcgPSBmdW5jdGlvbiBkaWFnKGQpIHtcbiAgICB2YXIgbiA9IGQubGVuZ3RoLGkscmV0ID0gQXJyYXkobiksaTEsaTIsaTM7XG4gICAgZm9yKGk9bi0xO2k+PTE7aS09Mikge1xuICAgICAgICBpMSA9IGktMTtcbiAgICAgICAgcmV0W2ldID0gW107IHJldFtpXVtpXSA9IGRbaV07XG4gICAgICAgIHJldFtpMV0gPSBbXTsgcmV0W2kxXVtpMV0gPSBkW2kxXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHsgcmV0WzBdID0gW107IHJldFswXVswXSA9IGRbaV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG51bWVyaWMuc2RpYWcobnVtZXJpYy5yZXAoW25dLDEpKTsgfVxuXG5udW1lcmljLnN0cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoQSkge1xuICAgIHZhciByZXQgPSBbXSwgbiA9IEEubGVuZ3RoLCBpLGosQWk7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZighKEEuaGFzT3duUHJvcGVydHkoaSkpKSBjb250aW51ZTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYodHlwZW9mIHJldFtqXSAhPT0gXCJvYmplY3RcIikgeyByZXRbal0gPSBbXTsgfVxuICAgICAgICAgICAgcmV0W2pdW2ldID0gQWlbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zTFVQID0gZnVuY3Rpb24gTFVQKEEsdG9sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIG51bWVyaWMuc0xVUCBoYWQgYSBidWcgaW4gaXQgYW5kIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlIG5ldyBudW1lcmljLmNjc0xVUCBmdW5jdGlvbiBpbnN0ZWFkLlwiKTtcbn07XG5cbm51bWVyaWMuc2RvdE1NID0gZnVuY3Rpb24gZG90TU0oQSxCKSB7XG4gICAgdmFyIHAgPSBBLmxlbmd0aCwgcSA9IEIubGVuZ3RoLCBCVCA9IG51bWVyaWMuc3RyYW5zcG9zZShCKSwgciA9IEJULmxlbmd0aCwgQWksIEJUaztcbiAgICB2YXIgaSxqLGssYWNjdW07XG4gICAgdmFyIHJldCA9IEFycmF5KHApLHJldGk7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIHJldGkgPSBbXTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBmb3Ioaz1yLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgIGFjY3VtID0gMDtcbiAgICAgICAgICAgIEJUayA9IEJUW2tdO1xuICAgICAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYoaiBpbiBCVGspIHsgYWNjdW0gKz0gQWlbal0qQlRrW2pdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhY2N1bSkgcmV0aVtrXSA9IGFjY3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSA9IHJldGk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdE1WID0gZnVuY3Rpb24gZG90TVYoQSx4KSB7XG4gICAgdmFyIHAgPSBBLmxlbmd0aCwgQWksIGksajtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCksIGFjY3VtO1xuICAgIGZvcihpPXAtMTtpPj0wO2ktLSkge1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGFjY3VtID0gMDtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmKHhbal0pIGFjY3VtICs9IEFpW2pdKnhbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWNjdW0pIHJldFtpXSA9IGFjY3VtO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RWTSA9IGZ1bmN0aW9uIGRvdE1WKHgsQSkge1xuICAgIHZhciBpLGosQWksYWxwaGE7XG4gICAgdmFyIHJldCA9IFtdLCBhY2N1bTtcbiAgICBmb3IoaSBpbiB4KSB7XG4gICAgICAgIGlmKCF4Lmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBhbHBoYSA9IHhbaV07XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighQWkuaGFzT3duUHJvcGVydHkoaikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYoIXJldFtqXSkgeyByZXRbal0gPSAwOyB9XG4gICAgICAgICAgICByZXRbal0gKz0gYWxwaGEqQWlbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90VlYgPSBmdW5jdGlvbiBkb3RWVih4LHkpIHtcbiAgICB2YXIgaSxyZXQ9MDtcbiAgICBmb3IoaSBpbiB4KSB7IGlmKHhbaV0gJiYgeVtpXSkgcmV0Kz0geFtpXSp5W2ldOyB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90ID0gZnVuY3Rpb24gZG90KEEsQikge1xuICAgIHZhciBtID0gbnVtZXJpYy5zZGltKEEpLmxlbmd0aCwgbiA9IG51bWVyaWMuc2RpbShCKS5sZW5ndGg7XG4gICAgdmFyIGsgPSBtKjEwMDArbjtcbiAgICBzd2l0Y2goaykge1xuICAgIGNhc2UgMDogcmV0dXJuIEEqQjtcbiAgICBjYXNlIDEwMDE6IHJldHVybiBudW1lcmljLnNkb3RWVihBLEIpO1xuICAgIGNhc2UgMjAwMTogcmV0dXJuIG51bWVyaWMuc2RvdE1WKEEsQik7XG4gICAgY2FzZSAxMDAyOiByZXR1cm4gbnVtZXJpYy5zZG90Vk0oQSxCKTtcbiAgICBjYXNlIDIwMDI6IHJldHVybiBudW1lcmljLnNkb3RNTShBLEIpO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignbnVtZXJpYy5zZG90IG5vdCBpbXBsZW1lbnRlZCBmb3IgdGVuc29ycyBvZiBvcmRlciAnK20rJyBhbmQgJytuKTtcbiAgICB9XG59XG5cbm51bWVyaWMuc3NjYXR0ZXIgPSBmdW5jdGlvbiBzY2F0dGVyKFYpIHtcbiAgICB2YXIgbiA9IFZbMF0ubGVuZ3RoLCBWaWosIGksIGosIG0gPSBWLmxlbmd0aCwgQSA9IFtdLCBBajtcbiAgICBmb3IoaT1uLTE7aT49MDstLWkpIHtcbiAgICAgICAgaWYoIVZbbS0xXVtpXSkgY29udGludWU7XG4gICAgICAgIEFqID0gQTtcbiAgICAgICAgZm9yKGo9MDtqPG0tMjtqKyspIHtcbiAgICAgICAgICAgIFZpaiA9IFZbal1baV07XG4gICAgICAgICAgICBpZighQWpbVmlqXSkgQWpbVmlqXSA9IFtdO1xuICAgICAgICAgICAgQWogPSBBaltWaWpdO1xuICAgICAgICB9XG4gICAgICAgIEFqW1Zbal1baV1dID0gVltqKzFdW2ldO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxubnVtZXJpYy5zZ2F0aGVyID0gZnVuY3Rpb24gZ2F0aGVyKEEscmV0LGspIHtcbiAgICBpZih0eXBlb2YgcmV0ID09PSBcInVuZGVmaW5lZFwiKSByZXQgPSBbXTtcbiAgICBpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgayA9IFtdO1xuICAgIHZhciBuLGksQWk7XG4gICAgbiA9IGsubGVuZ3RoO1xuICAgIGZvcihpIGluIEEpIHtcbiAgICAgICAgaWYoQS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAga1tuXSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICAgICAgaWYodHlwZW9mIEFpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYoQWkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocmV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGk9bisxO2k+PTA7LS1pKSByZXRbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IoaT1uO2k+PTA7LS1pKSByZXRbaV0ucHVzaChrW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0W24rMV0ucHVzaChBaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGdhdGhlcihBaSxyZXQsayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoay5sZW5ndGg+bikgay5wb3AoKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyA2LiBDb29yZGluYXRlIG1hdHJpY2VzXG5udW1lcmljLmNMVSA9IGZ1bmN0aW9uIExVKEEpIHtcbiAgICB2YXIgSSA9IEFbMF0sIEogPSBBWzFdLCBWID0gQVsyXTtcbiAgICB2YXIgcCA9IEkubGVuZ3RoLCBtPTAsIGksaixrLGEsYixjO1xuICAgIGZvcihpPTA7aTxwO2krKykgaWYoSVtpXT5tKSBtPUlbaV07XG4gICAgbSsrO1xuICAgIHZhciBMID0gQXJyYXkobSksIFUgPSBBcnJheShtKSwgbGVmdCA9IG51bWVyaWMucmVwKFttXSxJbmZpbml0eSksIHJpZ2h0ID0gbnVtZXJpYy5yZXAoW21dLC1JbmZpbml0eSk7XG4gICAgdmFyIFVpLCBVaixhbHBoYTtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHtcbiAgICAgICAgaSA9IElba107XG4gICAgICAgIGogPSBKW2tdO1xuICAgICAgICBpZihqPGxlZnRbaV0pIGxlZnRbaV0gPSBqO1xuICAgICAgICBpZihqPnJpZ2h0W2ldKSByaWdodFtpXSA9IGo7XG4gICAgfVxuICAgIGZvcihpPTA7aTxtLTE7aSsrKSB7IGlmKHJpZ2h0W2ldID4gcmlnaHRbaSsxXSkgcmlnaHRbaSsxXSA9IHJpZ2h0W2ldOyB9XG4gICAgZm9yKGk9bS0xO2k+PTE7aS0tKSB7IGlmKGxlZnRbaV08bGVmdFtpLTFdKSBsZWZ0W2ktMV0gPSBsZWZ0W2ldOyB9XG4gICAgdmFyIGNvdW50TCA9IDAsIGNvdW50VSA9IDA7XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIFVbaV0gPSBudW1lcmljLnJlcChbcmlnaHRbaV0tbGVmdFtpXSsxXSwwKTtcbiAgICAgICAgTFtpXSA9IG51bWVyaWMucmVwKFtpLWxlZnRbaV1dLDApO1xuICAgICAgICBjb3VudEwgKz0gaS1sZWZ0W2ldKzE7XG4gICAgICAgIGNvdW50VSArPSByaWdodFtpXS1pKzE7XG4gICAgfVxuICAgIGZvcihrPTA7azxwO2srKykgeyBpID0gSVtrXTsgVVtpXVtKW2tdLWxlZnRbaV1dID0gVltrXTsgfVxuICAgIGZvcihpPTA7aTxtLTE7aSsrKSB7XG4gICAgICAgIGEgPSBpLWxlZnRbaV07XG4gICAgICAgIFVpID0gVVtpXTtcbiAgICAgICAgZm9yKGo9aSsxO2xlZnRbal08PWkgJiYgajxtO2orKykge1xuICAgICAgICAgICAgYiA9IGktbGVmdFtqXTtcbiAgICAgICAgICAgIGMgPSByaWdodFtpXS1pO1xuICAgICAgICAgICAgVWogPSBVW2pdO1xuICAgICAgICAgICAgYWxwaGEgPSBValtiXS9VaVthXTtcbiAgICAgICAgICAgIGlmKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgZm9yKGs9MTtrPD1jO2srKykgeyBValtrK2JdIC09IGFscGhhKlVpW2srYV07IH1cbiAgICAgICAgICAgICAgICBMW2pdW2ktbGVmdFtqXV0gPSBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgVWkgPSBbXSwgVWogPSBbXSwgVXYgPSBbXSwgTGkgPSBbXSwgTGogPSBbXSwgTHYgPSBbXTtcbiAgICB2YXIgcCxxLGZvbztcbiAgICBwPTA7IHE9MDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgYSA9IGxlZnRbaV07XG4gICAgICAgIGIgPSByaWdodFtpXTtcbiAgICAgICAgZm9vID0gVVtpXTtcbiAgICAgICAgZm9yKGo9aTtqPD1iO2orKykge1xuICAgICAgICAgICAgaWYoZm9vW2otYV0pIHtcbiAgICAgICAgICAgICAgICBVaVtwXSA9IGk7XG4gICAgICAgICAgICAgICAgVWpbcF0gPSBqO1xuICAgICAgICAgICAgICAgIFV2W3BdID0gZm9vW2otYV07XG4gICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvbyA9IExbaV07XG4gICAgICAgIGZvcihqPWE7ajxpO2orKykge1xuICAgICAgICAgICAgaWYoZm9vW2otYV0pIHtcbiAgICAgICAgICAgICAgICBMaVtxXSA9IGk7XG4gICAgICAgICAgICAgICAgTGpbcV0gPSBqO1xuICAgICAgICAgICAgICAgIEx2W3FdID0gZm9vW2otYV07XG4gICAgICAgICAgICAgICAgcSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpW3FdID0gaTtcbiAgICAgICAgTGpbcV0gPSBpO1xuICAgICAgICBMdltxXSA9IDE7XG4gICAgICAgIHErKztcbiAgICB9XG4gICAgcmV0dXJuIHtVOltVaSxVaixVdl0sIEw6W0xpLExqLEx2XX07XG59O1xuXG5udW1lcmljLmNMVXNvbHZlID0gZnVuY3Rpb24gTFVzb2x2ZShsdSxiKSB7XG4gICAgdmFyIEwgPSBsdS5MLCBVID0gbHUuVSwgcmV0ID0gbnVtZXJpYy5jbG9uZShiKTtcbiAgICB2YXIgTGkgPSBMWzBdLCBMaiA9IExbMV0sIEx2ID0gTFsyXTtcbiAgICB2YXIgVWkgPSBVWzBdLCBVaiA9IFVbMV0sIFV2ID0gVVsyXTtcbiAgICB2YXIgcCA9IFVpLmxlbmd0aCwgcSA9IExpLmxlbmd0aDtcbiAgICB2YXIgbSA9IHJldC5sZW5ndGgsaSxqLGs7XG4gICAgayA9IDA7XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIHdoaWxlKExqW2tdIDwgaSkge1xuICAgICAgICAgICAgcmV0W2ldIC09IEx2W2tdKnJldFtMaltrXV07XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgIH1cbiAgICBrID0gcC0xO1xuICAgIGZvcihpPW0tMTtpPj0wO2ktLSkge1xuICAgICAgICB3aGlsZShValtrXSA+IGkpIHtcbiAgICAgICAgICAgIHJldFtpXSAtPSBVdltrXSpyZXRbVWpba11dO1xuICAgICAgICAgICAgay0tO1xuICAgICAgICB9XG4gICAgICAgIHJldFtpXSAvPSBVdltrXTtcbiAgICAgICAgay0tO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5jZ3JpZCA9IGZ1bmN0aW9uIGdyaWQobixzaGFwZSkge1xuICAgIGlmKHR5cGVvZiBuID09PSBcIm51bWJlclwiKSBuID0gW24sbl07XG4gICAgdmFyIHJldCA9IG51bWVyaWMucmVwKG4sLTEpO1xuICAgIHZhciBpLGosY291bnQ7XG4gICAgaWYodHlwZW9mIHNoYXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3dpdGNoKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgc2hhcGUgPSBmdW5jdGlvbihpLGopIHsgcmV0dXJuIChpPj1uWzBdLzIgfHwgajxuWzFdLzIpOyB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNoYXBlID0gZnVuY3Rpb24oaSxqKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnQ9MDtcbiAgICBmb3IoaT0xO2k8blswXS0xO2krKykgZm9yKGo9MTtqPG5bMV0tMTtqKyspIFxuICAgICAgICBpZihzaGFwZShpLGopKSB7XG4gICAgICAgICAgICByZXRbaV1bal0gPSBjb3VudDtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmNkZWxzcSA9IGZ1bmN0aW9uIGRlbHNxKGcpIHtcbiAgICB2YXIgZGlyID0gW1stMSwwXSxbMCwtMV0sWzAsMV0sWzEsMF1dO1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oZyksIG0gPSBzWzBdLCBuID0gc1sxXSwgaSxqLGsscCxxO1xuICAgIHZhciBMaSA9IFtdLCBMaiA9IFtdLCBMdiA9IFtdO1xuICAgIGZvcihpPTE7aTxtLTE7aSsrKSBmb3Ioaj0xO2o8bi0xO2orKykge1xuICAgICAgICBpZihnW2ldW2pdPDApIGNvbnRpbnVlO1xuICAgICAgICBmb3Ioaz0wO2s8NDtrKyspIHtcbiAgICAgICAgICAgIHAgPSBpK2RpcltrXVswXTtcbiAgICAgICAgICAgIHEgPSBqK2RpcltrXVsxXTtcbiAgICAgICAgICAgIGlmKGdbcF1bcV08MCkgY29udGludWU7XG4gICAgICAgICAgICBMaS5wdXNoKGdbaV1bal0pO1xuICAgICAgICAgICAgTGoucHVzaChnW3BdW3FdKTtcbiAgICAgICAgICAgIEx2LnB1c2goLTEpO1xuICAgICAgICB9XG4gICAgICAgIExpLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgIExqLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgIEx2LnB1c2goNCk7XG4gICAgfVxuICAgIHJldHVybiBbTGksTGosTHZdO1xufVxuXG5udW1lcmljLmNkb3RNViA9IGZ1bmN0aW9uIGRvdE1WKEEseCkge1xuICAgIHZhciByZXQsIEFpID0gQVswXSwgQWogPSBBWzFdLCBBdiA9IEFbMl0sayxwPUFpLmxlbmd0aCxOO1xuICAgIE49MDtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHsgaWYoQWlba10+TikgTiA9IEFpW2tdOyB9XG4gICAgTisrO1xuICAgIHJldCA9IG51bWVyaWMucmVwKFtOXSwwKTtcbiAgICBmb3Ioaz0wO2s8cDtrKyspIHsgcmV0W0FpW2tdXSs9QXZba10qeFtBaltrXV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyA3LiBTcGxpbmVzXG5cbm51bWVyaWMuU3BsaW5lID0gZnVuY3Rpb24gU3BsaW5lKHgseWwseXIsa2wsa3IpIHsgdGhpcy54ID0geDsgdGhpcy55bCA9IHlsOyB0aGlzLnlyID0geXI7IHRoaXMua2wgPSBrbDsgdGhpcy5rciA9IGtyOyB9XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuX2F0ID0gZnVuY3Rpb24gX2F0KHgxLHApIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeWwgPSB0aGlzLnlsO1xuICAgIHZhciB5ciA9IHRoaXMueXI7XG4gICAgdmFyIGtsID0gdGhpcy5rbDtcbiAgICB2YXIga3IgPSB0aGlzLmtyO1xuICAgIHZhciB4MSxhLGIsdDtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIHN1YiA9IG51bWVyaWMuc3ViLCBtdWwgPSBudW1lcmljLm11bDtcbiAgICBhID0gc3ViKG11bChrbFtwXSx4W3ArMV0teFtwXSksc3ViKHlyW3ArMV0seWxbcF0pKTtcbiAgICBiID0gYWRkKG11bChrcltwKzFdLHhbcF0teFtwKzFdKSxzdWIoeXJbcCsxXSx5bFtwXSkpO1xuICAgIHQgPSAoeDEteFtwXSkvKHhbcCsxXS14W3BdKTtcbiAgICB2YXIgcyA9IHQqKDEtdCk7XG4gICAgcmV0dXJuIGFkZChhZGQoYWRkKG11bCgxLXQseWxbcF0pLG11bCh0LHlyW3ArMV0pKSxtdWwoYSxzKigxLXQpKSksbXVsKGIscyp0KSk7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCh4MCkge1xuICAgIGlmKHR5cGVvZiB4MCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICAgICAgdmFyIHAscSxtaWQsZmxvb3IgPSBNYXRoLmZsb29yLGEsYix0O1xuICAgICAgICBwID0gMDtcbiAgICAgICAgcSA9IG4tMTtcbiAgICAgICAgd2hpbGUocS1wPjEpIHtcbiAgICAgICAgICAgIG1pZCA9IGZsb29yKChwK3EpLzIpO1xuICAgICAgICAgICAgaWYoeFttaWRdIDw9IHgwKSBwID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBxID0gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hdCh4MCxwKTtcbiAgICB9XG4gICAgdmFyIG4gPSB4MC5sZW5ndGgsIGksIHJldCA9IEFycmF5KG4pO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSByZXRbaV0gPSB0aGlzLmF0KHgwW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5TcGxpbmUucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiBkaWZmKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5bCA9IHRoaXMueWw7XG4gICAgdmFyIHlyID0gdGhpcy55cjtcbiAgICB2YXIga2wgPSB0aGlzLmtsO1xuICAgIHZhciBrciA9IHRoaXMua3I7XG4gICAgdmFyIG4gPSB5bC5sZW5ndGg7XG4gICAgdmFyIGksZHgsZHk7XG4gICAgdmFyIHpsID0ga2wsIHpyID0ga3IsIHBsID0gQXJyYXkobiksIHByID0gQXJyYXkobik7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCwgZGl2ID0gbnVtZXJpYy5kaXYsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGR4ID0geFtpKzFdLXhbaV07XG4gICAgICAgIGR5ID0gc3ViKHlyW2krMV0seWxbaV0pO1xuICAgICAgICBwbFtpXSA9IGRpdihhZGQobXVsKGR5LCA2KSxtdWwoa2xbaV0sLTQqZHgpLG11bChrcltpKzFdLC0yKmR4KSksZHgqZHgpO1xuICAgICAgICBwcltpKzFdID0gZGl2KGFkZChtdWwoZHksLTYpLG11bChrbFtpXSwgMipkeCksbXVsKGtyW2krMV0sIDQqZHgpKSxkeCpkeCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5TcGxpbmUoeCx6bCx6cixwbCxwcik7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUucm9vdHMgPSBmdW5jdGlvbiByb290cygpIHtcbiAgICBmdW5jdGlvbiBzcXIoeCkgeyByZXR1cm4geCp4OyB9XG4gICAgZnVuY3Rpb24gaGV2YWwoeTAseTEsazAsazEseCkge1xuICAgICAgICB2YXIgQSA9IGswKjItKHkxLXkwKTtcbiAgICAgICAgdmFyIEIgPSAtazEqMisoeTEteTApO1xuICAgICAgICB2YXIgdCA9ICh4KzEpKjAuNTtcbiAgICAgICAgdmFyIHMgPSB0KigxLXQpO1xuICAgICAgICByZXR1cm4gKDEtdCkqeTArdCp5MStBKnMqKDEtdCkrQipzKnQ7XG4gICAgfVxuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgeCA9IHRoaXMueCwgeWwgPSB0aGlzLnlsLCB5ciA9IHRoaXMueXIsIGtsID0gdGhpcy5rbCwga3IgPSB0aGlzLmtyO1xuICAgIGlmKHR5cGVvZiB5bFswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB5bCA9IFt5bF07XG4gICAgICAgIHlyID0gW3lyXTtcbiAgICAgICAga2wgPSBba2xdO1xuICAgICAgICBrciA9IFtrcl07XG4gICAgfVxuICAgIHZhciBtID0geWwubGVuZ3RoLG49eC5sZW5ndGgtMSxpLGosayx5LHMsdDtcbiAgICB2YXIgYWksYmksY2ksZGksIHJldCA9IEFycmF5KG0pLHJpLGswLGsxLHkwLHkxLEEsQixELGR4LGN4LHN0b3BzLHowLHoxLHptLHQwLHQxLHRtO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIGZvcihpPTA7aSE9PW07KytpKSB7XG4gICAgICAgIGFpID0geWxbaV07XG4gICAgICAgIGJpID0geXJbaV07XG4gICAgICAgIGNpID0ga2xbaV07XG4gICAgICAgIGRpID0ga3JbaV07XG4gICAgICAgIHJpID0gW107XG4gICAgICAgIGZvcihqPTA7aiE9PW47aisrKSB7XG4gICAgICAgICAgICBpZihqPjAgJiYgYmlbal0qYWlbal08MCkgcmkucHVzaCh4W2pdKTtcbiAgICAgICAgICAgIGR4ID0gKHhbaisxXS14W2pdKTtcbiAgICAgICAgICAgIGN4ID0geFtqXTtcbiAgICAgICAgICAgIHkwID0gYWlbal07XG4gICAgICAgICAgICB5MSA9IGJpW2orMV07XG4gICAgICAgICAgICBrMCA9IGNpW2pdL2R4O1xuICAgICAgICAgICAgazEgPSBkaVtqKzFdL2R4O1xuICAgICAgICAgICAgRCA9IHNxcihrMC1rMSszKih5MC15MSkpICsgMTIqazEqeTA7XG4gICAgICAgICAgICBBID0gazErMyp5MCsyKmswLTMqeTE7XG4gICAgICAgICAgICBCID0gMyooazErazArMiooeTAteTEpKTtcbiAgICAgICAgICAgIGlmKEQ8PTApIHtcbiAgICAgICAgICAgICAgICB6MCA9IEEvQjtcbiAgICAgICAgICAgICAgICBpZih6MD54W2pdICYmIHowPHhbaisxXSkgc3RvcHMgPSBbeFtqXSx6MCx4W2orMV1dO1xuICAgICAgICAgICAgICAgIGVsc2Ugc3RvcHMgPSBbeFtqXSx4W2orMV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB6MCA9IChBLXNxcnQoRCkpL0I7XG4gICAgICAgICAgICAgICAgejEgPSAoQStzcXJ0KEQpKS9CO1xuICAgICAgICAgICAgICAgIHN0b3BzID0gW3hbal1dO1xuICAgICAgICAgICAgICAgIGlmKHowPnhbal0gJiYgejA8eFtqKzFdKSBzdG9wcy5wdXNoKHowKTtcbiAgICAgICAgICAgICAgICBpZih6MT54W2pdICYmIHoxPHhbaisxXSkgc3RvcHMucHVzaCh6MSk7XG4gICAgICAgICAgICAgICAgc3RvcHMucHVzaCh4W2orMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDAgPSBzdG9wc1swXTtcbiAgICAgICAgICAgIHowID0gdGhpcy5fYXQodDAsaik7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8c3RvcHMubGVuZ3RoLTE7aysrKSB7XG4gICAgICAgICAgICAgICAgdDEgPSBzdG9wc1trKzFdO1xuICAgICAgICAgICAgICAgIHoxID0gdGhpcy5fYXQodDEsaik7XG4gICAgICAgICAgICAgICAgaWYoejAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmkucHVzaCh0MCk7IFxuICAgICAgICAgICAgICAgICAgICB0MCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB6MCA9IHoxO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoejEgPT09IDAgfHwgejAqejE+MCkge1xuICAgICAgICAgICAgICAgICAgICB0MCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB6MCA9IHoxO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpZGUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG0gPSAoejAqdDEtejEqdDApLyh6MC16MSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtIDw9IHQwIHx8IHRtID49IHQxKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIHptID0gdGhpcy5fYXQodG0saik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHptKnoxPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdG07XG4gICAgICAgICAgICAgICAgICAgICAgICB6MSA9IHptO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gLTEpIHowKj0wLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih6bSp6MD4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0MCA9IHRtO1xuICAgICAgICAgICAgICAgICAgICAgICAgejAgPSB6bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IDEpIHoxKj0wLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaS5wdXNoKHRtKTtcbiAgICAgICAgICAgICAgICB0MCA9IHN0b3BzW2srMV07XG4gICAgICAgICAgICAgICAgejAgPSB0aGlzLl9hdCh0MCwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih6MSA9PT0gMCkgcmkucHVzaCh0MSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gcmk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiB0aGlzLnlsWzBdID09PSBcIm51bWJlclwiKSByZXR1cm4gcmV0WzBdO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLnNwbGluZSA9IGZ1bmN0aW9uIHNwbGluZSh4LHksazEsa24pIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBiID0gW10sIGR4ID0gW10sIGR5ID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHN1YiA9IG51bWVyaWMuc3ViLG11bCA9IG51bWVyaWMubXVsLGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIGZvcihpPW4tMjtpPj0wO2ktLSkgeyBkeFtpXSA9IHhbaSsxXS14W2ldOyBkeVtpXSA9IHN1Yih5W2krMV0seVtpXSk7IH1cbiAgICBpZih0eXBlb2YgazEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtuID09PSBcInN0cmluZ1wiKSB7IFxuICAgICAgICBrMSA9IGtuID0gXCJwZXJpb2RpY1wiO1xuICAgIH1cbiAgICAvLyBCdWlsZCBzcGFyc2UgdHJpZGlhZ29uYWwgc3lzdGVtXG4gICAgdmFyIFQgPSBbW10sW10sW11dO1xuICAgIHN3aXRjaCh0eXBlb2YgazEpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGJbMF0gPSBtdWwoMy8oZHhbMF0qZHhbMF0pLGR5WzBdKTtcbiAgICAgICAgVFswXS5wdXNoKDAsMCk7XG4gICAgICAgIFRbMV0ucHVzaCgwLDEpO1xuICAgICAgICBUWzJdLnB1c2goMi9keFswXSwxL2R4WzBdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBiWzBdID0gYWRkKG11bCgzLyhkeFtuLTJdKmR4W24tMl0pLGR5W24tMl0pLG11bCgzLyhkeFswXSpkeFswXSksZHlbMF0pKTtcbiAgICAgICAgVFswXS5wdXNoKDAsMCwwKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMiwwLDEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtuLTJdLDIvZHhbbi0yXSsyL2R4WzBdLDEvZHhbMF0pO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICBiWzBdID0gazE7XG4gICAgICAgIFRbMF0ucHVzaCgwKTtcbiAgICAgICAgVFsxXS5wdXNoKDApO1xuICAgICAgICBUWzJdLnB1c2goMSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IoaT0xO2k8bi0xO2krKykge1xuICAgICAgICBiW2ldID0gYWRkKG11bCgzLyhkeFtpLTFdKmR4W2ktMV0pLGR5W2ktMV0pLG11bCgzLyhkeFtpXSpkeFtpXSksZHlbaV0pKTtcbiAgICAgICAgVFswXS5wdXNoKGksaSxpKTtcbiAgICAgICAgVFsxXS5wdXNoKGktMSxpLGkrMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W2ktMV0sMi9keFtpLTFdKzIvZHhbaV0sMS9keFtpXSk7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlb2Yga24pIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGJbbi0xXSA9IG11bCgzLyhkeFtuLTJdKmR4W24tMl0pLGR5W24tMl0pO1xuICAgICAgICBUWzBdLnB1c2gobi0xLG4tMSk7XG4gICAgICAgIFRbMV0ucHVzaChuLTIsbi0xKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbbi0yXSwyL2R4W24tMl0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIFRbMV1bVFsxXS5sZW5ndGgtMV0gPSAwO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICBiW24tMV0gPSBrbjtcbiAgICAgICAgVFswXS5wdXNoKG4tMSk7XG4gICAgICAgIFRbMV0ucHVzaChuLTEpO1xuICAgICAgICBUWzJdLnB1c2goMSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZih0eXBlb2YgYlswXSAhPT0gXCJudW1iZXJcIikgYiA9IG51bWVyaWMudHJhbnNwb3NlKGIpO1xuICAgIGVsc2UgYiA9IFtiXTtcbiAgICB2YXIgayA9IEFycmF5KGIubGVuZ3RoKTtcbiAgICBpZih0eXBlb2YgazEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yKGk9ay5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBrW2ldID0gbnVtZXJpYy5jY3NMVVBTb2x2ZShudW1lcmljLmNjc0xVUChudW1lcmljLmNjc1NjYXR0ZXIoVCkpLGJbaV0pO1xuICAgICAgICAgICAga1tpXVtuLTFdID0ga1tpXVswXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpPWsubGVuZ3RoLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAga1tpXSA9IG51bWVyaWMuY0xVc29sdmUobnVtZXJpYy5jTFUoVCksYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYodHlwZW9mIHlbMF0gPT09IFwibnVtYmVyXCIpIGsgPSBrWzBdO1xuICAgIGVsc2UgayA9IG51bWVyaWMudHJhbnNwb3NlKGspO1xuICAgIHJldHVybiBuZXcgbnVtZXJpYy5TcGxpbmUoeCx5LHksayxrKTtcbn1cblxuLy8gOC4gRkZUXG5udW1lcmljLmZmdHBvdzIgPSBmdW5jdGlvbiBmZnRwb3cyKHgseSkge1xuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgaWYobiA9PT0gMSkgcmV0dXJuO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW4sIGksajtcbiAgICB2YXIgeGUgPSBBcnJheShuLzIpLCB5ZSA9IEFycmF5KG4vMiksIHhvID0gQXJyYXkobi8yKSwgeW8gPSBBcnJheShuLzIpO1xuICAgIGogPSBuLzI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICB4b1tqXSA9IHhbaV07XG4gICAgICAgIHlvW2pdID0geVtpXTtcbiAgICAgICAgLS1pO1xuICAgICAgICB4ZVtqXSA9IHhbaV07XG4gICAgICAgIHllW2pdID0geVtpXTtcbiAgICB9XG4gICAgZmZ0cG93Mih4ZSx5ZSk7XG4gICAgZmZ0cG93Mih4byx5byk7XG4gICAgaiA9IG4vMjtcbiAgICB2YXIgdCxrID0gKC02LjI4MzE4NTMwNzE3OTU4NjQ3NjkyNTI4Njc2NjU1OTAwNTc2ODM5NDMzODc5ODc1MDIxMTY0MTkvbiksY2ksc2k7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgLS1qO1xuICAgICAgICBpZihqID09PSAtMSkgaiA9IG4vMi0xO1xuICAgICAgICB0ID0gayppO1xuICAgICAgICBjaSA9IGNvcyh0KTtcbiAgICAgICAgc2kgPSBzaW4odCk7XG4gICAgICAgIHhbaV0gPSB4ZVtqXSArIGNpKnhvW2pdIC0gc2kqeW9bal07XG4gICAgICAgIHlbaV0gPSB5ZVtqXSArIGNpKnlvW2pdICsgc2kqeG9bal07XG4gICAgfVxufVxubnVtZXJpYy5faWZmdHBvdzIgPSBmdW5jdGlvbiBfaWZmdHBvdzIoeCx5KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuID09PSAxKSByZXR1cm47XG4gICAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgaSxqO1xuICAgIHZhciB4ZSA9IEFycmF5KG4vMiksIHllID0gQXJyYXkobi8yKSwgeG8gPSBBcnJheShuLzIpLCB5byA9IEFycmF5KG4vMik7XG4gICAgaiA9IG4vMjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIHhvW2pdID0geFtpXTtcbiAgICAgICAgeW9bal0gPSB5W2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhlW2pdID0geFtpXTtcbiAgICAgICAgeWVbal0gPSB5W2ldO1xuICAgIH1cbiAgICBfaWZmdHBvdzIoeGUseWUpO1xuICAgIF9pZmZ0cG93Mih4byx5byk7XG4gICAgaiA9IG4vMjtcbiAgICB2YXIgdCxrID0gKDYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MDA1NzY4Mzk0MzM4Nzk4NzUwMjExNjQxOS9uKSxjaSxzaTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIGlmKGogPT09IC0xKSBqID0gbi8yLTE7XG4gICAgICAgIHQgPSBrKmk7XG4gICAgICAgIGNpID0gY29zKHQpO1xuICAgICAgICBzaSA9IHNpbih0KTtcbiAgICAgICAgeFtpXSA9IHhlW2pdICsgY2kqeG9bal0gLSBzaSp5b1tqXTtcbiAgICAgICAgeVtpXSA9IHllW2pdICsgY2kqeW9bal0gKyBzaSp4b1tqXTtcbiAgICB9XG59XG5udW1lcmljLmlmZnRwb3cyID0gZnVuY3Rpb24gaWZmdHBvdzIoeCx5KSB7XG4gICAgbnVtZXJpYy5faWZmdHBvdzIoeCx5KTtcbiAgICBudW1lcmljLmRpdmVxKHgseC5sZW5ndGgpO1xuICAgIG51bWVyaWMuZGl2ZXEoeSx5Lmxlbmd0aCk7XG59XG5udW1lcmljLmNvbnZwb3cyID0gZnVuY3Rpb24gY29udnBvdzIoYXgsYXksYngsYnkpIHtcbiAgICBudW1lcmljLmZmdHBvdzIoYXgsYXkpO1xuICAgIG51bWVyaWMuZmZ0cG93MihieCxieSk7XG4gICAgdmFyIGksbiA9IGF4Lmxlbmd0aCxheGksYnhpLGF5aSxieWk7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgYXhpID0gYXhbaV07IGF5aSA9IGF5W2ldOyBieGkgPSBieFtpXTsgYnlpID0gYnlbaV07XG4gICAgICAgIGF4W2ldID0gYXhpKmJ4aS1heWkqYnlpO1xuICAgICAgICBheVtpXSA9IGF4aSpieWkrYXlpKmJ4aTtcbiAgICB9XG4gICAgbnVtZXJpYy5pZmZ0cG93MihheCxheSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmZmdCA9IGZ1bmN0aW9uIGZmdCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBsb2cgPSBNYXRoLmxvZywgbG9nMiA9IGxvZygyKSxcbiAgICAgICAgcCA9IE1hdGguY2VpbChsb2coMipuLTEpL2xvZzIpLCBtID0gTWF0aC5wb3coMixwKTtcbiAgICB2YXIgY3ggPSBudW1lcmljLnJlcChbbV0sMCksIGN5ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGssIGMgPSAoLTMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwL24pLHQ7XG4gICAgdmFyIGEgPSBudW1lcmljLnJlcChbbV0sMCksIGIgPSBudW1lcmljLnJlcChbbV0sMCksbmhhbGYgPSBNYXRoLmZsb29yKG4vMik7XG4gICAgZm9yKGs9MDtrPG47aysrKSBhW2tdID0geFtrXTtcbiAgICBpZih0eXBlb2YgeSAhPT0gXCJ1bmRlZmluZWRcIikgZm9yKGs9MDtrPG47aysrKSBiW2tdID0geVtrXTtcbiAgICBjeFswXSA9IDE7XG4gICAgZm9yKGs9MTtrPD1tLzI7aysrKSB7XG4gICAgICAgIHQgPSBjKmsqaztcbiAgICAgICAgY3hba10gPSBjb3ModCk7XG4gICAgICAgIGN5W2tdID0gc2luKHQpO1xuICAgICAgICBjeFttLWtdID0gY29zKHQpO1xuICAgICAgICBjeVttLWtdID0gc2luKHQpXG4gICAgfVxuICAgIHZhciBYID0gbmV3IG51bWVyaWMuVChhLGIpLCBZID0gbmV3IG51bWVyaWMuVChjeCxjeSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIG51bWVyaWMuY29udnBvdzIoWC54LFgueSxudW1lcmljLmNsb25lKFkueCksbnVtZXJpYy5uZWcoWS55KSk7XG4gICAgWCA9IFgubXVsKFkpO1xuICAgIFgueC5sZW5ndGggPSBuO1xuICAgIFgueS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBYO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5pZmZ0ID0gZnVuY3Rpb24gaWZmdCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICB2YXIgbiA9IHgubGVuZ3RoLCBsb2cgPSBNYXRoLmxvZywgbG9nMiA9IGxvZygyKSxcbiAgICAgICAgcCA9IE1hdGguY2VpbChsb2coMipuLTEpL2xvZzIpLCBtID0gTWF0aC5wb3coMixwKTtcbiAgICB2YXIgY3ggPSBudW1lcmljLnJlcChbbV0sMCksIGN5ID0gbnVtZXJpYy5yZXAoW21dLDApLCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGssIGMgPSAoMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjAvbiksdDtcbiAgICB2YXIgYSA9IG51bWVyaWMucmVwKFttXSwwKSwgYiA9IG51bWVyaWMucmVwKFttXSwwKSxuaGFsZiA9IE1hdGguZmxvb3Iobi8yKTtcbiAgICBmb3Ioaz0wO2s8bjtrKyspIGFba10gPSB4W2tdO1xuICAgIGlmKHR5cGVvZiB5ICE9PSBcInVuZGVmaW5lZFwiKSBmb3Ioaz0wO2s8bjtrKyspIGJba10gPSB5W2tdO1xuICAgIGN4WzBdID0gMTtcbiAgICBmb3Ioaz0xO2s8PW0vMjtrKyspIHtcbiAgICAgICAgdCA9IGMqayprO1xuICAgICAgICBjeFtrXSA9IGNvcyh0KTtcbiAgICAgICAgY3lba10gPSBzaW4odCk7XG4gICAgICAgIGN4W20ta10gPSBjb3ModCk7XG4gICAgICAgIGN5W20ta10gPSBzaW4odClcbiAgICB9XG4gICAgdmFyIFggPSBuZXcgbnVtZXJpYy5UKGEsYiksIFkgPSBuZXcgbnVtZXJpYy5UKGN4LGN5KTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgbnVtZXJpYy5jb252cG93MihYLngsWC55LG51bWVyaWMuY2xvbmUoWS54KSxudW1lcmljLm5lZyhZLnkpKTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgWC54Lmxlbmd0aCA9IG47XG4gICAgWC55Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIFguZGl2KG4pO1xufVxuXG4vLzkuIFVuY29uc3RyYWluZWQgb3B0aW1pemF0aW9uXG5udW1lcmljLmdyYWRpZW50ID0gZnVuY3Rpb24gZ3JhZGllbnQoZix4KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICB2YXIgZjAgPSBmKHgpO1xuICAgIGlmKGlzTmFOKGYwKSkgdGhyb3cgbmV3IEVycm9yKCdncmFkaWVudDogZih4KSBpcyBhIE5hTiEnKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIGkseDAgPSBudW1lcmljLmNsb25lKHgpLGYxLGYyLCBKID0gQXJyYXkobik7XG4gICAgdmFyIGRpdiA9IG51bWVyaWMuZGl2LCBzdWIgPSBudW1lcmljLnN1YixlcnJlc3Qscm91bmRvZmYsbWF4ID0gTWF0aC5tYXgsZXBzID0gMWUtMyxhYnMgPSBNYXRoLmFicywgbWluID0gTWF0aC5taW47XG4gICAgdmFyIHQwLHQxLHQyLGl0PTAsZDEsZDIsTjtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgdmFyIGggPSBtYXgoMWUtNipmMCwxZS04KTtcbiAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgKytpdDtcbiAgICAgICAgICAgIGlmKGl0PjIwKSB7IHRocm93IG5ldyBFcnJvcihcIk51bWVyaWNhbCBncmFkaWVudCBmYWlsc1wiKTsgfVxuICAgICAgICAgICAgeDBbaV0gPSB4W2ldK2g7XG4gICAgICAgICAgICBmMSA9IGYoeDApO1xuICAgICAgICAgICAgeDBbaV0gPSB4W2ldLWg7XG4gICAgICAgICAgICBmMiA9IGYoeDApO1xuICAgICAgICAgICAgeDBbaV0gPSB4W2ldO1xuICAgICAgICAgICAgaWYoaXNOYU4oZjEpIHx8IGlzTmFOKGYyKSkgeyBoLz0xNjsgY29udGludWU7IH1cbiAgICAgICAgICAgIEpbaV0gPSAoZjEtZjIpLygyKmgpO1xuICAgICAgICAgICAgdDAgPSB4W2ldLWg7XG4gICAgICAgICAgICB0MSA9IHhbaV07XG4gICAgICAgICAgICB0MiA9IHhbaV0raDtcbiAgICAgICAgICAgIGQxID0gKGYxLWYwKS9oO1xuICAgICAgICAgICAgZDIgPSAoZjAtZjIpL2g7XG4gICAgICAgICAgICBOID0gbWF4KGFicyhKW2ldKSxhYnMoZjApLGFicyhmMSksYWJzKGYyKSxhYnModDApLGFicyh0MSksYWJzKHQyKSwxZS04KTtcbiAgICAgICAgICAgIGVycmVzdCA9IG1pbihtYXgoYWJzKGQxLUpbaV0pLGFicyhkMi1KW2ldKSxhYnMoZDEtZDIpKS9OLGgvTik7XG4gICAgICAgICAgICBpZihlcnJlc3Q+ZXBzKSB7IGgvPTE2OyB9XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSjtcbn1cblxubnVtZXJpYy51bmNtaW4gPSBmdW5jdGlvbiB1bmNtaW4oZix4MCx0b2wsZ3JhZGllbnQsbWF4aXQsY2FsbGJhY2ssb3B0aW9ucykge1xuICAgIHZhciBncmFkID0gbnVtZXJpYy5ncmFkaWVudDtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikgeyBvcHRpb25zID0ge307IH1cbiAgICBpZih0eXBlb2YgdG9sID09PSBcInVuZGVmaW5lZFwiKSB7IHRvbCA9IDFlLTg7IH1cbiAgICBpZih0eXBlb2YgZ3JhZGllbnQgPT09IFwidW5kZWZpbmVkXCIpIHsgZ3JhZGllbnQgPSBmdW5jdGlvbih4KSB7IHJldHVybiBncmFkKGYseCk7IH07IH1cbiAgICBpZih0eXBlb2YgbWF4aXQgPT09IFwidW5kZWZpbmVkXCIpIG1heGl0ID0gMTAwMDtcbiAgICB4MCA9IG51bWVyaWMuY2xvbmUoeDApO1xuICAgIHZhciBuID0geDAubGVuZ3RoO1xuICAgIHZhciBmMCA9IGYoeDApLGYxLGRmMDtcbiAgICBpZihpc05hTihmMCkpIHRocm93IG5ldyBFcnJvcigndW5jbWluOiBmKHgwKSBpcyBhIE5hTiEnKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgsIG5vcm0yID0gbnVtZXJpYy5ub3JtMjtcbiAgICB0b2wgPSBtYXgodG9sLG51bWVyaWMuZXBzaWxvbik7XG4gICAgdmFyIHN0ZXAsZzAsZzEsSDEgPSBvcHRpb25zLkhpbnYgfHwgbnVtZXJpYy5pZGVudGl0eShuKTtcbiAgICB2YXIgZG90ID0gbnVtZXJpYy5kb3QsIGludiA9IG51bWVyaWMuaW52LCBzdWIgPSBudW1lcmljLnN1YiwgYWRkID0gbnVtZXJpYy5hZGQsIHRlbiA9IG51bWVyaWMudGVuc29yLCBkaXYgPSBudW1lcmljLmRpdiwgbXVsID0gbnVtZXJpYy5tdWw7XG4gICAgdmFyIGFsbCA9IG51bWVyaWMuYWxsLCBpc2Zpbml0ZSA9IG51bWVyaWMuaXNGaW5pdGUsIG5lZyA9IG51bWVyaWMubmVnO1xuICAgIHZhciBpdD0wLGkscyx4MSx5LEh5LEhzLHlzLGkwLHQsbnN0ZXAsdDEsdDI7XG4gICAgdmFyIG1zZyA9IFwiXCI7XG4gICAgZzAgPSBncmFkaWVudCh4MCk7XG4gICAgd2hpbGUoaXQ8bWF4aXQpIHtcbiAgICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHsgaWYoY2FsbGJhY2soaXQseDAsZjAsZzAsSDEpKSB7IG1zZyA9IFwiQ2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZVwiOyBicmVhazsgfSB9XG4gICAgICAgIGlmKCFhbGwoaXNmaW5pdGUoZzApKSkgeyBtc2cgPSBcIkdyYWRpZW50IGhhcyBJbmZpbml0eSBvciBOYU5cIjsgYnJlYWs7IH1cbiAgICAgICAgc3RlcCA9IG5lZyhkb3QoSDEsZzApKTtcbiAgICAgICAgaWYoIWFsbChpc2Zpbml0ZShzdGVwKSkpIHsgbXNnID0gXCJTZWFyY2ggZGlyZWN0aW9uIGhhcyBJbmZpbml0eSBvciBOYU5cIjsgYnJlYWs7IH1cbiAgICAgICAgbnN0ZXAgPSBub3JtMihzdGVwKTtcbiAgICAgICAgaWYobnN0ZXAgPCB0b2wpIHsgbXNnPVwiTmV3dG9uIHN0ZXAgc21hbGxlciB0aGFuIHRvbFwiOyBicmVhazsgfVxuICAgICAgICB0ID0gMTtcbiAgICAgICAgZGYwID0gZG90KGcwLHN0ZXApO1xuICAgICAgICAvLyBsaW5lIHNlYXJjaFxuICAgICAgICB4MSA9IHgwO1xuICAgICAgICB3aGlsZShpdCA8IG1heGl0KSB7XG4gICAgICAgICAgICBpZih0Km5zdGVwIDwgdG9sKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICBzID0gbXVsKHN0ZXAsdCk7XG4gICAgICAgICAgICB4MSA9IGFkZCh4MCxzKTtcbiAgICAgICAgICAgIGYxID0gZih4MSk7XG4gICAgICAgICAgICBpZihmMS1mMCA+PSAwLjEqdCpkZjAgfHwgaXNOYU4oZjEpKSB7XG4gICAgICAgICAgICAgICAgdCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgKytpdDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHQqbnN0ZXAgPCB0b2wpIHsgbXNnID0gXCJMaW5lIHNlYXJjaCBzdGVwIHNpemUgc21hbGxlciB0aGFuIHRvbFwiOyBicmVhazsgfVxuICAgICAgICBpZihpdCA9PT0gbWF4aXQpIHsgbXNnID0gXCJtYXhpdCByZWFjaGVkIGR1cmluZyBsaW5lIHNlYXJjaFwiOyBicmVhazsgfVxuICAgICAgICBnMSA9IGdyYWRpZW50KHgxKTtcbiAgICAgICAgeSA9IHN1YihnMSxnMCk7XG4gICAgICAgIHlzID0gZG90KHkscyk7XG4gICAgICAgIEh5ID0gZG90KEgxLHkpO1xuICAgICAgICBIMSA9IHN1YihhZGQoSDEsXG4gICAgICAgICAgICAgICAgbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHlzK2RvdCh5LEh5KSkvKHlzKnlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbihzLHMpICAgICkpLFxuICAgICAgICAgICAgICAgIGRpdihhZGQodGVuKEh5LHMpLHRlbihzLEh5KSkseXMpKTtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgZjAgPSBmMTtcbiAgICAgICAgZzAgPSBnMTtcbiAgICAgICAgKytpdDtcbiAgICB9XG4gICAgcmV0dXJuIHtzb2x1dGlvbjogeDAsIGY6IGYwLCBncmFkaWVudDogZzAsIGludkhlc3NpYW46IEgxLCBpdGVyYXRpb25zOml0LCBtZXNzYWdlOiBtc2d9O1xufVxuXG4vLyAxMC4gT2RlIHNvbHZlciAoRG9ybWFuZC1QcmluY2UpXG5udW1lcmljLkRvcHJpID0gZnVuY3Rpb24gRG9wcmkoeCx5LGYseW1pZCxpdGVyYXRpb25zLG1zZyxldmVudHMpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLnltaWQgPSB5bWlkO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxubnVtZXJpYy5Eb3ByaS5wcm90b3R5cGUuX2F0ID0gZnVuY3Rpb24gX2F0KHhpLGopIHtcbiAgICBmdW5jdGlvbiBzcXIoeCkgeyByZXR1cm4geCp4OyB9XG4gICAgdmFyIHNvbCA9IHRoaXM7XG4gICAgdmFyIHhzID0gc29sLng7XG4gICAgdmFyIHlzID0gc29sLnk7XG4gICAgdmFyIGsxID0gc29sLmY7XG4gICAgdmFyIHltaWQgPSBzb2wueW1pZDtcbiAgICB2YXIgbiA9IHhzLmxlbmd0aDtcbiAgICB2YXIgeDAseDEseGgseTAseTEseWgseGk7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcixoO1xuICAgIHZhciBjID0gMC41O1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsc3ViID0gbnVtZXJpYy5zdWIsIHAscSx3O1xuICAgIHgwID0geHNbal07XG4gICAgeDEgPSB4c1tqKzFdO1xuICAgIHkwID0geXNbal07XG4gICAgeTEgPSB5c1tqKzFdO1xuICAgIGggID0geDEteDA7XG4gICAgeGggPSB4MCtjKmg7XG4gICAgeWggPSB5bWlkW2pdO1xuICAgIHAgPSBzdWIoazFbaiAgXSxtdWwoeTAsMS8oeDAteGgpKzIvKHgwLXgxKSkpO1xuICAgIHEgPSBzdWIoazFbaisxXSxtdWwoeTEsMS8oeDEteGgpKzIvKHgxLXgwKSkpO1xuICAgIHcgPSBbc3FyKHhpIC0geDEpICogKHhpIC0geGgpIC8gc3FyKHgwIC0geDEpIC8gKHgwIC0geGgpLFxuICAgICAgICAgc3FyKHhpIC0geDApICogc3FyKHhpIC0geDEpIC8gc3FyKHgwIC0geGgpIC8gc3FyKHgxIC0geGgpLFxuICAgICAgICAgc3FyKHhpIC0geDApICogKHhpIC0geGgpIC8gc3FyKHgxIC0geDApIC8gKHgxIC0geGgpLFxuICAgICAgICAgKHhpIC0geDApICogc3FyKHhpIC0geDEpICogKHhpIC0geGgpIC8gc3FyKHgwLXgxKSAvICh4MCAtIHhoKSxcbiAgICAgICAgICh4aSAtIHgxKSAqIHNxcih4aSAtIHgwKSAqICh4aSAtIHhoKSAvIHNxcih4MC14MSkgLyAoeDEgLSB4aCldO1xuICAgIHJldHVybiBhZGQoYWRkKGFkZChhZGQobXVsKHkwLHdbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKHloLHdbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCh5MSx3WzJdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoIHAsd1szXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKCBxLHdbNF0pKTtcbn1cbm51bWVyaWMuRG9wcmkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQoeCkge1xuICAgIHZhciBpLGosayxmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgaWYodHlwZW9mIHggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFyIG4gPSB4Lmxlbmd0aCwgcmV0ID0gQXJyYXkobik7XG4gICAgICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICByZXRbaV0gPSB0aGlzLmF0KHhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHZhciB4MCA9IHRoaXMueDtcbiAgICBpID0gMDsgaiA9IHgwLmxlbmd0aC0xO1xuICAgIHdoaWxlKGotaT4xKSB7XG4gICAgICAgIGsgPSBmbG9vcigwLjUqKGkraikpO1xuICAgICAgICBpZih4MFtrXSA8PSB4KSBpID0gaztcbiAgICAgICAgZWxzZSBqID0gaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F0KHgsaSk7XG59XG5cbm51bWVyaWMuZG9wcmkgPSBmdW5jdGlvbiBkb3ByaSh4MCx4MSx5MCxmLHRvbCxtYXhpdCxldmVudCkge1xuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHsgdG9sID0gMWUtNjsgfVxuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgeyBtYXhpdCA9IDEwMDA7IH1cbiAgICB2YXIgeHMgPSBbeDBdLCB5cyA9IFt5MF0sIGsxID0gW2YoeDAseTApXSwgazIsazMsazQsazUsazYsazcsIHltaWQgPSBbXTtcbiAgICB2YXIgQTIgPSAxLzU7XG4gICAgdmFyIEEzID0gWzMvNDAsOS80MF07XG4gICAgdmFyIEE0ID0gWzQ0LzQ1LC01Ni8xNSwzMi85XTtcbiAgICB2YXIgQTUgPSBbMTkzNzIvNjU2MSwtMjUzNjAvMjE4Nyw2NDQ0OC82NTYxLC0yMTIvNzI5XTtcbiAgICB2YXIgQTYgPSBbOTAxNy8zMTY4LC0zNTUvMzMsNDY3MzIvNTI0Nyw0OS8xNzYsLTUxMDMvMTg2NTZdO1xuICAgIHZhciBiID0gWzM1LzM4NCwwLDUwMC8xMTEzLDEyNS8xOTIsLTIxODcvNjc4NCwxMS84NF07XG4gICAgdmFyIGJtID0gWzAuNSo2MDI1MTkyNzQzLzMwMDg1NTUzMTUyLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLjUqNTEyNTIyOTI5MjUvNjU0MDA4MjE1OTgsXG4gICAgICAgICAgICAgIDAuNSotMjY5MTg2ODkyNS80NTEyODMyOTcyOCxcbiAgICAgICAgICAgICAgMC41KjE4Nzk0MDM3MjA2Ny8xNTk0NTM0MzE3MDU2LFxuICAgICAgICAgICAgICAwLjUqLTE3NzYwOTQzMzEvMTk3NDM2NDQyNTYsXG4gICAgICAgICAgICAgIDAuNSoxMTIzNzA5OS8yMzUwNDMzODRdO1xuICAgIHZhciBjID0gWzEvNSwzLzEwLDQvNSw4LzksMSwxXTtcbiAgICB2YXIgZSA9IFstNzEvNTc2MDAsMCw3MS8xNjY5NSwtNzEvMTkyMCwxNzI1My8zMzkyMDAsLTIyLzUyNSwxLzQwXTtcbiAgICB2YXIgaSA9IDAsZXIsajtcbiAgICB2YXIgaCA9ICh4MS14MCkvMTA7XG4gICAgdmFyIGl0ID0gMDtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLCB5MSxlcmluZjtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgsIG1pbiA9IE1hdGgubWluLCBhYnMgPSBNYXRoLmFicywgbm9ybWluZiA9IG51bWVyaWMubm9ybWluZixwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgYW55ID0gbnVtZXJpYy5hbnksIGx0ID0gbnVtZXJpYy5sdCwgYW5kID0gbnVtZXJpYy5hbmQsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIHZhciBlMCwgZTEsIGV2O1xuICAgIHZhciByZXQgPSBuZXcgbnVtZXJpYy5Eb3ByaSh4cyx5cyxrMSx5bWlkLC0xLFwiXCIpO1xuICAgIGlmKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSBlMCA9IGV2ZW50KHgwLHkwKTtcbiAgICB3aGlsZSh4MDx4MSAmJiBpdDxtYXhpdCkge1xuICAgICAgICArK2l0O1xuICAgICAgICBpZih4MCtoPngxKSBoID0geDEteDA7XG4gICAgICAgIGsyID0gZih4MCtjWzBdKmgsICAgICAgICAgICAgICAgIGFkZCh5MCxtdWwoICAgQTIqaCxrMVtpXSkpKTtcbiAgICAgICAgazMgPSBmKHgwK2NbMV0qaCwgICAgICAgICAgICBhZGQoYWRkKHkwLG11bChBM1swXSpoLGsxW2ldKSksbXVsKEEzWzFdKmgsazIpKSk7XG4gICAgICAgIGs0ID0gZih4MCtjWzJdKmgsICAgICAgICBhZGQoYWRkKGFkZCh5MCxtdWwoQTRbMF0qaCxrMVtpXSkpLG11bChBNFsxXSpoLGsyKSksbXVsKEE0WzJdKmgsazMpKSk7XG4gICAgICAgIGs1ID0gZih4MCtjWzNdKmgsICAgIGFkZChhZGQoYWRkKGFkZCh5MCxtdWwoQTVbMF0qaCxrMVtpXSkpLG11bChBNVsxXSpoLGsyKSksbXVsKEE1WzJdKmgsazMpKSxtdWwoQTVbM10qaCxrNCkpKTtcbiAgICAgICAgazYgPSBmKHgwK2NbNF0qaCxhZGQoYWRkKGFkZChhZGQoYWRkKHkwLG11bChBNlswXSpoLGsxW2ldKSksbXVsKEE2WzFdKmgsazIpKSxtdWwoQTZbMl0qaCxrMykpLG11bChBNlszXSpoLGs0KSksbXVsKEE2WzRdKmgsazUpKSk7XG4gICAgICAgIHkxID0gYWRkKGFkZChhZGQoYWRkKGFkZCh5MCxtdWwoazFbaV0saCpiWzBdKSksbXVsKGszLGgqYlsyXSkpLG11bChrNCxoKmJbM10pKSxtdWwoazUsaCpiWzRdKSksbXVsKGs2LGgqYls1XSkpO1xuICAgICAgICBrNyA9IGYoeDAraCx5MSk7XG4gICAgICAgIGVyID0gYWRkKGFkZChhZGQoYWRkKGFkZChtdWwoazFbaV0saCplWzBdKSxtdWwoazMsaCplWzJdKSksbXVsKGs0LGgqZVszXSkpLG11bChrNSxoKmVbNF0pKSxtdWwoazYsaCplWzVdKSksbXVsKGs3LGgqZVs2XSkpO1xuICAgICAgICBpZih0eXBlb2YgZXIgPT09IFwibnVtYmVyXCIpIGVyaW5mID0gYWJzKGVyKTtcbiAgICAgICAgZWxzZSBlcmluZiA9IG5vcm1pbmYoZXIpO1xuICAgICAgICBpZihlcmluZiA+IHRvbCkgeyAvLyByZWplY3RcbiAgICAgICAgICAgIGggPSAwLjIqaCpwb3codG9sL2VyaW5mLDAuMjUpO1xuICAgICAgICAgICAgaWYoeDAraCA9PT0geDApIHtcbiAgICAgICAgICAgICAgICByZXQubXNnID0gXCJTdGVwIHNpemUgYmVjYW1lIHRvbyBzbWFsbFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeW1pZFtpXSA9IGFkZChhZGQoYWRkKGFkZChhZGQoYWRkKHkwLFxuICAgICAgICAgICAgICAgIG11bChrMVtpXSxoKmJtWzBdKSksXG4gICAgICAgICAgICAgICAgbXVsKGszICAgLGgqYm1bMl0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazQgICAsaCpibVszXSkpLFxuICAgICAgICAgICAgICAgIG11bChrNSAgICxoKmJtWzRdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs2ICAgLGgqYm1bNV0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazcgICAsaCpibVs2XSkpO1xuICAgICAgICArK2k7XG4gICAgICAgIHhzW2ldID0geDAraDtcbiAgICAgICAgeXNbaV0gPSB5MTtcbiAgICAgICAgazFbaV0gPSBrNztcbiAgICAgICAgaWYodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciB5aSx4bCA9IHgwLHhyID0geDArMC41KmgseGk7XG4gICAgICAgICAgICBlMSA9IGV2ZW50KHhyLHltaWRbaS0xXSk7XG4gICAgICAgICAgICBldiA9IGFuZChsdChlMCwwKSxsdCgwLGUxKSk7XG4gICAgICAgICAgICBpZighYW55KGV2KSkgeyB4bCA9IHhyOyB4ciA9IHgwK2g7IGUwID0gZTE7IGUxID0gZXZlbnQoeHIseTEpOyBldiA9IGFuZChsdChlMCwwKSxsdCgwLGUxKSk7IH1cbiAgICAgICAgICAgIGlmKGFueShldikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGMsIHljLCBlbixlaTtcbiAgICAgICAgICAgICAgICB2YXIgc2lkZT0wLCBzbCA9IDEuMCwgc3IgPSAxLjA7XG4gICAgICAgICAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZTAgPT09IFwibnVtYmVyXCIpIHhpID0gKHNyKmUxKnhsLXNsKmUwKnhyKS8oc3IqZTEtc2wqZTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Ioaj1lMC5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZTBbal08MCAmJiBlMVtqXT4wKSB4aSA9IG1pbih4aSwoc3IqZTFbal0qeGwtc2wqZTBbal0qeHIpLyhzciplMVtqXS1zbCplMFtqXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHhpIDw9IHhsIHx8IHhpID49IHhyKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgeWkgPSByZXQuX2F0KHhpLCBpLTEpO1xuICAgICAgICAgICAgICAgICAgICBlaSA9IGV2ZW50KHhpLHlpKTtcbiAgICAgICAgICAgICAgICAgICAgZW4gPSBhbmQobHQoZTAsMCksbHQoMCxlaSkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhbnkoZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ciA9IHhpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZTEgPSBlaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ID0gZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IC0xKSBzbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHNsID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGwgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUwID0gZWk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZGUgPT09IDEpIHNyICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugc3IgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5MSA9IHJldC5fYXQoMC41Kih4MCt4aSksaS0xKTtcbiAgICAgICAgICAgICAgICByZXQuZltpXSA9IGYoeGkseWkpO1xuICAgICAgICAgICAgICAgIHJldC54W2ldID0geGk7XG4gICAgICAgICAgICAgICAgcmV0LnlbaV0gPSB5aTtcbiAgICAgICAgICAgICAgICByZXQueW1pZFtpLTFdID0geTE7XG4gICAgICAgICAgICAgICAgcmV0LmV2ZW50cyA9IGV2O1xuICAgICAgICAgICAgICAgIHJldC5pdGVyYXRpb25zID0gaXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4MCArPSBoO1xuICAgICAgICB5MCA9IHkxO1xuICAgICAgICBlMCA9IGUxO1xuICAgICAgICBoID0gbWluKDAuOCpoKnBvdyh0b2wvZXJpbmYsMC4yNSksNCpoKTtcbiAgICB9XG4gICAgcmV0Lml0ZXJhdGlvbnMgPSBpdDtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyAxMS4gQXggPSBiXG5udW1lcmljLkxVID0gZnVuY3Rpb24oQSwgZmFzdCkge1xuICBmYXN0ID0gZmFzdCB8fCBmYWxzZTtcblxuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBpLCBqLCBrLCBhYnNBamssIEFraywgQWssIFBrLCBBaTtcbiAgdmFyIG1heDtcbiAgdmFyIG4gPSBBLmxlbmd0aCwgbjEgPSBuLTE7XG4gIHZhciBQID0gbmV3IEFycmF5KG4pO1xuICBpZighZmFzdCkgQSA9IG51bWVyaWMuY2xvbmUoQSk7XG5cbiAgZm9yIChrID0gMDsgayA8IG47ICsraykge1xuICAgIFBrID0gaztcbiAgICBBayA9IEFba107XG4gICAgbWF4ID0gYWJzKEFrW2tdKTtcbiAgICBmb3IgKGogPSBrICsgMTsgaiA8IG47ICsraikge1xuICAgICAgYWJzQWprID0gYWJzKEFbal1ba10pO1xuICAgICAgaWYgKG1heCA8IGFic0Fqaykge1xuICAgICAgICBtYXggPSBhYnNBams7XG4gICAgICAgIFBrID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgUFtrXSA9IFBrO1xuXG4gICAgaWYgKFBrICE9IGspIHtcbiAgICAgIEFba10gPSBBW1BrXTtcbiAgICAgIEFbUGtdID0gQWs7XG4gICAgICBBayA9IEFba107XG4gICAgfVxuXG4gICAgQWtrID0gQWtba107XG5cbiAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47ICsraSkge1xuICAgICAgQVtpXVtrXSAvPSBBa2s7XG4gICAgfVxuXG4gICAgZm9yIChpID0gayArIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIEFpID0gQVtpXTtcbiAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjE7ICsraikge1xuICAgICAgICBBaVtqXSAtPSBBaVtrXSAqIEFrW2pdO1xuICAgICAgICArK2o7XG4gICAgICAgIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgICB9XG4gICAgICBpZihqPT09bjEpIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBMVTogQSxcbiAgICBQOiAgUFxuICB9O1xufVxuXG5udW1lcmljLkxVc29sdmUgPSBmdW5jdGlvbiBMVXNvbHZlKExVUCwgYikge1xuICB2YXIgaSwgajtcbiAgdmFyIExVID0gTFVQLkxVO1xuICB2YXIgbiAgID0gTFUubGVuZ3RoO1xuICB2YXIgeCA9IG51bWVyaWMuY2xvbmUoYik7XG4gIHZhciBQICAgPSBMVVAuUDtcbiAgdmFyIFBpLCBMVWksIExVaWksIHRtcDtcblxuICBmb3IgKGk9bi0xO2khPT0tMTstLWkpIHhbaV0gPSBiW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgUGkgPSBQW2ldO1xuICAgIGlmIChQW2ldICE9PSBpKSB7XG4gICAgICB0bXAgPSB4W2ldO1xuICAgICAgeFtpXSA9IHhbUGldO1xuICAgICAgeFtQaV0gPSB0bXA7XG4gICAgfVxuXG4gICAgTFVpID0gTFVbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IGk7ICsraikge1xuICAgICAgeFtpXSAtPSB4W2pdICogTFVpW2pdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgIExVaSA9IExVW2ldO1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICB4W2ldIC09IHhbal0gKiBMVWlbal07XG4gICAgfVxuXG4gICAgeFtpXSAvPSBMVWlbaV07XG4gIH1cblxuICByZXR1cm4geDtcbn1cblxubnVtZXJpYy5zb2x2ZSA9IGZ1bmN0aW9uIHNvbHZlKEEsYixmYXN0KSB7IHJldHVybiBudW1lcmljLkxVc29sdmUobnVtZXJpYy5MVShBLGZhc3QpLCBiKTsgfVxuXG4vLyAxMi4gTGluZWFyIHByb2dyYW1taW5nXG5udW1lcmljLmVjaGVsb25pemUgPSBmdW5jdGlvbiBlY2hlbG9uaXplKEEpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEEpLCBtID0gc1swXSwgbiA9IHNbMV07XG4gICAgdmFyIEkgPSBudW1lcmljLmlkZW50aXR5KG0pO1xuICAgIHZhciBQID0gQXJyYXkobSk7XG4gICAgdmFyIGksaixrLGwsQWksSWksWixhO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgZGl2ZXEgPSBudW1lcmljLmRpdmVxO1xuICAgIEEgPSBudW1lcmljLmNsb25lKEEpO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBrID0gMDtcbiAgICAgICAgQWkgPSBBW2ldO1xuICAgICAgICBJaSA9IElbaV07XG4gICAgICAgIGZvcihqPTE7ajxuOysraikgaWYoYWJzKEFpW2tdKTxhYnMoQWlbal0pKSBrPWo7XG4gICAgICAgIFBbaV0gPSBrO1xuICAgICAgICBkaXZlcShJaSxBaVtrXSk7XG4gICAgICAgIGRpdmVxKEFpLEFpW2tdKTtcbiAgICAgICAgZm9yKGo9MDtqPG07KytqKSBpZihqIT09aSkge1xuICAgICAgICAgICAgWiA9IEFbal07IGEgPSBaW2tdO1xuICAgICAgICAgICAgZm9yKGw9bi0xO2whPT0tMTstLWwpIFpbbF0gLT0gQWlbbF0qYTtcbiAgICAgICAgICAgIFogPSBJW2pdO1xuICAgICAgICAgICAgZm9yKGw9bS0xO2whPT0tMTstLWwpIFpbbF0gLT0gSWlbbF0qYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge0k6SSwgQTpBLCBQOlB9O1xufVxuXG5udW1lcmljLl9fc29sdmVMUCA9IGZ1bmN0aW9uIF9fc29sdmVMUChjLEEsYix0b2wsbWF4aXQseCxmbGFnKSB7XG4gICAgdmFyIHN1bSA9IG51bWVyaWMuc3VtLCBsb2cgPSBudW1lcmljLmxvZywgbXVsID0gbnVtZXJpYy5tdWwsIHN1YiA9IG51bWVyaWMuc3ViLCBkb3QgPSBudW1lcmljLmRvdCwgZGl2ID0gbnVtZXJpYy5kaXYsIGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIHZhciBtID0gYy5sZW5ndGgsIG4gPSBiLmxlbmd0aCx5O1xuICAgIHZhciB1bmJvdW5kZWQgPSBmYWxzZSwgY2IsaTA9MDtcbiAgICB2YXIgYWxwaGEgPSAxLjA7XG4gICAgdmFyIGYwLGRmMCxBVCA9IG51bWVyaWMudHJhbnNwb3NlKEEpLCBzdmQgPSBudW1lcmljLnN2ZCx0cmFuc3Bvc2UgPSBudW1lcmljLnRyYW5zcG9zZSxsZXEgPSBudW1lcmljLmxlcSwgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIG11bGVxID0gbnVtZXJpYy5tdWxlcTtcbiAgICB2YXIgbm9ybSA9IG51bWVyaWMubm9ybWluZiwgYW55ID0gbnVtZXJpYy5hbnksbWluID0gTWF0aC5taW47XG4gICAgdmFyIGFsbCA9IG51bWVyaWMuYWxsLCBndCA9IG51bWVyaWMuZ3Q7XG4gICAgdmFyIHAgPSBBcnJheShtKSwgQTAgPSBBcnJheShuKSxlPW51bWVyaWMucmVwKFtuXSwxKSwgSDtcbiAgICB2YXIgc29sdmUgPSBudW1lcmljLnNvbHZlLCB6ID0gc3ViKGIsZG90KEEseCkpLGNvdW50O1xuICAgIHZhciBkb3RjYyA9IGRvdChjLGMpO1xuICAgIHZhciBnO1xuICAgIGZvcihjb3VudD1pMDtjb3VudDxtYXhpdDsrK2NvdW50KSB7XG4gICAgICAgIHZhciBpLGosZDtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIEEwW2ldID0gZGl2KEFbaV0seltpXSk7XG4gICAgICAgIHZhciBBMSA9IHRyYW5zcG9zZShBMCk7XG4gICAgICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSBwW2ldID0gKC8qeFtpXSsqL3N1bShBMVtpXSkpO1xuICAgICAgICBhbHBoYSA9IDAuMjUqYWJzKGRvdGNjL2RvdChjLHApKTtcbiAgICAgICAgdmFyIGExID0gMTAwKnNxcnQoZG90Y2MvZG90KHAscCkpO1xuICAgICAgICBpZighaXNGaW5pdGUoYWxwaGEpIHx8IGFscGhhPmExKSBhbHBoYSA9IGExO1xuICAgICAgICBnID0gYWRkKGMsbXVsKGFscGhhLHApKTtcbiAgICAgICAgSCA9IGRvdChBMSxBMCk7XG4gICAgICAgIGZvcihpPW0tMTtpIT09LTE7LS1pKSBIW2ldW2ldICs9IDE7XG4gICAgICAgIGQgPSBzb2x2ZShILGRpdihnLGFscGhhKSx0cnVlKTtcbiAgICAgICAgdmFyIHQwID0gZGl2KHosZG90KEEsZCkpO1xuICAgICAgICB2YXIgdCA9IDEuMDtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIGlmKHQwW2ldPDApIHQgPSBtaW4odCwtMC45OTkqdDBbaV0pO1xuICAgICAgICB5ID0gc3ViKHgsbXVsKGQsdCkpO1xuICAgICAgICB6ID0gc3ViKGIsZG90KEEseSkpO1xuICAgICAgICBpZighYWxsKGd0KHosMCkpKSByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTogXCJcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICAgICAgeCA9IHk7XG4gICAgICAgIGlmKGFscGhhPHRvbCkgcmV0dXJuIHsgc29sdXRpb246IHksIG1lc3NhZ2U6IFwiXCIsIGl0ZXJhdGlvbnM6IGNvdW50IH07XG4gICAgICAgIGlmKGZsYWcpIHtcbiAgICAgICAgICAgIHZhciBzID0gZG90KGMsZyksIEFnID0gZG90KEEsZyk7XG4gICAgICAgICAgICB1bmJvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIGlmKHMqQWdbaV08MCkgeyB1bmJvdW5kZWQgPSBmYWxzZTsgYnJlYWs7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHhbbS0xXT49MCkgdW5ib3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIHVuYm91bmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYodW5ib3VuZGVkKSByZXR1cm4geyBzb2x1dGlvbjogeSwgbWVzc2FnZTogXCJVbmJvdW5kZWRcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc29sdXRpb246IHgsIG1lc3NhZ2U6IFwibWF4aW11bSBpdGVyYXRpb24gY291bnQgZXhjZWVkZWRcIiwgaXRlcmF0aW9uczpjb3VudCB9O1xufVxuXG5udW1lcmljLl9zb2x2ZUxQID0gZnVuY3Rpb24gX3NvbHZlTFAoYyxBLGIsdG9sLG1heGl0KSB7XG4gICAgdmFyIG0gPSBjLmxlbmd0aCwgbiA9IGIubGVuZ3RoLHk7XG4gICAgdmFyIHN1bSA9IG51bWVyaWMuc3VtLCBsb2cgPSBudW1lcmljLmxvZywgbXVsID0gbnVtZXJpYy5tdWwsIHN1YiA9IG51bWVyaWMuc3ViLCBkb3QgPSBudW1lcmljLmRvdCwgZGl2ID0gbnVtZXJpYy5kaXYsIGFkZCA9IG51bWVyaWMuYWRkO1xuICAgIHZhciBjMCA9IG51bWVyaWMucmVwKFttXSwwKS5jb25jYXQoWzFdKTtcbiAgICB2YXIgSiA9IG51bWVyaWMucmVwKFtuLDFdLC0xKTtcbiAgICB2YXIgQTAgPSBudW1lcmljLmJsb2NrTWF0cml4KFtbQSAgICAgICAgICAgICAgICAgICAsICAgSiAgXV0pO1xuICAgIHZhciBiMCA9IGI7XG4gICAgdmFyIHkgPSBudW1lcmljLnJlcChbbV0sMCkuY29uY2F0KE1hdGgubWF4KDAsbnVtZXJpYy5zdXAobnVtZXJpYy5uZWcoYikpKSsxKTtcbiAgICB2YXIgeDAgPSBudW1lcmljLl9fc29sdmVMUChjMCxBMCxiMCx0b2wsbWF4aXQseSxmYWxzZSk7XG4gICAgdmFyIHggPSBudW1lcmljLmNsb25lKHgwLnNvbHV0aW9uKTtcbiAgICB4Lmxlbmd0aCA9IG07XG4gICAgdmFyIGZvbyA9IG51bWVyaWMuaW5mKHN1YihiLGRvdChBLHgpKSk7XG4gICAgaWYoZm9vPDApIHsgcmV0dXJuIHsgc29sdXRpb246IE5hTiwgbWVzc2FnZTogXCJJbmZlYXNpYmxlXCIsIGl0ZXJhdGlvbnM6IHgwLml0ZXJhdGlvbnMgfTsgfVxuICAgIHZhciByZXQgPSBudW1lcmljLl9fc29sdmVMUChjLCBBLCBiLCB0b2wsIG1heGl0LXgwLml0ZXJhdGlvbnMsIHgsIHRydWUpO1xuICAgIHJldC5pdGVyYXRpb25zICs9IHgwLml0ZXJhdGlvbnM7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm51bWVyaWMuc29sdmVMUCA9IGZ1bmN0aW9uIHNvbHZlTFAoYyxBLGIsQWVxLGJlcSx0b2wsbWF4aXQpIHtcbiAgICBpZih0eXBlb2YgbWF4aXQgPT09IFwidW5kZWZpbmVkXCIpIG1heGl0ID0gMTAwMDtcbiAgICBpZih0eXBlb2YgdG9sID09PSBcInVuZGVmaW5lZFwiKSB0b2wgPSBudW1lcmljLmVwc2lsb247XG4gICAgaWYodHlwZW9mIEFlcSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bWVyaWMuX3NvbHZlTFAoYyxBLGIsdG9sLG1heGl0KTtcbiAgICB2YXIgbSA9IEFlcS5sZW5ndGgsIG4gPSBBZXFbMF0ubGVuZ3RoLCBvID0gQS5sZW5ndGg7XG4gICAgdmFyIEIgPSBudW1lcmljLmVjaGVsb25pemUoQWVxKTtcbiAgICB2YXIgZmxhZ3MgPSBudW1lcmljLnJlcChbbl0sMCk7XG4gICAgdmFyIFAgPSBCLlA7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgaTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIGZsYWdzW1BbaV1dID0gMTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYoZmxhZ3NbaV09PT0wKSBRLnB1c2goaSk7XG4gICAgdmFyIGcgPSBudW1lcmljLmdldFJhbmdlO1xuICAgIHZhciBJID0gbnVtZXJpYy5saW5zcGFjZSgwLG0tMSksIEogPSBudW1lcmljLmxpbnNwYWNlKDAsby0xKTtcbiAgICB2YXIgQWVxMiA9IGcoQWVxLEksUSksIEExID0gZyhBLEosUCksIEEyID0gZyhBLEosUSksIGRvdCA9IG51bWVyaWMuZG90LCBzdWIgPSBudW1lcmljLnN1YjtcbiAgICB2YXIgQTMgPSBkb3QoQTEsQi5JKTtcbiAgICB2YXIgQTQgPSBzdWIoQTIsZG90KEEzLEFlcTIpKSwgYjQgPSBzdWIoYixkb3QoQTMsYmVxKSk7XG4gICAgdmFyIGMxID0gQXJyYXkoUC5sZW5ndGgpLCBjMiA9IEFycmF5KFEubGVuZ3RoKTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIGMxW2ldID0gY1tQW2ldXTtcbiAgICBmb3IoaT1RLmxlbmd0aC0xO2khPT0tMTstLWkpIGMyW2ldID0gY1tRW2ldXTtcbiAgICB2YXIgYzQgPSBzdWIoYzIsZG90KGMxLGRvdChCLkksQWVxMikpKTtcbiAgICB2YXIgUyA9IG51bWVyaWMuX3NvbHZlTFAoYzQsQTQsYjQsdG9sLG1heGl0KTtcbiAgICB2YXIgeDIgPSBTLnNvbHV0aW9uO1xuICAgIGlmKHgyIT09eDIpIHJldHVybiBTO1xuICAgIHZhciB4MSA9IGRvdChCLkksc3ViKGJlcSxkb3QoQWVxMix4MikpKTtcbiAgICB2YXIgeCA9IEFycmF5KGMubGVuZ3RoKTtcbiAgICBmb3IoaT1QLmxlbmd0aC0xO2khPT0tMTstLWkpIHhbUFtpXV0gPSB4MVtpXTtcbiAgICBmb3IoaT1RLmxlbmd0aC0xO2khPT0tMTstLWkpIHhbUVtpXV0gPSB4MltpXTtcbiAgICByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTpTLm1lc3NhZ2UsIGl0ZXJhdGlvbnM6IFMuaXRlcmF0aW9ucyB9O1xufVxuXG5udW1lcmljLk1QU3RvTFAgPSBmdW5jdGlvbiBNUFN0b0xQKE1QUykge1xuICAgIGlmKE1QUyBpbnN0YW5jZW9mIFN0cmluZykgeyBNUFMuc3BsaXQoJ1xcbicpOyB9XG4gICAgdmFyIHN0YXRlID0gMDtcbiAgICB2YXIgc3RhdGVzID0gWydJbml0aWFsIHN0YXRlJywnTkFNRScsJ1JPV1MnLCdDT0xVTU5TJywnUkhTJywnQk9VTkRTJywnRU5EQVRBJ107XG4gICAgdmFyIG4gPSBNUFMubGVuZ3RoO1xuICAgIHZhciBpLGoseixOPTAscm93cyA9IHt9LCBzaWduID0gW10sIHJsID0gMCwgdmFycyA9IHt9LCBudiA9IDA7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGMgPSBbXSwgQSA9IFtdLCBiID0gW107XG4gICAgZnVuY3Rpb24gZXJyKGUpIHsgdGhyb3cgbmV3IEVycm9yKCdNUFN0b0xQOiAnK2UrJ1xcbkxpbmUgJytpKyc6ICcrTVBTW2ldKydcXG5DdXJyZW50IHN0YXRlOiAnK3N0YXRlc1tzdGF0ZV0rJ1xcbicpOyB9XG4gICAgZm9yKGk9MDtpPG47KytpKSB7XG4gICAgICAgIHogPSBNUFNbaV07XG4gICAgICAgIHZhciB3MCA9IHoubWF0Y2goL1xcUyovZyk7XG4gICAgICAgIHZhciB3ID0gW107XG4gICAgICAgIGZvcihqPTA7ajx3MC5sZW5ndGg7KytqKSBpZih3MFtqXSE9PVwiXCIpIHcucHVzaCh3MFtqXSk7XG4gICAgICAgIGlmKHcubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgZm9yKGo9MDtqPHN0YXRlcy5sZW5ndGg7KytqKSBpZih6LnN1YnN0cigwLHN0YXRlc1tqXS5sZW5ndGgpID09PSBzdGF0ZXNbal0pIGJyZWFrO1xuICAgICAgICBpZihqPHN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlID0gajtcbiAgICAgICAgICAgIGlmKGo9PT0xKSB7IG5hbWUgPSB3WzFdOyB9XG4gICAgICAgICAgICBpZihqPT09NikgcmV0dXJuIHsgbmFtZTpuYW1lLCBjOmMsIEE6bnVtZXJpYy50cmFuc3Bvc2UoQSksIGI6Yiwgcm93czpyb3dzLCB2YXJzOnZhcnMgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChzdGF0ZSkge1xuICAgICAgICBjYXNlIDA6IGNhc2UgMTogZXJyKCdVbmV4cGVjdGVkIGxpbmUnKTtcbiAgICAgICAgY2FzZSAyOiBcbiAgICAgICAgICAgIHN3aXRjaCh3WzBdKSB7XG4gICAgICAgICAgICBjYXNlICdOJzogaWYoTj09PTApIE4gPSB3WzFdOyBlbHNlIGVycignVHdvIG9yIG1vcmUgTiByb3dzJyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAxOyBiW3JsXSA9IDA7ICsrcmw7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRyc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAtMTtiW3JsXSA9IDA7ICsrcmw7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRSc6IHJvd3Nbd1sxXV0gPSBybDsgc2lnbltybF0gPSAwO2JbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBlcnIoJ1BhcnNlIGVycm9yICcrbnVtZXJpYy5wcmV0dHlQcmludCh3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYoIXZhcnMuaGFzT3duUHJvcGVydHkod1swXSkpIHsgdmFyc1t3WzBdXSA9IG52OyBjW252XSA9IDA7IEFbbnZdID0gbnVtZXJpYy5yZXAoW3JsXSwwKTsgKytudjsgfVxuICAgICAgICAgICAgdmFyIHAgPSB2YXJzW3dbMF1dO1xuICAgICAgICAgICAgZm9yKGo9MTtqPHcubGVuZ3RoO2orPTIpIHtcbiAgICAgICAgICAgICAgICBpZih3W2pdID09PSBOKSB7IGNbcF0gPSBwYXJzZUZsb2F0KHdbaisxXSk7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHEgPSByb3dzW3dbal1dO1xuICAgICAgICAgICAgICAgIEFbcF1bcV0gPSAoc2lnbltxXTwwPy0xOjEpKnBhcnNlRmxvYXQod1tqKzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBmb3Ioaj0xO2o8dy5sZW5ndGg7ais9MikgYltyb3dzW3dbal1dXSA9IChzaWduW3Jvd3Nbd1tqXV1dPDA/LTE6MSkqcGFyc2VGbG9hdCh3W2orMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogLypGSVhNRSovIGJyZWFrO1xuICAgICAgICBjYXNlIDY6IGVycignSW50ZXJuYWwgZXJyb3InKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnIoJ1JlYWNoZWQgZW5kIG9mIGZpbGUgd2l0aG91dCBFTkRBVEEnKTtcbn1cbi8vIHNlZWRyYW5kb20uanMgdmVyc2lvbiAyLjAuXG4vLyBBdXRob3I6IERhdmlkIEJhdSA0LzIvMjAxMVxuLy9cbi8vIERlZmluZXMgYSBtZXRob2QgTWF0aC5zZWVkcmFuZG9tKCkgdGhhdCwgd2hlbiBjYWxsZWQsIHN1YnN0aXR1dGVzXG4vLyBhbiBleHBsaWNpdGx5IHNlZWRlZCBSQzQtYmFzZWQgYWxnb3JpdGhtIGZvciBNYXRoLnJhbmRvbSgpLiAgQWxzb1xuLy8gc3VwcG9ydHMgYXV0b21hdGljIHNlZWRpbmcgZnJvbSBsb2NhbCBvciBuZXR3b3JrIHNvdXJjZXMgb2YgZW50cm9weS5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyAgIDxzY3JpcHQgc3JjPWh0dHA6Ly9kYXZpZGJhdS5jb20vZW5jb2RlL3NlZWRyYW5kb20tbWluLmpzPjwvc2NyaXB0PlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCd5aXBlZScpOyBTZXRzIE1hdGgucmFuZG9tIHRvIGEgZnVuY3Rpb24gdGhhdCBpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkIHVzaW5nIHRoZSBnaXZlbiBleHBsaWNpdCBzZWVkLlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCk7ICAgICAgICBTZXRzIE1hdGgucmFuZG9tIHRvIGEgZnVuY3Rpb24gdGhhdCBpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRlZCB1c2luZyB0aGUgY3VycmVudCB0aW1lLCBkb20gc3RhdGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIG90aGVyIGFjY3VtdWxhdGVkIGxvY2FsIGVudHJvcHkuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzZWVkIHN0cmluZyBpcyByZXR1cm5lZC5cbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbSgneW93emEnLCB0cnVlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWVkcyB1c2luZyB0aGUgZ2l2ZW4gZXhwbGljaXQgc2VlZCBtaXhlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2V0aGVyIHdpdGggYWNjdW11bGF0ZWQgZW50cm9weS5cbi8vXG4vLyAgIDxzY3JpcHQgc3JjPVwiaHR0cDovL2JpdC5seS9zcmFuZG9tLTUxMlwiPjwvc2NyaXB0PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHBoeXNpY2FsIHJhbmRvbSBiaXRzIGRvd25sb2FkZWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJhbmRvbS5vcmcuXG4vL1xuLy8gICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vanNvbmxpYi5hcHBzcG90LmNvbS91cmFuZG9tP2NhbGxiYWNrPU1hdGguc2VlZHJhbmRvbVwiPlxuLy8gICA8L3NjcmlwdD4gICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHVyYW5kb20gYml0cyBmcm9tIGNhbGwuanNvbmxpYi5jb20sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggaXMgZmFzdGVyIHRoYW4gcmFuZG9tLm9yZy5cbi8vXG4vLyBFeGFtcGxlczpcbi8vXG4vLyAgIE1hdGguc2VlZHJhbmRvbShcImhlbGxvXCIpOyAgICAgICAgICAgIC8vIFVzZSBcImhlbGxvXCIgYXMgdGhlIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBBbHdheXMgMC41NDYzNjYzNzY4MTQwNzM0XG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBBbHdheXMgMC40Mzk3Mzc5Mzc3MDU5MjIzNFxuLy8gICB2YXIgcm5nMSA9IE1hdGgucmFuZG9tOyAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgcHJuZy5cbi8vXG4vLyAgIHZhciBhdXRvc2VlZCA9IE1hdGguc2VlZHJhbmRvbSgpOyAgICAvLyBOZXcgcHJuZyB3aXRoIGFuIGF1dG9tYXRpYyBzZWVkLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gUHJldHR5IG11Y2ggdW5wcmVkaWN0YWJsZS5cbi8vXG4vLyAgIE1hdGgucmFuZG9tID0gcm5nMTsgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBcImhlbGxvXCIgcHJuZyBzZXF1ZW5jZS5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjU1NDc2OTQzMjQ3MzQ1NVxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKGF1dG9zZWVkKTsgICAgICAgICAgIC8vIFJlc3RhcnQgYXQgdGhlIHByZXZpb3VzIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBSZXBlYXQgdGhlICd1bnByZWRpY3RhYmxlJyB2YWx1ZS5cbi8vXG4vLyBOb3Rlczpcbi8vXG4vLyBFYWNoIHRpbWUgc2VlZHJhbmRvbSgnYXJnJykgaXMgY2FsbGVkLCBlbnRyb3B5IGZyb20gdGhlIHBhc3NlZCBzZWVkXG4vLyBpcyBhY2N1bXVsYXRlZCBpbiBhIHBvb2wgdG8gaGVscCBnZW5lcmF0ZSBmdXR1cmUgc2VlZHMgZm9yIHRoZVxuLy8gemVyby1hcmd1bWVudCBmb3JtIG9mIE1hdGguc2VlZHJhbmRvbSwgc28gZW50cm9weSBjYW4gYmUgaW5qZWN0ZWQgb3ZlclxuLy8gdGltZSBieSBjYWxsaW5nIHNlZWRyYW5kb20gd2l0aCBleHBsaWNpdCBkYXRhIHJlcGVhdGVkbHkuXG4vL1xuLy8gT24gc3BlZWQgLSBUaGlzIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgTWF0aC5yYW5kb20oKSBpcyBhYm91dFxuLy8gMy0xMHggc2xvd2VyIHRoYW4gdGhlIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkgYmVjYXVzZSBpdCBpcyBub3QgbmF0aXZlXG4vLyBjb2RlLCBidXQgdGhpcyBpcyB0eXBpY2FsbHkgZmFzdCBlbm91Z2ggYW55d2F5LiAgU2VlZGluZyBpcyBtb3JlIGV4cGVuc2l2ZSxcbi8vIGVzcGVjaWFsbHkgaWYgeW91IHVzZSBhdXRvLXNlZWRpbmcuICBTb21lIGRldGFpbHMgKHRpbWluZ3Mgb24gQ2hyb21lIDQpOlxuLy9cbi8vIE91ciBNYXRoLnJhbmRvbSgpICAgICAgICAgICAgLSBhdmcgbGVzcyB0aGFuIDAuMDAyIG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgnZXhwbGljaXQnKSAgICAgICAtIGF2ZyBsZXNzIHRoYW4gMC41IG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgnZXhwbGljaXQnLCB0cnVlKSAtIGF2ZyBsZXNzIHRoYW4gMiBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vIHNlZWRyYW5kb20oKSAgICAgICAgICAgICAgICAgLSBhdmcgYWJvdXQgMzggbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vL1xuLy8gTElDRU5TRSAoQlNEKTpcbi8vXG4vLyBDb3B5cmlnaHQgMjAxMCBEYXZpZCBCYXUsIGFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vIFxuLy8gICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vL1xuLy8gICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyBcbi8vICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGlzIG1vZHVsZSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4vLyAgICAgIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4vLyAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vL1xuLyoqXG4gKiBBbGwgY29kZSBpcyBpbiBhbiBhbm9ueW1vdXMgY2xvc3VyZSB0byBrZWVwIHRoZSBnbG9iYWwgbmFtZXNwYWNlIGNsZWFuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3ZlcmZsb3cgXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ZGVub21cbiAqL1xuXG4vLyBQYXRjaGVkIGJ5IFNlYiBzbyB0aGF0IHNlZWRyYW5kb20uanMgZG9lcyBub3QgcG9sbHV0ZSB0aGUgTWF0aCBvYmplY3QuXG4vLyBNeSB0ZXN0cyBzdWdnZXN0IHRoYXQgZG9pbmcgTWF0aC50cm91YmxlID0gMSBtYWtlcyBNYXRoIGxvb2t1cHMgYWJvdXQgNSVcbi8vIHNsb3dlci5cbm51bWVyaWMuc2VlZHJhbmRvbSA9IHsgcG93Ok1hdGgucG93LCByYW5kb206TWF0aC5yYW5kb20gfTtcblxuKGZ1bmN0aW9uIChwb29sLCBtYXRoLCB3aWR0aCwgY2h1bmtzLCBzaWduaWZpY2FuY2UsIG92ZXJmbG93LCBzdGFydGRlbm9tKSB7XG5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xubWF0aFsnc2VlZHJhbmRvbSddID0gZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCB1c2VfZW50cm9weSkge1xuICB2YXIga2V5ID0gW107XG4gIHZhciBhcmM0O1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICBzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgdXNlX2VudHJvcHkgPyBbc2VlZCwgcG9vbF0gOlxuICAgIGFyZ3VtZW50cy5sZW5ndGggPyBzZWVkIDpcbiAgICBbbmV3IERhdGUoKS5nZXRUaW1lKCksIHBvb2wsIHdpbmRvd10sIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkoYXJjNC5TLCBwb29sKTtcblxuICAvLyBPdmVycmlkZSBNYXRoLnJhbmRvbVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cblxuICBtYXRoWydyYW5kb20nXSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHsgIC8vIENsb3N1cmUgdG8gcmV0dXJuIGEgcmFuZG9tIGRvdWJsZTpcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpOyAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICB2YXIgZCA9IHN0YXJ0ZGVub207ICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgIHZhciB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2VlZCB0aGF0IHdhcyB1c2VkXG4gIHJldHVybiBzZWVkO1xufTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbi8qKiBAY29uc3RydWN0b3IgKi9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCB1LCBtZSA9IHRoaXMsIGtleWxlbiA9IGtleS5sZW5ndGg7XG4gIHZhciBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gbWUubSA9IDA7XG4gIG1lLlMgPSBbXTtcbiAgbWUuYyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7IG1lLlNbaV0gPSBpKys7IH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICB0ID0gbWUuU1tpXTtcbiAgICBqID0gbG93Yml0cyhqICsgdCArIGtleVtpICUga2V5bGVuXSk7XG4gICAgdSA9IG1lLlNbal07XG4gICAgbWUuU1tpXSA9IHU7XG4gICAgbWUuU1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIG1lLmcgPSBmdW5jdGlvbiBnZXRuZXh0KGNvdW50KSB7XG4gICAgdmFyIHMgPSBtZS5TO1xuICAgIHZhciBpID0gbG93Yml0cyhtZS5pICsgMSk7IHZhciB0ID0gc1tpXTtcbiAgICB2YXIgaiA9IGxvd2JpdHMobWUuaiArIHQpOyB2YXIgdSA9IHNbal07XG4gICAgc1tpXSA9IHU7XG4gICAgc1tqXSA9IHQ7XG4gICAgdmFyIHIgPSBzW2xvd2JpdHModCArIHUpXTtcbiAgICB3aGlsZSAoLS1jb3VudCkge1xuICAgICAgaSA9IGxvd2JpdHMoaSArIDEpOyB0ID0gc1tpXTtcbiAgICAgIGogPSBsb3diaXRzKGogKyB0KTsgdSA9IHNbal07XG4gICAgICBzW2ldID0gdTtcbiAgICAgIHNbal0gPSB0O1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbG93Yml0cyh0ICsgdSldO1xuICAgIH1cbiAgICBtZS5pID0gaTtcbiAgICBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgfTtcbiAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5IGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuXG4gIC8vIFNlZSBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMDA5XG4gIG1lLmcod2lkdGgpO1xufVxuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuLyoqIEBwYXJhbSB7T2JqZWN0PX0gcmVzdWx0IFxuICAqIEBwYXJhbSB7c3RyaW5nPX0gcHJvcFxuICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwICovXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgsIHJlc3VsdCwgcHJvcCwgdHlwKSB7XG4gIHJlc3VsdCA9IFtdO1xuICB0eXAgPSB0eXBlb2Yob2JqKTtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChwcm9wLmluZGV4T2YoJ1MnKSA8IDUpIHsgICAgLy8gQXZvaWQgRkYzIGJ1ZyAobG9jYWwvc2Vzc2lvblN0b3JhZ2UpXG4gICAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogb2JqICsgKHR5cCAhPSAnc3RyaW5nJyA/ICdcXDAnIDogJycpKTtcbn1cblxuLy9cbi8vIG1peGtleSgpXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbi8vXG4vKiogQHBhcmFtIHtudW1iZXI9fSBzbWVhciBcbiAgKiBAcGFyYW0ge251bWJlcj19IGogKi9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXksIHNtZWFyLCBqKSB7XG4gIHNlZWQgKz0gJyc7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2VlZCBpcyBhIHN0cmluZ1xuICBzbWVhciA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgaisrKSB7XG4gICAga2V5W2xvd2JpdHMoaildID1cbiAgICAgIGxvd2JpdHMoKHNtZWFyIF49IGtleVtsb3diaXRzKGopXSAqIDE5KSArIHNlZWQuY2hhckNvZGVBdChqKSk7XG4gIH1cbiAgc2VlZCA9ICcnO1xuICBmb3IgKGogaW4ga2V5KSB7IHNlZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlbal0pOyB9XG4gIHJldHVybiBzZWVkO1xufVxuXG4vL1xuLy8gbG93Yml0cygpXG4vLyBBIHF1aWNrIFwibiBtb2Qgd2lkdGhcIiBmb3Igd2lkdGggYSBwb3dlciBvZiAyLlxuLy9cbmZ1bmN0aW9uIGxvd2JpdHMobikgeyByZXR1cm4gbiAmICh3aWR0aCAtIDEpOyB9XG5cbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpO1xuc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgc2lnbmlmaWNhbmNlKTtcbm92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMjtcblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZWZlcmUgd2l0aCBkZXRlcm1pbnN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufShcbiAgW10sICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxuICBudW1lcmljLnNlZWRyYW5kb20sIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cbiAgMjU2LCAgLy8gd2lkdGg6IGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgNiwgICAgLy8gY2h1bmtzOiBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gIDUyICAgIC8vIHNpZ25pZmljYW5jZTogdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICApKTtcbi8qIFRoaXMgZmlsZSBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgcXVhZHByb2cuanMgZnJvbSBBbGJlcnRvIFNhbnRpbmkuXG4gKiBJdCBoYXMgYmVlbiBzbGlnaHRseSBtb2RpZmllZCBieSBTw6liYXN0aWVuIExvaXNlbCB0byBtYWtlIHN1cmUgdGhhdCBpdCBoYW5kbGVzXG4gKiAwLWJhc2VkIEFycmF5cyBpbnN0ZWFkIG9mIDEtYmFzZWQgQXJyYXlzLlxuICogTGljZW5zZSBpcyBpbiByZXNvdXJjZXMvTElDRU5TRS5xdWFkcHJvZyAqL1xuKGZ1bmN0aW9uKGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gYmFzZTB0bzEoQSkge1xuICAgIGlmKHR5cGVvZiBBICE9PSBcIm9iamVjdFwiKSB7IHJldHVybiBBOyB9XG4gICAgdmFyIHJldCA9IFtdLCBpLG49QS5sZW5ndGg7XG4gICAgZm9yKGk9MDtpPG47aSsrKSByZXRbaSsxXSA9IGJhc2UwdG8xKEFbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBiYXNlMXRvMChBKSB7XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIEE7IH1cbiAgICB2YXIgcmV0ID0gW10sIGksbj1BLmxlbmd0aDtcbiAgICBmb3IoaT0xO2k8bjtpKyspIHJldFtpLTFdID0gYmFzZTF0bzAoQVtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZHBvcmkoYSwgbGRhLCBuKSB7XG4gICAgdmFyIGksIGosIGssIGtwMSwgdDtcblxuICAgIGZvciAoayA9IDE7IGsgPD0gbjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGFba11ba10gPSAxIC8gYVtrXVtrXTtcbiAgICAgICAgdCA9IC1hW2tdW2tdO1xuICAgICAgICAvL34gZHNjYWwoayAtIDEsIHQsIGFbMV1ba10sIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBhW2ldW2tdID0gdCAqIGFbaV1ba107XG4gICAgICAgIH1cblxuICAgICAgICBrcDEgPSBrICsgMTtcbiAgICAgICAgaWYgKG4gPCBrcDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IGtwMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHQgPSBhW2tdW2pdO1xuICAgICAgICAgICAgYVtrXVtqXSA9IDA7XG4gICAgICAgICAgICAvL34gZGF4cHkoaywgdCwgYVsxXVtrXSwgMSwgYVsxXVtqXSwgMSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGFbaV1bal0gPSBhW2ldW2pdICsgKHQgKiBhW2ldW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBkcG9zbChhLCBsZGEsIG4sIGIpIHtcbiAgICB2YXIgaSwgaywga2IsIHQ7XG5cbiAgICBmb3IgKGsgPSAxOyBrIDw9IG47IGsgPSBrICsgMSkge1xuICAgICAgICAvL34gdCA9IGRkb3QoayAtIDEsIGFbMV1ba10sIDEsIGJbMV0sIDEpO1xuICAgICAgICB0ID0gMDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgdCA9IHQgKyAoYVtpXVtrXSAqIGJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYltrXSA9IChiW2tdIC0gdCkgLyBhW2tdW2tdO1xuICAgIH1cblxuICAgIGZvciAoa2IgPSAxOyBrYiA8PSBuOyBrYiA9IGtiICsgMSkge1xuICAgICAgICBrID0gbiArIDEgLSBrYjtcbiAgICAgICAgYltrXSA9IGJba10gLyBhW2tdW2tdO1xuICAgICAgICB0ID0gLWJba107XG4gICAgICAgIC8vfiBkYXhweShrIC0gMSwgdCwgYVsxXVtrXSwgMSwgYlsxXSwgMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGJbaV0gPSBiW2ldICsgKHQgKiBhW2ldW2tdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZHBvZmEoYSwgbGRhLCBuLCBpbmZvKSB7XG4gICAgdmFyIGksIGosIGptMSwgaywgdCwgcztcblxuICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIGluZm9bMV0gPSBqO1xuICAgICAgICBzID0gMDtcbiAgICAgICAgam0xID0gaiAtIDE7XG4gICAgICAgIGlmIChqbTEgPCAxKSB7XG4gICAgICAgICAgICBzID0gYVtqXVtqXSAtIHM7XG4gICAgICAgICAgICBpZiAocyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2pdW2pdID0gTWF0aC5zcXJ0KHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMTsgayA8PSBqbTE7IGsgPSBrICsgMSkge1xuICAgICAgICAgICAgICAgIC8vfiB0ID0gYVtrXVtqXSAtIGRkb3QoayAtIDEsIGFbMV1ba10sIDEsIGFbMV1bal0sIDEpO1xuICAgICAgICAgICAgICAgIHQgPSBhW2tdW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQgLSAoYVtpXVtqXSAqIGFbaV1ba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gdCAvIGFba11ba107XG4gICAgICAgICAgICAgICAgYVtrXVtqXSA9IHQ7XG4gICAgICAgICAgICAgICAgcyA9IHMgKyB0ICogdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBhW2pdW2pdIC0gcztcbiAgICAgICAgICAgIGlmIChzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbal1bal0gPSBNYXRoLnNxcnQocyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1sxXSA9IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBxcGdlbjIoZG1hdCwgZHZlYywgZmRkbWF0LCBuLCBzb2wsIGNydmFsLCBhbWF0LFxuICAgIGJ2ZWMsIGZkYW1hdCwgcSwgbWVxLCBpYWN0LCBuYWN0LCBpdGVyLCB3b3JrLCBpZXJyKSB7XG5cbiAgICB2YXIgaSwgaiwgbCwgbDEsIGluZm8sIGl0MSwgaXd6diwgaXdydiwgaXdybSwgaXdzdiwgaXd1diwgbnZsLCByLCBpd25idixcbiAgICAgICAgdGVtcCwgc3VtLCB0MSwgdHQsIGdjLCBncywgbnUsXG4gICAgICAgIHQxaW5mLCB0Mm1pbixcbiAgICAgICAgdnNtYWxsLCB0bXBhLCB0bXBiLFxuICAgICAgICBnbztcblxuICAgIHIgPSBNYXRoLm1pbihuLCBxKTtcbiAgICBsID0gMiAqIG4gKyAociAqIChyICsgNSkpIC8gMiArIDIgKiBxICsgMTtcblxuICAgIHZzbWFsbCA9IDEuMGUtNjA7XG4gICAgZG8ge1xuICAgICAgICB2c21hbGwgPSB2c21hbGwgKyB2c21hbGw7XG4gICAgICAgIHRtcGEgPSAxICsgMC4xICogdnNtYWxsO1xuICAgICAgICB0bXBiID0gMSArIDAuMiAqIHZzbWFsbDtcbiAgICB9IHdoaWxlICh0bXBhIDw9IDEgfHwgdG1wYiA8PSAxKTtcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHdvcmtbaV0gPSBkdmVjW2ldO1xuICAgIH1cbiAgICBmb3IgKGkgPSBuICsgMTsgaSA8PSBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGlhY3RbaV0gPSAwO1xuICAgIH1cblxuICAgIGluZm8gPSBbXTtcblxuICAgIGlmIChpZXJyWzFdID09PSAwKSB7XG4gICAgICAgIGRwb2ZhKGRtYXQsIGZkZG1hdCwgbiwgaW5mbyk7XG4gICAgICAgIGlmIChpbmZvWzFdICE9PSAwKSB7XG4gICAgICAgICAgICBpZXJyWzFdID0gMjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcG9zbChkbWF0LCBmZGRtYXQsIG4sIGR2ZWMpO1xuICAgICAgICBkcG9yaShkbWF0LCBmZGRtYXQsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBzb2xbal0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBqOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBzb2xbal0gPSBzb2xbal0gKyBkbWF0W2ldW2pdICogZHZlY1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgZHZlY1tqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSBqOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGR2ZWNbal0gPSBkdmVjW2pdICsgZG1hdFtqXVtpXSAqIHNvbFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNydmFsWzFdID0gMDtcbiAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICBzb2xbal0gPSBkdmVjW2pdO1xuICAgICAgICBjcnZhbFsxXSA9IGNydmFsWzFdICsgd29ya1tqXSAqIHNvbFtqXTtcbiAgICAgICAgd29ya1tqXSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGogKyAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgZG1hdFtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3J2YWxbMV0gPSAtY3J2YWxbMV0gLyAyO1xuICAgIGllcnJbMV0gPSAwO1xuXG4gICAgaXd6diA9IG47XG4gICAgaXdydiA9IGl3enYgKyBuO1xuICAgIGl3dXYgPSBpd3J2ICsgcjtcbiAgICBpd3JtID0gaXd1diArIHIgKyAxO1xuICAgIGl3c3YgPSBpd3JtICsgKHIgKiAociArIDEpKSAvIDI7XG4gICAgaXduYnYgPSBpd3N2ICsgcTtcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0gKyBhbWF0W2pdW2ldICogYW1hdFtqXVtpXTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrW2l3bmJ2ICsgaV0gPSBNYXRoLnNxcnQoc3VtKTtcbiAgICB9XG4gICAgbmFjdCA9IDA7XG4gICAgaXRlclsxXSA9IDA7XG4gICAgaXRlclsyXSA9IDA7XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzUwKCkge1xuICAgICAgICBpdGVyWzFdID0gaXRlclsxXSArIDE7XG5cbiAgICAgICAgbCA9IGl3c3Y7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICBzdW0gPSAtYnZlY1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgYW1hdFtqXVtpXSAqIHNvbFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdW0pIDwgdnNtYWxsKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gbWVxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tsXSA9IHN1bTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya1tsXSA9IC1NYXRoLmFicyhzdW0pO1xuICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWF0W2pdW2ldID0gLWFtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnZlY1tpXSA9IC1idmVjW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2l3c3YgKyBpYWN0W2ldXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBudmwgPSAwO1xuICAgICAgICB0ZW1wID0gMDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGlmICh3b3JrW2l3c3YgKyBpXSA8IHRlbXAgKiB3b3JrW2l3bmJ2ICsgaV0pIHtcbiAgICAgICAgICAgICAgICBudmwgPSBpO1xuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2l3c3YgKyBpXSAvIHdvcmtbaXduYnYgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnZsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gOTk5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b181NSgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIGRtYXRbal1baV0gKiBhbWF0W2pdW252bF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrW2ldID0gc3VtO1xuICAgICAgICB9XG5cbiAgICAgICAgbDEgPSBpd3p2O1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgd29ya1tsMSArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSBuYWN0ICsgMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tsMSArIGldID0gd29ya1tsMSArIGldICsgZG1hdFtpXVtqXSAqIHdvcmtbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0MWluZiA9IHRydWU7XG4gICAgICAgIGZvciAoaSA9IG5hY3Q7IGkgPj0gMTsgaSA9IGkgLSAxKSB7XG4gICAgICAgICAgICBzdW0gPSB3b3JrW2ldO1xuICAgICAgICAgICAgbCA9IGl3cm0gKyAoaSAqIChpICsgMykpIC8gMjtcbiAgICAgICAgICAgIGwxID0gbCAtIGk7XG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8PSBuYWN0OyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gLSB3b3JrW2xdICogd29ya1tpd3J2ICsgal07XG4gICAgICAgICAgICAgICAgbCA9IGwgKyBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtID0gc3VtIC8gd29ya1tsMV07XG4gICAgICAgICAgICB3b3JrW2l3cnYgKyBpXSA9IHN1bTtcbiAgICAgICAgICAgIGlmIChpYWN0W2ldIDwgbWVxKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VtIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDFpbmYgPSBmYWxzZTtcbiAgICAgICAgICAgIGl0MSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXQxaW5mKSB7XG4gICAgICAgICAgICB0MSA9IHdvcmtbaXd1diArIGl0MV0gLyB3b3JrW2l3cnYgKyBpdDFdO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWFjdFtpXSA8IG1lcSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3b3JrW2l3cnYgKyBpXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wID0gd29ya1tpd3V2ICsgaV0gLyB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA8IHQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgaXQxID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGkgPSBpd3p2ICsgMTsgaSA8PSBpd3p2ICsgbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0gKyB3b3JrW2ldICogd29ya1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA8PSB2c21hbGwpIHtcbiAgICAgICAgICAgIGlmICh0MWluZikge1xuICAgICAgICAgICAgICAgIGllcnJbMV0gPSAxO1xuICAgICAgICAgICAgICAgIC8vIEdPVE8gOTk5XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk5OTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgaV0gPSB3b3JrW2l3dXYgKyBpXSAtIHQxICogd29ya1tpd3J2ICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXSArIHQxO1xuICAgICAgICAgICAgICAgIC8vIEdPVE8gNzAwXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIHdvcmtbaXd6diArIGldICogYW1hdFtpXVtudmxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHQgPSAtd29ya1tpd3N2ICsgbnZsXSAvIHN1bTtcbiAgICAgICAgICAgIHQybWluID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdDFpbmYpIHtcbiAgICAgICAgICAgICAgICBpZiAodDEgPCB0dCkge1xuICAgICAgICAgICAgICAgICAgICB0dCA9IHQxO1xuICAgICAgICAgICAgICAgICAgICB0Mm1pbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBzb2xbaV0gPSBzb2xbaV0gKyB0dCAqIHdvcmtbaXd6diArIGldO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzb2xbaV0pIDwgdnNtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjcnZhbFsxXSA9IGNydmFsWzFdICsgdHQgKiBzdW0gKiAodHQgLyAyICsgd29ya1tpd3V2ICsgbmFjdCArIDFdKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgaV0gPSB3b3JrW2l3dXYgKyBpXSAtIHR0ICogd29ya1tpd3J2ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gKyB0dDtcblxuICAgICAgICAgICAgaWYgKHQybWluKSB7XG4gICAgICAgICAgICAgICAgbmFjdCA9IG5hY3QgKyAxO1xuICAgICAgICAgICAgICAgIGlhY3RbbmFjdF0gPSBudmw7XG5cbiAgICAgICAgICAgICAgICBsID0gaXdybSArICgobmFjdCAtIDEpICogbmFjdCkgLyAyICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3QgLSAxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tsXSA9IHdvcmtbaV07XG4gICAgICAgICAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmFjdCA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tuXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuOyBpID49IG5hY3QgKyAxOyBpID0gaSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrW2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYyA9IE1hdGgubWF4KE1hdGguYWJzKHdvcmtbaSAtIDFdKSwgTWF0aC5hYnMod29ya1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3MgPSBNYXRoLm1pbihNYXRoLmFicyh3b3JrW2kgLSAxXSksIE1hdGguYWJzKHdvcmtbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrW2kgLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSAtTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjID0gd29ya1tpIC0gMV0gLyB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3MgPSB3b3JrW2ldIC8gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdjID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrW2kgLSAxXSA9IGdzICogdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gZG1hdFtqXVtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baSAtIDFdID0gZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrW2kgLSAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnUgPSBncyAvICgxICsgZ2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIGRtYXRbal1baSAtIDFdICsgZ3MgKiBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2ldID0gbnUgKiAoZG1hdFtqXVtpIC0gMV0gKyB0ZW1wKSAtIGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baSAtIDFdID0gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tuYWN0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1bSA9IC1idmVjW252bF07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgc29sW2pdICogYW1hdFtqXVtudmxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnZsID4gbWVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbaXdzdiArIG52bF0gPSBzdW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3N2ICsgbnZsXSA9IC1NYXRoLmFicyhzdW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWF0W2pdW252bF0gPSAtYW1hdFtqXVtudmxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnZlY1tudmxdID0gLWJ2ZWNbbnZsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHT1RPIDcwMFxuICAgICAgICAgICAgICAgIHJldHVybiA3MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5NygpIHtcbiAgICAgICAgbCA9IGl3cm0gKyAoaXQxICogKGl0MSArIDEpKSAvIDIgKyAxO1xuICAgICAgICBsMSA9IGwgKyBpdDE7XG4gICAgICAgIGlmICh3b3JrW2wxXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gR09UTyA3OThcbiAgICAgICAgICAgIHJldHVybiA3OTg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MgPSBNYXRoLm1heChNYXRoLmFicyh3b3JrW2wxIC0gMV0pLCBNYXRoLmFicyh3b3JrW2wxXSkpO1xuICAgICAgICBncyA9IE1hdGgubWluKE1hdGguYWJzKHdvcmtbbDEgLSAxXSksIE1hdGguYWJzKHdvcmtbbDFdKSk7XG4gICAgICAgIGlmICh3b3JrW2wxIC0gMV0gPj0gMCkge1xuICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gLU1hdGguYWJzKGdjICogTWF0aC5zcXJ0KDEgKyBncyAqIGdzIC8gKGdjICogZ2MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MgPSB3b3JrW2wxIC0gMV0gLyB0ZW1wO1xuICAgICAgICBncyA9IHdvcmtbbDFdIC8gdGVtcDtcblxuICAgICAgICBpZiAoZ2MgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk4XG4gICAgICAgICAgICByZXR1cm4gNzk4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYyA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gaXQxICsgMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gd29ya1tsMSAtIDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgLSAxXSA9IHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBsMSA9IGwxICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGRtYXRbaV1baXQxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MV0gPSBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxICsgMV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnUgPSBncyAvICgxICsgZ2MpO1xuICAgICAgICAgICAgZm9yIChpID0gaXQxICsgMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZ2MgKiB3b3JrW2wxIC0gMV0gKyBncyAqIHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDFdID0gbnUgKiAod29ya1tsMSAtIDFdICsgdGVtcCkgLSB3b3JrW2wxXTtcbiAgICAgICAgICAgICAgICB3b3JrW2wxIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGwxID0gbDEgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZ2MgKiBkbWF0W2ldW2l0MV0gKyBncyAqIGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDEgKyAxXSA9IG51ICogKGRtYXRbaV1baXQxXSArIHRlbXApIC0gZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTgoKSB7XG4gICAgICAgIGwxID0gbCAtIGl0MTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBpdDE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgd29ya1tsMV0gPSB3b3JrW2xdO1xuICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgbDEgPSBsMSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrW2l3dXYgKyBpdDFdID0gd29ya1tpd3V2ICsgaXQxICsgMV07XG4gICAgICAgIGlhY3RbaXQxXSA9IGlhY3RbaXQxICsgMV07XG4gICAgICAgIGl0MSA9IGl0MSArIDE7XG4gICAgICAgIGlmIChpdDEgPCBuYWN0KSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5N1xuICAgICAgICAgICAgcmV0dXJuIDc5NztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk5KCkge1xuICAgICAgICB3b3JrW2l3dXYgKyBuYWN0XSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXTtcbiAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gMDtcbiAgICAgICAgaWFjdFtuYWN0XSA9IDA7XG4gICAgICAgIG5hY3QgPSBuYWN0IC0gMTtcbiAgICAgICAgaXRlclsyXSA9IGl0ZXJbMl0gKyAxO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGdvID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBnbyA9IGZuX2dvdG9fNTAoKTtcbiAgICAgICAgaWYgKGdvID09PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZ28gPSBmbl9nb3RvXzU1KCk7XG4gICAgICAgICAgICBpZiAoZ28gPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbyA9PT0gOTk5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvID09PSA3MDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQxID09PSBuYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbyA9IGZuX2dvdG9fNzk4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ28gIT09IDc5Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZuX2dvdG9fNzk5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIHNvbHZlUVAoRG1hdCwgZHZlYywgQW1hdCwgYnZlYywgbWVxLCBmYWN0b3JpemVkKSB7XG4gICAgRG1hdCA9IGJhc2UwdG8xKERtYXQpO1xuICAgIGR2ZWMgPSBiYXNlMHRvMShkdmVjKTtcbiAgICBBbWF0ID0gYmFzZTB0bzEoQW1hdCk7XG4gICAgdmFyIGksIG4sIHEsXG4gICAgICAgIG5hY3QsIHIsXG4gICAgICAgIGNydmFsID0gW10sIGlhY3QgPSBbXSwgc29sID0gW10sIHdvcmsgPSBbXSwgaXRlciA9IFtdLFxuICAgICAgICBtZXNzYWdlO1xuXG4gICAgbWVxID0gbWVxIHx8IDA7XG4gICAgZmFjdG9yaXplZCA9IGZhY3Rvcml6ZWQgPyBiYXNlMHRvMShmYWN0b3JpemVkKSA6IFt1bmRlZmluZWQsIDBdO1xuICAgIGJ2ZWMgPSBidmVjID8gYmFzZTB0bzEoYnZlYykgOiBbXTtcblxuICAgIC8vIEluIEZvcnRyYW4gdGhlIGFycmF5IGluZGV4IHN0YXJ0cyBmcm9tIDFcbiAgICBuID0gRG1hdC5sZW5ndGggLSAxO1xuICAgIHEgPSBBbWF0WzFdLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoIWJ2ZWMpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGJ2ZWNbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gcTsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGlhY3RbaV0gPSAwO1xuICAgIH1cbiAgICBuYWN0ID0gMDtcbiAgICByID0gTWF0aC5taW4obiwgcSk7XG4gICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgc29sW2ldID0gMDtcbiAgICB9XG4gICAgY3J2YWxbMV0gPSAwO1xuICAgIGZvciAoaSA9IDE7IGkgPD0gKDIgKiBuICsgKHIgKiAociArIDUpKSAvIDIgKyAyICogcSArIDEpOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gMjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGl0ZXJbaV0gPSAwO1xuICAgIH1cblxuICAgIHFwZ2VuMihEbWF0LCBkdmVjLCBuLCBuLCBzb2wsIGNydmFsLCBBbWF0LFxuICAgICAgICBidmVjLCBuLCBxLCBtZXEsIGlhY3QsIG5hY3QsIGl0ZXIsIHdvcmssIGZhY3Rvcml6ZWQpO1xuXG4gICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgaWYgKGZhY3Rvcml6ZWRbMV0gPT09IDEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiY29uc3RyYWludHMgYXJlIGluY29uc2lzdGVudCwgbm8gc29sdXRpb24hXCI7XG4gICAgfVxuICAgIGlmIChmYWN0b3JpemVkWzFdID09PSAyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIm1hdHJpeCBEIGluIHF1YWRyYXRpYyBmdW5jdGlvbiBpcyBub3QgcG9zaXRpdmUgZGVmaW5pdGUhXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc29sdXRpb246IGJhc2UxdG8wKHNvbCksXG4gICAgICAgIHZhbHVlOiBiYXNlMXRvMChjcnZhbCksXG4gICAgICAgIHVuY29uc3RyYWluZWRfc29sdXRpb246IGJhc2UxdG8wKGR2ZWMpLFxuICAgICAgICBpdGVyYXRpb25zOiBiYXNlMXRvMChpdGVyKSxcbiAgICAgICAgaWFjdDogYmFzZTF0bzAoaWFjdCksXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9O1xufVxuZXhwb3J0cy5zb2x2ZVFQID0gc29sdmVRUDtcbn0obnVtZXJpYykpO1xuLypcclxuU2hhbnRpIFJhbyBzZW50IG1lIHRoaXMgcm91dGluZSBieSBwcml2YXRlIGVtYWlsLiBJIGhhZCB0byBtb2RpZnkgaXRcclxuc2xpZ2h0bHkgdG8gd29yayBvbiBBcnJheXMgaW5zdGVhZCBvZiB1c2luZyBhIE1hdHJpeCBvYmplY3QuXHJcbkl0IGlzIGFwcGFyZW50bHkgdHJhbnNsYXRlZCBmcm9tIGh0dHA6Ly9zdGl0Y2hwYW5vcmFtYS5zb3VyY2Vmb3JnZS5uZXQvUHl0aG9uL3N2ZC5weVxyXG4qL1xyXG5cclxubnVtZXJpYy5zdmQ9IGZ1bmN0aW9uIHN2ZChBKSB7XHJcbiAgICB2YXIgdGVtcDtcclxuLy9Db21wdXRlIHRoZSB0aGluIFNWRCBmcm9tIEcuIEguIEdvbHViIGFuZCBDLiBSZWluc2NoLCBOdW1lci4gTWF0aC4gMTQsIDQwMy00MjAgKDE5NzApXHJcblx0dmFyIHByZWM9IG51bWVyaWMuZXBzaWxvbjsgLy9NYXRoLnBvdygyLC01MikgLy8gYXNzdW1lcyBkb3VibGUgcHJlY1xyXG5cdHZhciB0b2xlcmFuY2U9IDEuZS02NC9wcmVjO1xyXG5cdHZhciBpdG1heD0gNTA7XHJcblx0dmFyIGM9MDtcclxuXHR2YXIgaT0wO1xyXG5cdHZhciBqPTA7XHJcblx0dmFyIGs9MDtcclxuXHR2YXIgbD0wO1xyXG5cdFxyXG5cdHZhciB1PSBudW1lcmljLmNsb25lKEEpO1xyXG5cdHZhciBtPSB1Lmxlbmd0aDtcclxuXHRcclxuXHR2YXIgbj0gdVswXS5sZW5ndGg7XHJcblx0XHJcblx0aWYgKG0gPCBuKSB0aHJvdyBcIk5lZWQgbW9yZSByb3dzIHRoYW4gY29sdW1uc1wiXHJcblx0XHJcblx0dmFyIGUgPSBuZXcgQXJyYXkobik7XHJcblx0dmFyIHEgPSBuZXcgQXJyYXkobik7XHJcblx0Zm9yIChpPTA7IGk8bjsgaSsrKSBlW2ldID0gcVtpXSA9IDAuMDtcclxuXHR2YXIgdiA9IG51bWVyaWMucmVwKFtuLG5dLDApO1xyXG4vL1x0di56ZXJvKCk7XHJcblx0XHJcbiBcdGZ1bmN0aW9uIHB5dGhhZyhhLGIpXHJcbiBcdHtcclxuXHRcdGEgPSBNYXRoLmFicyhhKVxyXG5cdFx0YiA9IE1hdGguYWJzKGIpXHJcblx0XHRpZiAoYSA+IGIpXHJcblx0XHRcdHJldHVybiBhKk1hdGguc3FydCgxLjArKGIqYi9hL2EpKVxyXG5cdFx0ZWxzZSBpZiAoYiA9PSAwLjApIFxyXG5cdFx0XHRyZXR1cm4gYVxyXG5cdFx0cmV0dXJuIGIqTWF0aC5zcXJ0KDEuMCsoYSphL2IvYikpXHJcblx0fVxyXG5cclxuXHQvL0hvdXNlaG9sZGVyJ3MgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybVxyXG5cclxuXHR2YXIgZj0gMC4wO1xyXG5cdHZhciBnPSAwLjA7XHJcblx0dmFyIGg9IDAuMDtcclxuXHR2YXIgeD0gMC4wO1xyXG5cdHZhciB5PSAwLjA7XHJcblx0dmFyIHo9IDAuMDtcclxuXHR2YXIgcz0gMC4wO1xyXG5cdFxyXG5cdGZvciAoaT0wOyBpIDwgbjsgaSsrKVxyXG5cdHtcdFxyXG5cdFx0ZVtpXT0gZztcclxuXHRcdHM9IDAuMDtcclxuXHRcdGw9IGkrMTtcclxuXHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSBcclxuXHRcdFx0cyArPSAodVtqXVtpXSp1W2pdW2ldKTtcclxuXHRcdGlmIChzIDw9IHRvbGVyYW5jZSlcclxuXHRcdFx0Zz0gMC4wO1xyXG5cdFx0ZWxzZVxyXG5cdFx0e1x0XHJcblx0XHRcdGY9IHVbaV1baV07XHJcblx0XHRcdGc9IE1hdGguc3FydChzKTtcclxuXHRcdFx0aWYgKGYgPj0gMC4wKSBnPSAtZztcclxuXHRcdFx0aD0gZipnLXNcclxuXHRcdFx0dVtpXVtpXT1mLWc7XHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cz0gMC4wXHJcblx0XHRcdFx0Zm9yIChrPWk7IGsgPCBtOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSB1W2tdW2ldKnVba11bal1cclxuXHRcdFx0XHRmPSBzL2hcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgXHJcblx0XHRcdFx0XHR1W2tdW2pdKz1mKnVba11baV1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cVtpXT0gZ1xyXG5cdFx0cz0gMC4wXHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdHM9IHMgKyB1W2ldW2pdKnVbaV1bal1cclxuXHRcdGlmIChzIDw9IHRvbGVyYW5jZSlcclxuXHRcdFx0Zz0gMC4wXHJcblx0XHRlbHNlXHJcblx0XHR7XHRcclxuXHRcdFx0Zj0gdVtpXVtpKzFdXHJcblx0XHRcdGc9IE1hdGguc3FydChzKVxyXG5cdFx0XHRpZiAoZiA+PSAwLjApIGc9IC1nXHJcblx0XHRcdGg9IGYqZyAtIHNcclxuXHRcdFx0dVtpXVtpKzFdID0gZi1nO1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgZVtqXT0gdVtpXVtqXS9oXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbTsgaisrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHMgKz0gKHVbal1ba10qdVtpXVtrXSlcclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHR1W2pdW2tdKz1zKmVba11cclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHR5PSBNYXRoLmFicyhxW2ldKStNYXRoLmFicyhlW2ldKVxyXG5cdFx0aWYgKHk+eCkgXHJcblx0XHRcdHg9eVxyXG5cdH1cclxuXHRcclxuXHQvLyBhY2N1bXVsYXRpb24gb2YgcmlnaHQgaGFuZCBndHJhbnNmb3JtYXRpb25zXHJcblx0Zm9yIChpPW4tMTsgaSAhPSAtMTsgaSs9IC0xKVxyXG5cdHtcdFxyXG5cdFx0aWYgKGcgIT0gMC4wKVxyXG5cdFx0e1xyXG5cdFx0IFx0aD0gZyp1W2ldW2krMV1cclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspIFxyXG5cdFx0XHRcdHZbal1baV09dVtpXVtqXS9oXHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHMgKz0gdVtpXVtrXSp2W2tdW2pdXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0dltrXVtqXSs9KHMqdltrXVtpXSlcclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdHtcclxuXHRcdFx0dltpXVtqXSA9IDA7XHJcblx0XHRcdHZbal1baV0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dltpXVtpXSA9IDE7XHJcblx0XHRnPSBlW2ldXHJcblx0XHRsPSBpXHJcblx0fVxyXG5cdFxyXG5cdC8vIGFjY3VtdWxhdGlvbiBvZiBsZWZ0IGhhbmQgdHJhbnNmb3JtYXRpb25zXHJcblx0Zm9yIChpPW4tMTsgaSAhPSAtMTsgaSs9IC0xKVxyXG5cdHtcdFxyXG5cdFx0bD0gaSsxXHJcblx0XHRnPSBxW2ldXHJcblx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdHVbaV1bal0gPSAwO1xyXG5cdFx0aWYgKGcgIT0gMC4wKVxyXG5cdFx0e1xyXG5cdFx0XHRoPSB1W2ldW2ldKmdcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzPTAuMFxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbTsgaysrKSBzICs9IHVba11baV0qdVtrXVtqXTtcclxuXHRcdFx0XHRmPSBzL2hcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgdVtrXVtqXSs9Zip1W2tdW2ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSB1W2pdW2ldID0gdVtqXVtpXS9nO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRmb3IgKGo9aTsgaiA8IG07IGorKykgdVtqXVtpXSA9IDA7XHJcblx0XHR1W2ldW2ldICs9IDE7XHJcblx0fVxyXG5cdFxyXG5cdC8vIGRpYWdvbmFsaXphdGlvbiBvZiB0aGUgYmlkaWFnb25hbCBmb3JtXHJcblx0cHJlYz0gcHJlYyp4XHJcblx0Zm9yIChrPW4tMTsgayAhPSAtMTsgays9IC0xKVxyXG5cdHtcclxuXHRcdGZvciAodmFyIGl0ZXJhdGlvbj0wOyBpdGVyYXRpb24gPCBpdG1heDsgaXRlcmF0aW9uKyspXHJcblx0XHR7XHQvLyB0ZXN0IGYgc3BsaXR0aW5nXHJcblx0XHRcdHZhciB0ZXN0X2NvbnZlcmdlbmNlID0gZmFsc2VcclxuXHRcdFx0Zm9yIChsPWs7IGwgIT0gLTE7IGwrPSAtMSlcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKGVbbF0pIDw9IHByZWMpXHJcblx0XHRcdFx0e1x0dGVzdF9jb252ZXJnZW5jZT0gdHJ1ZVxyXG5cdFx0XHRcdFx0YnJlYWsgXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChNYXRoLmFicyhxW2wtMV0pIDw9IHByZWMpXHJcblx0XHRcdFx0XHRicmVhayBcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIXRlc3RfY29udmVyZ2VuY2UpXHJcblx0XHRcdHtcdC8vIGNhbmNlbGxhdGlvbiBvZiBlW2xdIGlmIGw+MFxyXG5cdFx0XHRcdGM9IDAuMFxyXG5cdFx0XHRcdHM9IDEuMFxyXG5cdFx0XHRcdHZhciBsMT0gbC0xXHJcblx0XHRcdFx0Zm9yIChpID1sOyBpPGsrMTsgaSsrKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0Zj0gcyplW2ldXHJcblx0XHRcdFx0XHRlW2ldPSBjKmVbaV1cclxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhmKSA8PSBwcmVjKVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Zz0gcVtpXVxyXG5cdFx0XHRcdFx0aD0gcHl0aGFnKGYsZylcclxuXHRcdFx0XHRcdHFbaV09IGhcclxuXHRcdFx0XHRcdGM9IGcvaFxyXG5cdFx0XHRcdFx0cz0gLWYvaFxyXG5cdFx0XHRcdFx0Zm9yIChqPTA7IGogPCBtOyBqKyspXHJcblx0XHRcdFx0XHR7XHRcclxuXHRcdFx0XHRcdFx0eT0gdVtqXVtsMV1cclxuXHRcdFx0XHRcdFx0ej0gdVtqXVtpXVxyXG5cdFx0XHRcdFx0XHR1W2pdW2wxXSA9ICB5KmMrKHoqcylcclxuXHRcdFx0XHRcdFx0dVtqXVtpXSA9IC15KnMrKHoqYylcclxuXHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0fVx0XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gdGVzdCBmIGNvbnZlcmdlbmNlXHJcblx0XHRcdHo9IHFba11cclxuXHRcdFx0aWYgKGw9PSBrKVxyXG5cdFx0XHR7XHQvL2NvbnZlcmdlbmNlXHJcblx0XHRcdFx0aWYgKHo8MC4wKVxyXG5cdFx0XHRcdHtcdC8vcVtrXSBpcyBtYWRlIG5vbi1uZWdhdGl2ZVxyXG5cdFx0XHRcdFx0cVtrXT0gLXpcclxuXHRcdFx0XHRcdGZvciAoaj0wOyBqIDwgbjsgaisrKVxyXG5cdFx0XHRcdFx0XHR2W2pdW2tdID0gLXZbal1ba11cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWsgIC8vYnJlYWsgb3V0IG9mIGl0ZXJhdGlvbiBsb29wIGFuZCBtb3ZlIG9uIHRvIG5leHQgayB2YWx1ZVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpdGVyYXRpb24gPj0gaXRtYXgtMSlcclxuXHRcdFx0XHR0aHJvdyAnRXJyb3I6IG5vIGNvbnZlcmdlbmNlLidcclxuXHRcdFx0Ly8gc2hpZnQgZnJvbSBib3R0b20gMngyIG1pbm9yXHJcblx0XHRcdHg9IHFbbF1cclxuXHRcdFx0eT0gcVtrLTFdXHJcblx0XHRcdGc9IGVbay0xXVxyXG5cdFx0XHRoPSBlW2tdXHJcblx0XHRcdGY9ICgoeS16KSooeSt6KSsoZy1oKSooZytoKSkvKDIuMCpoKnkpXHJcblx0XHRcdGc9IHB5dGhhZyhmLDEuMClcclxuXHRcdFx0aWYgKGYgPCAwLjApXHJcblx0XHRcdFx0Zj0gKCh4LXopKih4K3opK2gqKHkvKGYtZyktaCkpL3hcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGY9ICgoeC16KSooeCt6KStoKih5LyhmK2cpLWgpKS94XHJcblx0XHRcdC8vIG5leHQgUVIgdHJhbnNmb3JtYXRpb25cclxuXHRcdFx0Yz0gMS4wXHJcblx0XHRcdHM9IDEuMFxyXG5cdFx0XHRmb3IgKGk9bCsxOyBpPCBrKzE7IGkrKylcclxuXHRcdFx0e1x0XHJcblx0XHRcdFx0Zz0gZVtpXVxyXG5cdFx0XHRcdHk9IHFbaV1cclxuXHRcdFx0XHRoPSBzKmdcclxuXHRcdFx0XHRnPSBjKmdcclxuXHRcdFx0XHR6PSBweXRoYWcoZixoKVxyXG5cdFx0XHRcdGVbaS0xXT0gelxyXG5cdFx0XHRcdGM9IGYvelxyXG5cdFx0XHRcdHM9IGgvelxyXG5cdFx0XHRcdGY9IHgqYytnKnNcclxuXHRcdFx0XHRnPSAteCpzK2cqY1xyXG5cdFx0XHRcdGg9IHkqc1xyXG5cdFx0XHRcdHk9IHkqY1xyXG5cdFx0XHRcdGZvciAoaj0wOyBqIDwgbjsgaisrKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0eD0gdltqXVtpLTFdXHJcblx0XHRcdFx0XHR6PSB2W2pdW2ldXHJcblx0XHRcdFx0XHR2W2pdW2ktMV0gPSB4KmMreipzXHJcblx0XHRcdFx0XHR2W2pdW2ldID0gLXgqcyt6KmNcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ej0gcHl0aGFnKGYsaClcclxuXHRcdFx0XHRxW2ktMV09IHpcclxuXHRcdFx0XHRjPSBmL3pcclxuXHRcdFx0XHRzPSBoL3pcclxuXHRcdFx0XHRmPSBjKmcrcyp5XHJcblx0XHRcdFx0eD0gLXMqZytjKnlcclxuXHRcdFx0XHRmb3IgKGo9MDsgaiA8IG07IGorKylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR5PSB1W2pdW2ktMV1cclxuXHRcdFx0XHRcdHo9IHVbal1baV1cclxuXHRcdFx0XHRcdHVbal1baS0xXSA9IHkqYyt6KnNcclxuXHRcdFx0XHRcdHVbal1baV0gPSAteSpzK3oqY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlW2xdPSAwLjBcclxuXHRcdFx0ZVtrXT0gZlxyXG5cdFx0XHRxW2tdPSB4XHJcblx0XHR9IFxyXG5cdH1cclxuXHRcdFxyXG5cdC8vdnQ9IHRyYW5zcG9zZSh2KVxyXG5cdC8vcmV0dXJuICh1LHEsdnQpXHJcblx0Zm9yIChpPTA7aTxxLmxlbmd0aDsgaSsrKSBcclxuXHQgIGlmIChxW2ldIDwgcHJlYykgcVtpXSA9IDBcclxuXHQgIFxyXG5cdC8vc29ydCBlaWdlbnZhbHVlc1x0XHJcblx0Zm9yIChpPTA7IGk8IG47IGkrKylcclxuXHR7XHQgXHJcblx0Ly93cml0ZWxuKHEpXHJcblx0IGZvciAoaj1pLTE7IGogPj0gMDsgai0tKVxyXG5cdCB7XHJcblx0ICBpZiAocVtqXSA8IHFbaV0pXHJcblx0ICB7XHJcblx0Ly8gIHdyaXRlbG4oaSwnLScsailcclxuXHQgICBjID0gcVtqXVxyXG5cdCAgIHFbal0gPSBxW2ldXHJcblx0ICAgcVtpXSA9IGNcclxuXHQgICBmb3Ioaz0wO2s8dS5sZW5ndGg7aysrKSB7IHRlbXAgPSB1W2tdW2ldOyB1W2tdW2ldID0gdVtrXVtqXTsgdVtrXVtqXSA9IHRlbXA7IH1cclxuXHQgICBmb3Ioaz0wO2s8di5sZW5ndGg7aysrKSB7IHRlbXAgPSB2W2tdW2ldOyB2W2tdW2ldID0gdltrXVtqXTsgdltrXVtqXSA9IHRlbXA7IH1cclxuLy9cdCAgIHUuc3dhcENvbHMoaSxqKVxyXG4vL1x0ICAgdi5zd2FwQ29scyhpLGopXHJcblx0ICAgaSA9IGpcdCAgIFxyXG5cdCAgfVxyXG5cdCB9XHRcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHtVOnUsUzpxLFY6dn1cclxufTtcclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHJldHVybiBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdHZhciBrZXkgPSBwYXJ0c1swXTtcblx0XHR2YXIgdmFsID0gcGFydHNbMV07XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCB7fSk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zb3J0KCkubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwyKTtcblx0XHRcdH0pLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG5cdH0pO1xufTtcbiIsIiMjI1xuXG5BIENvbXB1dGF0aW9uTWFuYWdlciBpcyB1c2VkIHRvIG1lbW9pemUgZnVuY3Rpb25zIHdpdGhpbiBhIGNvbXB1dGF0aW9uLiBVc2VcbkNvbXB1dGF0aW9uTWFuYWdlci5ydW4oY2FsbGJhY2spIHRvIHN0YXJ0IGEgbmV3IGNvbXB1dGF0aW9uIGFuZCB0aGVuIGFueVxubWVtb2l6ZWQgZnVuY3Rpb25zIHdpbGwgYmUgbWVtb2l6ZWQgd2l0aGluIHRoYXQgY29tcHV0YXRpb24uXG5cblRPRE86IFdyaXRlIHRlc3RzXG5cbiMjI1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbXB1dGF0aW9uTWFuYWdlclxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAaXNSdW5uaW5nID0gZmFsc2VcbiAgICBAY291bnRlciA9IDBcblxuICAjIEFueSBtZW1vaXplZCBmdW5jdGlvbnMgKHNlZSBiZWxvdykgdGhhdCBhcmUgY2FsbGVkIHdpdGhpbiBjYWxsYmFjayB3aWxsXG4gICMgbmV2ZXIgZXhlY3V0ZWQgbW9yZSB0aGFuIG9uY2UuIFRoZXkgd2lsbCBpbnN0ZWFkIHJldHVybiB0aGVpciBjYWNoZWRcbiAgIyB2YWx1ZS5cbiAgcnVuOiAoY2FsbGJhY2spIC0+XG4gICAgQGlzUnVubmluZyA9IHRydWVcbiAgICBAY291bnRlcisrXG4gICAgdHJ5XG4gICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgIGZpbmFsbHlcbiAgICAgIEBpc1J1bm5pbmcgPSBmYWxzZVxuXG4gICMgVGFrZXMgYSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIG1lbW9pemVkIHZlcnNpb24uXG4gIG1lbW9pemU6IChmbikgLT5cbiAgICBjYWNoZWRWYWx1ZSA9IG51bGxcbiAgICBsYXN0RXZhbHVhdGVkID0gLTFcbiAgICByZXR1cm4gPT5cbiAgICAgIGlmIGxhc3RFdmFsdWF0ZWQgIT0gQGNvdW50ZXJcbiAgICAgICAgY2FjaGVkVmFsdWUgPSBmbigpXG4gICAgICAgIGxhc3RFdmFsdWF0ZWQgPSBAY291bnRlclxuICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuQ29tcHV0YXRpb25NYW5hZ2VyID0gcmVxdWlyZSBcIi4vQ29tcHV0YXRpb25NYW5hZ2VyXCJcbkR5bmFtaWNTY29wZSA9IHJlcXVpcmUgXCIuL0R5bmFtaWNTY29wZVwiXG5TcHJlYWQgPSByZXF1aXJlIFwiLi9TcHJlYWRcIlxuU3ByZWFkRW52ID0gcmVxdWlyZSBcIi4vU3ByZWFkRW52XCJcblxuXG5jb21wdXRhdGlvbk1hbmFnZXIgPSBuZXcgQ29tcHV0YXRpb25NYW5hZ2VyKClcblxuZHluYW1pY1Njb3BlID0gbmV3IER5bmFtaWNTY29wZSB7XG4gICMgVGhlIGN1cnJlbnQgc3ByZWFkIGVudmlyb25tZW50LlxuICBzcHJlYWRFbnY6IFNwcmVhZEVudi5lbXB0eVxuXG4gICMgV2hldGhlciBvciBub3QgY2VsbHMgc2hvdWxkIHRocm93IGFuIFVucmVzb2x2ZWRTcHJlYWRFcnJvciBpZiB0aGV5XG4gICMgZW5jb3VudGVyIGEgc3ByZWFkIHRoYXQgaXMgbm90IGluIHRoZSBjdXJyZW50IHNwcmVhZCBlbnZpcm9ubWVudC5cbiAgc2hvdWxkVGhyb3c6IGZhbHNlXG59XG5cbmNsYXNzIFVucmVzb2x2ZWRTcHJlYWRFcnJvclxuICBjb25zdHJ1Y3RvcjogKEBzcHJlYWQpIC0+XG5cblxuY2VsbCA9IChmbikgLT5cblxuICAjIFRoZXNlIGFyZSB0aGUgd29ya2hvcnNlIGZ1bmN0aW9ucyB0aGF0IHRvZ2V0aGVyIGV2YWx1YXRlIHRoZSBjZWxsLlxuXG4gIHJ1bkZuID0gLT5cbiAgICB0cnlcbiAgICAgIHJldHVybiBmbigpIGlmIGR5bmFtaWNTY29wZS5jb250ZXh0LnNob3VsZFRocm93XG4gICAgICByZXR1cm4gZHluYW1pY1Njb3BlLndpdGgge3Nob3VsZFRocm93OiB0cnVlfSwgZm5cbiAgICBjYXRjaCBlcnJvclxuICAgICAgaWYgZXJyb3IgaW5zdGFuY2VvZiBVbnJlc29sdmVkU3ByZWFkRXJyb3JcbiAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGVBY3Jvc3NTcHJlYWQoZXJyb3Iuc3ByZWFkKVxuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBlcnJvclxuXG4gIGRpc3RyaWJ1dGVBY3Jvc3NTcHJlYWQgPSAoc3ByZWFkKSAtPlxuICAgIGN1cnJlbnRTcHJlYWRFbnYgPSBkeW5hbWljU2NvcGUuY29udGV4dC5zcHJlYWRFbnZcbiAgICBpdGVtcyA9IF8ubWFwIHNwcmVhZC5pdGVtcywgKGl0ZW0sIGluZGV4KSAtPlxuICAgICAgc3ByZWFkRW52ID0gY3VycmVudFNwcmVhZEVudi5hc3NpZ24oc3ByZWFkLCBpbmRleClcbiAgICAgIHJldHVybiBkeW5hbWljU2NvcGUud2l0aCB7c3ByZWFkRW52fSwgcnVuRm5cbiAgICByZXR1cm4gbmV3IFNwcmVhZChpdGVtcywgc3ByZWFkLm9yaWdpbilcblxuXG4gIGV2YWx1YXRlRnVsbCA9IC0+XG4gICAgcmV0dXJuIGR5bmFtaWNTY29wZS53aXRoIHtzcHJlYWRFbnY6IFNwcmVhZEVudi5lbXB0eX0sIHJ1bkZuXG5cbiAgZXZhbHVhdGVGdWxsID0gY29tcHV0YXRpb25NYW5hZ2VyLm1lbW9pemUoZXZhbHVhdGVGdWxsKVxuXG5cbiAgIyByZXNvbHZlIHdpbGwgcmVjdXJzaXZlbHkgdHJ5IHRvIHJlc29sdmUgdmFsdWUgaW4gdGhlIGN1cnJlbnQgc3ByZWFkXG4gICMgZW52aXJvbm1lbnQgdW50aWwgaXQgZ2V0cyB0byBhIG5vbi1TcHJlYWQgb3IgYSBTcHJlYWQgdGhhdCBpcyBub3QgaW4gdGhlXG4gICMgZW52aXJvbm1lbnQuXG4gIHJlc29sdmUgPSAodmFsdWUpIC0+XG4gICAgY3VycmVudFNwcmVhZEVudiA9IGR5bmFtaWNTY29wZS5jb250ZXh0LnNwcmVhZEVudlxuICAgIHJldHVybiBjdXJyZW50U3ByZWFkRW52LnJlc29sdmUodmFsdWUpXG5cblxuICAjIFwiUHVibGljXCIgbWV0aG9kcy5cbiAgYXNTcHJlYWQgPSAtPlxuICAgIGlmICFjb21wdXRhdGlvbk1hbmFnZXIuaXNSdW5uaW5nXG4gICAgICByZXR1cm4gY29tcHV0YXRpb25NYW5hZ2VyLnJ1bihhc1NwcmVhZClcbiAgICB2YWx1ZSA9IGV2YWx1YXRlRnVsbCgpXG4gICAgdmFsdWUgPSByZXNvbHZlKHZhbHVlKVxuICAgIHJldHVybiB2YWx1ZVxuXG4gIGNlbGxGbiA9IC0+XG4gICAgaWYgIWNvbXB1dGF0aW9uTWFuYWdlci5pc1J1bm5pbmdcbiAgICAgIHJldHVybiBjb21wdXRhdGlvbk1hbmFnZXIucnVuKGNlbGxGbilcbiAgICB2YWx1ZSA9IGFzU3ByZWFkKClcbiAgICBpZiBkeW5hbWljU2NvcGUuY29udGV4dC5zaG91bGRUaHJvdyBhbmQgdmFsdWUgaW5zdGFuY2VvZiBTcHJlYWRcbiAgICAgIHRocm93IG5ldyBVbnJlc29sdmVkU3ByZWFkRXJyb3IodmFsdWUpXG4gICAgcmV0dXJuIHZhbHVlXG5cbiAgIyBQYWNrYWdlIGl0IHVwLlxuICBjZWxsRm4uYXNTcHJlYWQgPSBhc1NwcmVhZFxuICByZXR1cm4gY2VsbEZuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhZmxvdyA9IHtcbiAgcnVuOiAoY2FsbGJhY2spIC0+IGNvbXB1dGF0aW9uTWFuYWdlci5ydW4oY2FsbGJhY2spXG4gIGN1cnJlbnRTcHJlYWRFbnY6IC0+IGR5bmFtaWNTY29wZS5jb250ZXh0LnNwcmVhZEVudlxuICBtZW1vaXplOiAoZm4pIC0+IGNvbXB1dGF0aW9uTWFuYWdlci5tZW1vaXplKGZuKVxuICBjZWxsLCBTcHJlYWQsIFNwcmVhZEVudiwgVW5yZXNvbHZlZFNwcmVhZEVycm9yXG59XG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIER5bmFtaWNTY29wZVxuICBjb25zdHJ1Y3RvcjogKEBjb250ZXh0PXt9KSAtPlxuXG4gIHdpdGg6IChuZXdDb250ZXh0LCBmbikgLT5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBAY29udGV4dFxuICAgIEBfdXBkYXRlQ29udGV4dChwcmV2aW91c0NvbnRleHQsIG5ld0NvbnRleHQpXG5cbiAgICB0cnlcbiAgICAgIHJlc3VsdCA9IGZuKClcbiAgICBmaW5hbGx5XG4gICAgICBAY29udGV4dCA9IHByZXZpb3VzQ29udGV4dFxuICAgIHJldHVybiByZXN1bHRcblxuICBfdXBkYXRlQ29udGV4dDogKHByZXZpb3VzQ29udGV4dCwgbmV3Q29udGV4dCkgLT5cbiAgICBAY29udGV4dCA9IG5ld0NvbnRleHRcbiAgICBmb3Igb3duIGtleSwgdmFsdWUgb2YgcHJldmlvdXNDb250ZXh0XG4gICAgICBAY29udGV4dFtrZXldID0gdmFsdWUgdW5sZXNzIEBjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSlcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcHJlYWRcbiAgY29uc3RydWN0b3I6IChAaXRlbXMsIEBvcmlnaW4pIC0+XG5cbiAgIyBSZWN1cnNpdmVseSBjb252ZXJ0cyBhIHNwcmVhZCB0byBhbiBhcnJheS4gU28gaWYgSSdtIGEgbmVzdGVkIHNwcmVhZCxcbiAgIyB0b0FycmF5IHdpbGwgcmV0dXJuIGEgbmVzdGVkIGFycmF5LlxuICB0b0FycmF5OiAtPlxuICAgIF8ubWFwIEBpdGVtcywgKGl0ZW0pIC0+XG4gICAgICBpZiBpdGVtIGluc3RhbmNlb2YgU3ByZWFkXG4gICAgICAgIGl0ZW0udG9BcnJheSgpXG4gICAgICBlbHNlXG4gICAgICAgIGl0ZW1cblxuICBmbGF0dGVuVG9BcnJheTogLT5cbiAgICBfLmZsYXR0ZW4oQHRvQXJyYXkoKSlcbiIsIlNwcmVhZCA9IHJlcXVpcmUgXCIuL1NwcmVhZFwiXG5cbiMgVE9ETzogVGhpcyBzaG91bGQgaGF2ZSB0ZXN0cyBmb3IgaXNFcXVhbFRvIGFuZCBjb250YWluc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNwcmVhZEVudlxuICBjb25zdHJ1Y3RvcjogKEBwYXJlbnQsIEBvcmlnaW4sIEBpbmRleCkgLT5cblxuICBsb29rdXA6IChzcHJlYWQpIC0+XG4gICAgaWYgc3ByZWFkLm9yaWdpbiA9PSBAb3JpZ2luXG4gICAgICByZXR1cm4gQGluZGV4XG4gICAgcmV0dXJuIEBwYXJlbnQ/Lmxvb2t1cChzcHJlYWQpXG5cbiAgIyBJZiB2YWx1ZSBpcyBhIHNwcmVhZCwgcmVzb2x2ZSB3aWxsIHJlY3Vyc2l2ZWx5IHRyeSB0byBsb29rdXAgYW4gaW5kZXggYW5kXG4gICMgcmV0dXJuIHRoZSBpdGVtIGF0IHRoYXQgaW5kZXguXG4gIHJlc29sdmU6ICh2YWx1ZSkgLT5cbiAgICBpZiB2YWx1ZSBpbnN0YW5jZW9mIFNwcmVhZFxuICAgICAgaW5kZXggPSBAbG9va3VwKHZhbHVlKVxuICAgICAgaWYgaW5kZXg/XG4gICAgICAgIHZhbHVlID0gdmFsdWUuaXRlbXNbaW5kZXhdXG4gICAgICAgIHJldHVybiBAcmVzb2x2ZSh2YWx1ZSlcbiAgICByZXR1cm4gdmFsdWVcblxuICAjIExpa2UgcmVzb2x2ZSwgYnV0IHdpbGwgdGFrZSBpbmRleCAwIGlmIHRoZSBzcHJlYWQgY2Fubm90IGJlIGZvdW5kLlxuICByZXNvbHZlV2l0aERlZmF1bHQ6ICh2YWx1ZSkgLT5cbiAgICBpZiB2YWx1ZSBpbnN0YW5jZW9mIFNwcmVhZFxuICAgICAgaW5kZXggPSBAbG9va3VwKHZhbHVlKSA/IDBcbiAgICAgIHZhbHVlID0gdmFsdWUuaXRlbXNbaW5kZXhdXG4gICAgICByZXR1cm4gQHJlc29sdmVXaXRoRGVmYXVsdCh2YWx1ZSlcbiAgICByZXR1cm4gdmFsdWVcblxuXG4gICMgTm90ZTogYXNzaWduIGlzIG5vdCBhIG11dGF0aW9uLCBpdCByZXR1cm5zIGEgbmV3IFNwcmVhZEVudiB3aGVyZSBzcHJlYWQgaXNcbiAgIyBhc3NpZ25lZCB0byBpbmRleC5cbiAgYXNzaWduOiAoc3ByZWFkLCBpbmRleCkgLT5cbiAgICByZXR1cm4gbmV3IFNwcmVhZEVudih0aGlzLCBzcHJlYWQub3JpZ2luLCBpbmRleClcblxuICBpc0VxdWFsVG86IChzcHJlYWRFbnYpIC0+XG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBzcHJlYWRFbnY/XG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBAb3JpZ2luID09IHNwcmVhZEVudi5vcmlnaW4gYW5kIEBpbmRleCA9PSBzcHJlYWRFbnYuaW5kZXhcbiAgICByZXR1cm4gdHJ1ZSBpZiAhQHBhcmVudCBhbmQgIXNwcmVhZEVudi5wYXJlbnRcbiAgICByZXR1cm4gQHBhcmVudC5pc0VxdWFsVG8oc3ByZWFkRW52LnBhcmVudClcblxuICBjb250YWluczogKHNwcmVhZEVudikgLT5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHNwcmVhZEVudj9cbiAgICByZXR1cm4gdHJ1ZSBpZiBAaXNFcXVhbFRvKHNwcmVhZEVudilcbiAgICByZXR1cm4gQGNvbnRhaW5zKHNwcmVhZEVudi5wYXJlbnQpXG5cblxuU3ByZWFkRW52LmVtcHR5ID0gbmV3IFNwcmVhZEVudigpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXZhbHVhdGU6IHJlcXVpcmUgXCIuL2V2YWx1YXRlXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXZhbHVhdGUgPSAoanNTdHJpbmcpIC0+XG4gIHJldHVybiBldmFsKGpzU3RyaW5nKVxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgQnVpbHQtaW4gRnVuY3Rpb25zXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbkUgPSBNYXRoLkVcbkxOMiA9IE1hdGguTE4yXG5MTjEwID0gTWF0aC5MTjEwXG5MT0cyRSA9IE1hdGguTE9HMkVcbkxPRzEwRSA9IE1hdGguTE9HMTBFXG5QSSA9IE1hdGguUElcblNRUlQxXzIgPSBNYXRoLlNRUlQxXzJcblNRUlQyID0gTWF0aC5TUVJUMlxuVEFVID0gTWF0aC5QSSAqIDJcblxuYWJzID0gTWF0aC5hYnNcbmFjb3MgPSBNYXRoLmFjb3NcbmFzaW4gPSBNYXRoLmFzaW5cbmF0YW4gPSBNYXRoLmF0YW5cbmF0YW4yID0gTWF0aC5hdGFuMlxuY2VpbCA9IE1hdGguY2VpbFxuY29zID0gTWF0aC5jb3NcbmV4cCA9IE1hdGguZXhwXG5mbG9vciA9IE1hdGguZmxvb3JcbmxvZyA9IE1hdGgubG9nXG5tYXggPSBNYXRoLm1heFxubWluID0gTWF0aC5taW5cbnBvdyA9IE1hdGgucG93XG5yYW5kb20gPSBNYXRoLnJhbmRvbVxucm91bmQgPSBNYXRoLnJvdW5kXG5zaW4gPSBNYXRoLnNpblxuc3FydCA9IE1hdGguc3FydFxudGFuID0gTWF0aC50YW5cblxucmdiYSA9IChyLCBnLCBiLCBhKSAtPlxuICByID0gTWF0aC5yb3VuZChyICogMjU1KVxuICBnID0gTWF0aC5yb3VuZChnICogMjU1KVxuICBiID0gTWF0aC5yb3VuZChiICogMjU1KVxuICByZXR1cm4gXCJyZ2JhKCN7cn0sICN7Z30sICN7Yn0sICN7YX0pXCJcblxuc3ByZWFkID0gcmVxdWlyZSBcIi4vc3ByZWFkXCJcblxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbkRhdGFmbG93ID0gcmVxdWlyZSBcIi4uL0RhdGFmbG93L0RhdGFmbG93XCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHNwcmVhZCA9IChzdGFydCwgZW5kLCBpbmNyZW1lbnQ9MSkgLT5cbiAgaWYgXy5pc0FycmF5KHN0YXJ0KVxuICAgIHJldHVybiBuZXcgRGF0YWZsb3cuU3ByZWFkKHN0YXJ0KVxuXG4gIGlmICFzdGFydD8gb3IgIWVuZD9cbiAgICB0aHJvdyBcIlNwcmVhZCBuZWVkcyBhcmd1bWVudHM6IHNwcmVhZChzdGFydCwgZW5kKSBvciBzcHJlYWQoc3RhcnQsIGVuZCwgaW5jcmVtZW50KSBvciBzcHJlYWQoYXJyYXkpXCJcbiAgaWYgaW5jcmVtZW50ID09IDBcbiAgICB0aHJvdyBcIlNwcmVhZCBpbmNyZW1lbnQgY2Fubm90IGJlIDBcIlxuICBpZiAhXy5pc0Zpbml0ZShpbmNyZW1lbnQpXG4gICAgdGhyb3cgXCJTcHJlYWQgaW5jcmVtZW50IG11c3QgYmUgZmluaXRlXCJcblxuICBuID0gKGVuZCAtIHN0YXJ0KSAvIGluY3JlbWVudFxuICBhcnJheSA9IChzdGFydCArIGluY3JlbWVudCAqIGkgZm9yIGkgaW4gWzAgLi4uIG5dKVxuICByZXR1cm4gbmV3IERhdGFmbG93LlNwcmVhZChhcnJheSlcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpYyA9IHt9XG5cblxuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIyBCYXNlIEVsZW1lbnRcbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY2xhc3MgR3JhcGhpYy5FbGVtZW50XG4gICMjI1xuXG4gIEVhY2ggR3JhcGhpYy5FbGVtZW50IG11c3QgaGF2ZSB0aGVzZSBwcm9wZXJ0aWVzOlxuXG4gIHBhcnRpY3VsYXJFbGVtZW50OiBUaGUgUGFydGljdWxhckVsZW1lbnQgdGhhdCBnZW5lcmF0ZWQgdGhlIGdyYXBoaWMuIFRoaXMgaXNcbiAgdXNlZCBmb3IgXCJiYWNrIHRyYWNpbmdcIiB3aGF0IHBhcnQgb2YgdGhlIG1vZGVsIGdlbmVyYXRlZCB0aGlzIGdyYXBoaWMsIGUuZy5cbiAgdG8gaW1wbGVtZW50IHNlbGVjdGlvbiB3aGVuIHlvdSBjbGljayBhIHNoYXBlIG9uIHRoZSBjYW52YXMuXG5cbiAgbWF0cml4OiBhIFV0aWwuTWF0cml4IHRoYXQgaXMgdGhlIGdyYXBoaWMncyAqYWNjdW11bGF0ZWQqIHRyYW5zZm9ybWF0aW9uLlxuXG4gIGNvbXBvbmVudHM6IGEgbGlzdCBvZiBHcmFwaGljLkNvbXBvbmVudCdzIHJlcHJlc2VudGluZyB0aGUgcGFpbnQgb3BlcmF0aW9uc1xuICB0byBwZXJmb3JtLlxuXG4gIGNoaWxkR3JhcGhpY3M6IGEgbGlzdCBvZiBHcmFwaGljLkVsZW1lbnQncy5cblxuICAjIyNcblxuICByZW5kZXI6IChvcHRzKSAtPlxuICAgICMjI1xuICAgIE9wdHM6XG5cbiAgICBjdHg6IENhbnZhcyAyRCBjb250ZXh0IHRvIHJlbmRlciBpbnRvLlxuXG4gICAgdmlld01hdHJpeDpcblxuICAgIGhpZ2hsaWdodChncmFwaGljKTogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIGEgZ3JhcGhpYyBhbmQgcmV0dXJucyBlaXRoZXJcbiAgICBhIGNvbG9yIG9yIG51bGwuXG5cbiAgICAjIyNcbiAgICB0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZFwiXG5cbiAgaGl0RGV0ZWN0OiAob3B0cykgLT5cbiAgICAjIyNcblxuICAgIEdpdmVuICh4LHkpLCByZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm90aGluZyB1bmRlciAoeCx5KSwgdGhhdCBpcyAoeCx5KVxuICAgIGlzIGEgYmFja2dyb3VuZCBwaXhlbC4gT3RoZXJ3aXNlIHJldHVybnMgYSBsaXN0IG9mIFBhcnRpY3VsYXJFbGVtZW50cyB3aGljaCBhcmVcbiAgICB1bmRlciAoeCx5KS4gVGhlIGxpc3QgZ29lcyBpbiBvcmRlciBvZiBkZWVwZXN0IHRvIHNoYWxsb3dlc3QuIFNvIGFzc3VtaW5nXG4gICAgdGhlcmUncyBhIGhpdDogdGhlIGZpcnN0IFBhcnRpY3VsYXJFbGVtZW50IGlzIHRoZSBkZWVwZXN0IG9uZSB0aGF0IGlzIHVuZGVyICh4LHkpXG4gICAgYW5kIHRoZSBsYXN0IFBhcnRpY3VsYXJFbGVtZW50IGlzIChuZWNlc3NhcmlseSkgdGhpcy5wYXJ0aWN1bGFyRWxlbWVudC5cblxuICAgIE9wdHM6XG5cbiAgICB4LCB5OiBQb3NpdGlvbiB0byBoaXQgZGV0ZWN0LlxuXG4gICAgdmlld01hdHJpeDpcblxuICAgIHNob3VsZERldGVjdEFuY2hvcihhbmNob3IpOiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gYW4gYW5jaG9yIGdyYXBoaWMgYW5kXG4gICAgcmV0dXJucyB0cnVlIG9yIGZhbHNlIHdoZXRoZXIgdG8gaGl0IGRldGVjdCB0aGF0IGFuY2hvci5cblxuICAgICMjI1xuICAgIHRocm93IFwiTm90IGltcGxlbWVudGVkXCJcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgSGVscGVyc1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbXBvbmVudE9mVHlwZTogKHR5cGUpIC0+XG4gICAgXy5maW5kIEBjb21wb25lbnRzLCAoY29tcG9uZW50KSAtPiBjb21wb25lbnQgaW5zdGFuY2VvZiB0eXBlXG5cbiAgY29tcG9uZW50c09mVHlwZTogKHR5cGUpIC0+XG4gICAgXy5maWx0ZXIgQGNvbXBvbmVudHMsIChjb21wb25lbnQpIC0+IGNvbXBvbmVudCBpbnN0YW5jZW9mIHR5cGVcblxuXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4jIEVsZW1lbnRzXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNsYXNzIEdyYXBoaWMuR3JvdXAgZXh0ZW5kcyBHcmFwaGljLkVsZW1lbnRcbiAgcmVuZGVyOiAob3B0cykgLT5cbiAgICBmb3IgY2hpbGRHcmFwaGljIGluIEBjaGlsZEdyYXBoaWNzXG4gICAgICBjaGlsZEdyYXBoaWMucmVuZGVyKG9wdHMpXG5cbiAgaGl0RGV0ZWN0OiAob3B0cykgLT5cbiAgICAjIFRPRE86IHRlc3RcbiAgICBsYXRlc3RIaXQgPSBudWxsXG4gICAgZm9yIGNoaWxkR3JhcGhpYyBpbiBAY2hpbGRHcmFwaGljc1xuICAgICAgbGF0ZXN0SGl0ID0gY2hpbGRHcmFwaGljLmhpdERldGVjdChvcHRzKSA/IGxhdGVzdEhpdFxuICAgIGlmIGxhdGVzdEhpdFxuICAgICAgcmV0dXJuIGxhdGVzdEhpdC5jb25jYXQoQHBhcnRpY3VsYXJFbGVtZW50KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsXG5cblxuXG5jbGFzcyBHcmFwaGljLkFuY2hvciBleHRlbmRzIEdyYXBoaWMuRWxlbWVudFxuXG5cblxuXG5jbGFzcyBHcmFwaGljLlBhdGggZXh0ZW5kcyBHcmFwaGljLkVsZW1lbnRcbiAgcmVuZGVyOiAob3B0cykgLT5cbiAgICBAYnVpbGRQYXRoKG9wdHMpXG4gICAgQHBlcmZvcm1QYWludE9wcyhvcHRzKVxuICAgIEBoaWdobGlnaHRJZk5lY2Vzc2FyeShvcHRzKVxuXG4gIGhpdERldGVjdDogKG9wdHMpIC0+XG4gICAgb3B0cy5jdHggPSBnZXREdW1teUNhbnZhc0N0eCgpXG4gICAge2N0eCwgeCwgeX0gPSBvcHRzXG4gICAgQGJ1aWxkUGF0aChvcHRzKVxuICAgIGlmIGN0eC5pc1BvaW50SW5QYXRoKHgsIHkpXG4gICAgICByZXR1cm4gW0BwYXJ0aWN1bGFyRWxlbWVudF1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbFxuXG4gIHBlcmZvcm1QYWludE9wczogKHtjdHh9KSAtPlxuICAgIGZvciBjb21wb25lbnQgaW4gQGNvbXBvbmVudHNPZlR5cGUoR3JhcGhpYy5QYWludE9wKVxuICAgICAgY29tcG9uZW50LnBhaW50KGN0eClcblxuICBoaWdobGlnaHRJZk5lY2Vzc2FyeTogKHtoaWdobGlnaHQsIGN0eH0pIC0+XG4gICAgcmV0dXJuIHVubGVzcyBoaWdobGlnaHRcbiAgICBoaWdobGlnaHRTcGVjID0gaGlnaGxpZ2h0KHRoaXMpXG4gICAgaWYgaGlnaGxpZ2h0U3BlY1xuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gaGlnaGxpZ2h0U3BlYy5jb2xvclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IGhpZ2hsaWdodFNwZWMubGluZVdpZHRoXG4gICAgICBjdHguc3Ryb2tlKClcbiAgICAgIGN0eC5yZXN0b3JlKClcblxuICBidWlsZFBhdGg6ICh7Y3R4LCB2aWV3TWF0cml4fSkgLT5cbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBhbmNob3JzID0gQGNvbGxlY3RBbmNob3JzKClcbiAgICBmb3IgYW5jaG9yIGluIGFuY2hvcnNcbiAgICAgIFt4LCB5XSA9IHZpZXdNYXRyaXguY29tcG9zZShhbmNob3IubWF0cml4KS5vcmlnaW4oKVxuICAgICAgY3R4LmxpbmVUbyh4LCB5KVxuXG4gICAgaWYgQGlzQ2xvc2VkKClcbiAgICAgIGN0eC5jbG9zZVBhdGgoKVxuXG4gIGNvbGxlY3RBbmNob3JzOiAtPlxuICAgIGFuY2hvcnMgPSBbXVxuICAgIGNvbGxlY3QgPSAoZ3JhcGhpYykgLT5cbiAgICAgIGlmIGdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljLkFuY2hvclxuICAgICAgICBhbmNob3JzLnB1c2goZ3JhcGhpYylcbiAgICAgIGVsc2UgaWYgZ3JhcGhpYyBpbnN0YW5jZW9mIEdyYXBoaWMuR3JvdXBcbiAgICAgICAgY29sbGVjdENoaWxkcmVuT2YoZ3JhcGhpYylcbiAgICBjb2xsZWN0Q2hpbGRyZW5PZiA9IChncmFwaGljKSAtPlxuICAgICAgZm9yIGNoaWxkR3JhcGhpYyBpbiBncmFwaGljLmNoaWxkR3JhcGhpY3NcbiAgICAgICAgY29sbGVjdChjaGlsZEdyYXBoaWMpXG4gICAgY29sbGVjdENoaWxkcmVuT2YodGhpcylcbiAgICByZXR1cm4gYW5jaG9yc1xuXG4gIGlzQ2xvc2VkOiAtPlxuICAgIHBhdGhDb21wb25lbnQgPSBAY29tcG9uZW50T2ZUeXBlKEdyYXBoaWMuUGF0aENvbXBvbmVudClcbiAgICByZXR1cm4gcGF0aENvbXBvbmVudC5jbG9zZWRcblxuXG5jbGFzcyBHcmFwaGljLkNpcmNsZSBleHRlbmRzIEdyYXBoaWMuUGF0aFxuICBidWlsZFBhdGg6ICh7Y3R4LCB2aWV3TWF0cml4fSkgLT5cbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguc2F2ZSgpXG4gICAgbWF0cml4ID0gdmlld01hdHJpeC5jb21wb3NlKEBtYXRyaXgpXG4gICAgbWF0cml4LmNhbnZhc1RyYW5zZm9ybShjdHgpXG4gICAgY3R4LmFyYygwLCAwLCAxLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXG4gICAgY3R4LnJlc3RvcmUoKVxuXG5cbmNsYXNzIEdyYXBoaWMuVGV4dCBleHRlbmRzIEdyYXBoaWMuUGF0aFxuICByZW5kZXI6IChvcHRzKSAtPlxuICAgIGN0eCA9IG9wdHMuY3R4XG4gICAgY3R4LnNhdmUoKVxuICAgIEBzZXR1cFRleHQob3B0cylcbiAgICBAcmVuZGVyVGV4dChvcHRzKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgICBpZiBvcHRzLmhpZ2hsaWdodFxuICAgICAgQGJ1aWxkUGF0aChvcHRzKVxuICAgICAgQGhpZ2hsaWdodElmTmVjZXNzYXJ5KG9wdHMpXG5cbiAgdGV4dENvbXBvbmVudDogLT5cbiAgICBAY29tcG9uZW50T2ZUeXBlKEdyYXBoaWMuVGV4dENvbXBvbmVudClcblxuICByZW5kZXJUZXh0OiAoe2N0eH0pIC0+XG4gICAge3RleHR9ID0gQHRleHRDb21wb25lbnQoKVxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKVxuXG4gIHRleHRNdWx0aXBsaWVyOiAxMDBcblxuICAjIHNldHVwVGV4dCB3aWxsIHNldCB0aGUgYXBwcm9wcmlhdGUgZm9udCBzdHlsZXMsIGNvbG9yLCBhbmQgdHJhbnNmb3JtYXRpb25cbiAgIyBtYXRyaXggc28gdGhhdCB0ZXh0IGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkIChmaWxsVGV4dCkgYXQgMCwwLlxuICBzZXR1cFRleHQ6ICh7Y3R4LCB2aWV3TWF0cml4fSkgLT5cbiAgICB7dGV4dCwgZm9udEZhbWlseSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUsIGNvbG9yfSA9IEB0ZXh0Q29tcG9uZW50KClcbiAgICBtYXRyaXggPSB2aWV3TWF0cml4LmNvbXBvc2UoQG1hdHJpeClcbiAgICBtYXRyaXggPSBtYXRyaXguc2NhbGUoMSAvIEB0ZXh0TXVsdGlwbGllciwgLTEgLyBAdGV4dE11bHRpcGxpZXIpXG4gICAgbWF0cml4LmNhbnZhc1RyYW5zZm9ybShjdHgpXG4gICAgY3R4LmZvbnQgPSBcIiN7QHRleHRNdWx0aXBsaWVyfXB4ICN7Zm9udEZhbWlseX1cIlxuICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ25cbiAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lXG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cbiAgIyBUZXh0J3MgYnVpbGRQYXRoIGp1c3QgZHJhd3MgYSByZWN0YW5nbGUgYXJvdW5kIHRoZSB0ZXh0J3MgYm91bmRpbmdcbiAgIyByZWN0YW5nbGUuXG4gIGJ1aWxkUGF0aDogKG9wdHMpIC0+XG4gICAge2N0eCwgdmlld01hdHJpeH0gPSBvcHRzXG4gICAgY3R4LnNhdmUoKVxuICAgIEBzZXR1cFRleHQob3B0cylcblxuICAgIHt0ZXh0LCBmb250RmFtaWx5LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSwgY29sb3J9ID0gQHRleHRDb21wb25lbnQoKVxuXG4gICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGggLyBAdGV4dE11bHRpcGxpZXJcbiAgICBoZWlnaHQgPSAxXG4gICAgY3R4LnJlc3RvcmUoKVxuXG4gICAgIyBUT0RPOiBEZWFsIHByb3Blcmx5IHdpdGggbHRyL3J0bCB0ZXh0LlxuICAgIGlmIHRleHRBbGlnbiA9PSBcImxlZnRcIiBvciB0ZXh0QWxpZ24gPT0gXCJzdGFydFwiXG4gICAgICBtaW5YID0gMFxuICAgICAgbWF4WCA9IHdpZHRoXG4gICAgZWxzZSBpZiB0ZXh0QWxpZ24gPT0gXCJyaWdodFwiIG9yIHRleHRBbGlnbiA9PSBcImVuZFwiXG4gICAgICBtaW5YID0gLXdpZHRoXG4gICAgICBtYXhYID0gMFxuICAgIGVsc2UgaWYgdGV4dEFsaWduID09IFwiY2VudGVyXCJcbiAgICAgIG1pblggPSAtd2lkdGggLyAyXG4gICAgICBtYXhYID0gIHdpZHRoIC8gMlxuXG4gICAgIyBUT0RPOiBUaGlzIDAuMjUgaXMgaGFyZC1jb2RlZC4gSG93IGNhbiB0aGlzIGJhc2VsaW5lIHZhbHVlIGJlIGRldGVybWluZWRcbiAgICAjIHByb2dyYW1tYXRpY2FsbHkgYmFzZWQgb24gdGhlIGZvbnQ/XG4gICAgYmFzZWxpbmUgPSAwLjI1XG4gICAgaWYgdGV4dEJhc2VsaW5lID09IFwidG9wXCJcbiAgICAgIG1pblkgPSAtaGVpZ2h0IC0gYmFzZWxpbmVcbiAgICAgIG1heFkgPSAtYmFzZWxpbmVcbiAgICBlbHNlIGlmIHRleHRCYXNlbGluZSA9PSBcIm1pZGRsZVwiXG4gICAgICBtaW5ZID0gKC1oZWlnaHQgLSBiYXNlbGluZSkgLyAyXG4gICAgICBtYXhZID0gKCBoZWlnaHQgKyBiYXNlbGluZSkgLyAyXG4gICAgZWxzZSBpZiB0ZXh0QmFzZWxpbmUgPT0gXCJhbHBoYWJldGljXCJcbiAgICAgIG1pblkgPSAtYmFzZWxpbmVcbiAgICAgIG1heFkgPSBoZWlnaHQgLSBiYXNlbGluZVxuICAgIGVsc2UgaWYgdGV4dEJhc2VsaW5lID09IFwiYm90dG9tXCJcbiAgICAgIG1pblkgPSAwXG4gICAgICBtYXhZID0gaGVpZ2h0XG5cbiAgICAjIERyYXcgdGhlIHRleHQgYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgIGN0eC5zYXZlKClcbiAgICBtYXRyaXggPSB2aWV3TWF0cml4LmNvbXBvc2UoQG1hdHJpeClcbiAgICBtYXRyaXguY2FudmFzVHJhbnNmb3JtKGN0eClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgubW92ZVRvKG1pblgsIG1pblkpXG4gICAgY3R4LmxpbmVUbyhtaW5YLCBtYXhZKVxuICAgIGN0eC5saW5lVG8obWF4WCwgbWF4WSlcbiAgICBjdHgubGluZVRvKG1heFgsIG1pblkpXG4gICAgY3R4LmNsb3NlUGF0aCgpXG4gICAgY3R4LnJlc3RvcmUoKVxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgQ29tcG9uZW50c1xuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jbGFzcyBHcmFwaGljLkNvbXBvbmVudFxuXG5jbGFzcyBHcmFwaGljLlBhaW50T3AgZXh0ZW5kcyBHcmFwaGljLkNvbXBvbmVudFxuXG5jbGFzcyBHcmFwaGljLkZpbGwgZXh0ZW5kcyBHcmFwaGljLlBhaW50T3BcbiAgcGFpbnQ6IChjdHgpIC0+XG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC5maWxsU3R5bGUgPSBAY29sb3JcbiAgICBjdHguZmlsbCgpXG4gICAgY3R4LnJlc3RvcmUoKVxuXG5jbGFzcyBHcmFwaGljLlN0cm9rZSBleHRlbmRzIEdyYXBoaWMuUGFpbnRPcFxuICBwYWludDogKGN0eCkgLT5cbiAgICByZXR1cm4gaWYgQGxpbmVXaWR0aCA8PSAwXG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IEBjb2xvclxuICAgIGN0eC5saW5lV2lkdGggPSBAbGluZVdpZHRoXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LnJlc3RvcmUoKVxuXG5jbGFzcyBHcmFwaGljLlBhdGhDb21wb25lbnQgZXh0ZW5kcyBHcmFwaGljLkNvbXBvbmVudFxuXG5jbGFzcyBHcmFwaGljLlRleHRDb21wb25lbnQgZXh0ZW5kcyBHcmFwaGljLkNvbXBvbmVudFxuXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4jIER1bW15IENhbnZhc1xuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4jIFRoaXMgZHVtbXkgY2FudmFzIGlzIHVzZWQgdG8gcGVyZm9ybSBpc1BvaW50SW5QYXRoIGZvciBoaXQgZGV0ZWN0aW9uLlxuXG5kdW1teUNhbnZhc0N0eCA9IG51bGxcbmdldER1bW15Q2FudmFzQ3R4ID0gLT5cbiAgcmV0dXJuIGR1bW15Q2FudmFzQ3R4IGlmIGR1bW15Q2FudmFzQ3R4XG4gIGR1bW15Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICByZXR1cm4gZHVtbXlDYW52YXNDdHggPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5EYXRhZmxvdyA9IHJlcXVpcmUgXCIuLi9EYXRhZmxvdy9EYXRhZmxvd1wiXG5FdmFsdWF0b3IgPSByZXF1aXJlIFwiLi4vRXZhbHVhdG9yL0V2YWx1YXRvclwiXG5Ob2RlID0gcmVxdWlyZSBcIi4vTm9kZVwiXG5MaW5rID0gcmVxdWlyZSBcIi4vTGlua1wiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuL01vZGVsXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZSA9IE5vZGUuY3JlYXRlVmFyaWFudFxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICAjIENhbGwgXCJzdXBlclwiIGNvbnN0cnVjdG9yXG4gICAgTm9kZS5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cbiAgICBAdmFsdWUgPSBEYXRhZmxvdy5jZWxsKEBfdmFsdWUuYmluZCh0aGlzKSlcblxuICBfdmFsdWU6IC0+XG4gICAgIyBPcHRpbWl6YXRpb25cbiAgICBpZiBAaXNOdW1iZXIoKVxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoQGV4cHJTdHJpbmcpXG5cbiAgICBpZiBAX2lzRGlydHkoKVxuICAgICAgQF91cGRhdGVDb21waWxlZEV4cHJlc3Npb24oKVxuXG4gICAgcmVmZXJlbmNlVmFsdWVzID0gXy5tYXBPYmplY3QgQHJlZmVyZW5jZXMoKSwgKHJlZmVyZW5jZUF0dHJpYnV0ZSkgLT5cbiAgICAgIHJlZmVyZW5jZUF0dHJpYnV0ZS52YWx1ZSgpXG5cbiAgICB0cnlcbiAgICAgIHJldHVybiBAX19jb21waWxlZEV4cHJlc3Npb24uZXZhbHVhdGUocmVmZXJlbmNlVmFsdWVzKVxuICAgIGNhdGNoIGVycm9yXG4gICAgICBpZiBlcnJvciBpbnN0YW5jZW9mIERhdGFmbG93LlVucmVzb2x2ZWRTcHJlYWRFcnJvclxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZXJyb3JcblxuICBfaXNEaXJ0eTogLT5cbiAgICByZXR1cm4gdHJ1ZSBpZiAhQGhhc093blByb3BlcnR5KFwiX19jb21waWxlZEV4cHJlc3Npb25cIilcbiAgICByZXR1cm4gdHJ1ZSBpZiBAX19jb21waWxlZEV4cHJlc3Npb24uZXhwclN0cmluZyAhPSBAZXhwclN0cmluZ1xuICAgIHJldHVybiBmYWxzZVxuXG4gIF91cGRhdGVDb21waWxlZEV4cHJlc3Npb246IC0+XG4gICAgY29tcGlsZWRFeHByZXNzaW9uID0gbmV3IENvbXBpbGVkRXhwcmVzc2lvbih0aGlzKVxuICAgIGlmIGNvbXBpbGVkRXhwcmVzc2lvbi5pc1N5bnRheEVycm9yXG4gICAgICBjb21waWxlZEV4cHJlc3Npb24uZm4gPSBAX19jb21waWxlZEV4cHJlc3Npb24/LmZuID8gLT4gbmV3IEVycm9yKFwiU3ludGF4IGVycm9yXCIpXG4gICAgQF9fY29tcGlsZWRFeHByZXNzaW9uID0gY29tcGlsZWRFeHByZXNzaW9uXG5cbiAgc2V0RXhwcmVzc2lvbjogKGV4cHJTdHJpbmcsIHJlZmVyZW5jZXM9e30pIC0+XG4gICAgQGV4cHJTdHJpbmcgPSBTdHJpbmcoZXhwclN0cmluZylcblxuICAgICMgUmVtb3ZlIGFsbCBleGlzdGluZyByZWZlcmVuY2UgbGlua3NcbiAgICBmb3IgcmVmZXJlbmNlTGluayBpbiBAY2hpbGRyZW5PZlR5cGUoTW9kZWwuUmVmZXJlbmNlTGluaylcbiAgICAgIEByZW1vdmVDaGlsZChyZWZlcmVuY2VMaW5rKVxuXG4gICAgIyBDcmVhdGUgYXBwcm9wcmlhdGUgcmVmZXJlbmNlIGxpbmtzXG4gICAgZm9yIG93biBrZXksIGF0dHJpYnV0ZSBvZiByZWZlcmVuY2VzXG4gICAgICByZWZlcmVuY2VMaW5rID0gTW9kZWwuUmVmZXJlbmNlTGluay5jcmVhdGVWYXJpYW50KClcbiAgICAgIHJlZmVyZW5jZUxpbmsua2V5ID0ga2V5XG4gICAgICByZWZlcmVuY2VMaW5rLnNldFRhcmdldChhdHRyaWJ1dGUpXG4gICAgICBAYWRkQ2hpbGQocmVmZXJlbmNlTGluaylcblxuICByZWZlcmVuY2VzOiAtPlxuICAgIHJlZmVyZW5jZXMgPSB7fVxuICAgIGZvciByZWZlcmVuY2VMaW5rIGluIEBjaGlsZHJlbk9mVHlwZShNb2RlbC5SZWZlcmVuY2VMaW5rKVxuICAgICAga2V5ID0gcmVmZXJlbmNlTGluay5rZXlcbiAgICAgIGF0dHJpYnV0ZSA9IHJlZmVyZW5jZUxpbmsudGFyZ2V0KClcbiAgICAgIHJlZmVyZW5jZXNba2V5XSA9IGF0dHJpYnV0ZVxuICAgIHJldHVybiByZWZlcmVuY2VzXG5cbiAgaGFzUmVmZXJlbmNlczogLT4gXy5hbnkoQHJlZmVyZW5jZXMoKSwgLT4gdHJ1ZSlcblxuICBpc051bWJlcjogLT5cbiAgICByZXR1cm4gVXRpbC5pc051bWJlclN0cmluZyhAZXhwclN0cmluZylcblxuICBpc1RyaXZpYWw6IC0+XG4gICAgIyBUT0RPXG4gICAgcmV0dXJuIEBpc051bWJlcigpXG5cbiAgaXNOb3ZlbDogLT5cbiAgICBAaGFzT3duUHJvcGVydHkoXCJleHByU3RyaW5nXCIpXG5cbiAgIyBSZXR1cm5zIGFsbCByZWZlcmVuY2VkIGF0dHJpYnV0ZXMgcmVjdXJzaXZlbHkuIEluIG90aGVyIHdvcmRzIGV2ZXJ5XG4gICMgYXR0cmlidXRlIHdoaWNoLCBpZiBpdCBjaGFuZ2VkLCB3b3VsZCBhZmZlY3QgbWUuXG4gIGRlcGVuZGVuY2llczogLT5cbiAgICBkZXBlbmRlbmNpZXMgPSBbXVxuICAgIHJlY3Vyc2UgPSAoYXR0cmlidXRlKSAtPlxuICAgICAgZm9yIHJlZmVyZW5jZUF0dHJpYnV0ZSBpbiBfLnZhbHVlcyhhdHRyaWJ1dGUucmVmZXJlbmNlcygpKVxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChyZWZlcmVuY2VBdHRyaWJ1dGUpXG4gICAgICAgIHJlY3Vyc2UocmVmZXJlbmNlQXR0cmlidXRlKVxuICAgIHJlY3Vyc2UodGhpcylcbiAgICBkZXBlbmRlbmNpZXMgPSBfLnVuaXF1ZShkZXBlbmRlbmNpZXMpXG4gICAgcmV0dXJuIGRlcGVuZGVuY2llc1xuXG4gIHBhcmVudEVsZW1lbnQ6IC0+XG4gICAgcmVzdWx0ID0gQHBhcmVudCgpXG4gICAgdW50aWwgcmVzdWx0LmlzVmFyaWFudE9mKE1vZGVsLkVsZW1lbnQpXG4gICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50KClcbiAgICByZXR1cm4gcmVzdWx0XG5cblxuXG5cbmNsYXNzIENvbXBpbGVkRXhwcmVzc2lvblxuICBjb25zdHJ1Y3RvcjogKEBhdHRyaWJ1dGUpIC0+XG4gICAgQGV4cHJTdHJpbmcgPSBAYXR0cmlidXRlLmV4cHJTdHJpbmdcbiAgICBAcmVmZXJlbmNlS2V5cyA9IF8ua2V5cyhAYXR0cmlidXRlLnJlZmVyZW5jZXMoKSlcblxuICAgIGlmIEBleHByU3RyaW5nID09IFwiXCJcbiAgICAgIEBfc2V0U3ludGF4RXJyb3IoKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiBVdGlsLmlzTnVtYmVyU3RyaW5nKEBleHByU3RyaW5nKVxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KEBleHByU3RyaW5nKVxuICAgICAgQF9zZXRDb25zdGFudCh2YWx1ZSlcbiAgICAgIHJldHVyblxuXG4gICAgd3JhcHBlZCA9IEBfd3JhcHBlZCgpXG4gICAgdHJ5XG4gICAgICBjb21waWxlZCA9IEV2YWx1YXRvci5ldmFsdWF0ZSh3cmFwcGVkKVxuICAgIGNhdGNoIGVycm9yXG4gICAgICBAX3NldFN5bnRheEVycm9yKClcbiAgICAgIHJldHVyblxuXG4gICAgY29tcGlsZWQgPSBAX3dyYXBGdW5jdGlvbkluU3ByZWFkQ2hlY2soY29tcGlsZWQpXG5cbiAgICBpZiBAcmVmZXJlbmNlS2V5cy5sZW5ndGggPT0gMFxuICAgICAgdHJ5XG4gICAgICAgIHZhbHVlID0gY29tcGlsZWQoKVxuICAgICAgY2F0Y2ggZXJyb3JcbiAgICAgICAgQF9zZXRDb25zdGFudChlcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICBAX3NldENvbnN0YW50KHZhbHVlKVxuICAgICAgcmV0dXJuXG5cbiAgICBAX3NldEZuKGNvbXBpbGVkKVxuXG4gIF9zZXRTeW50YXhFcnJvcjogLT5cbiAgICBAaXNTeW50YXhFcnJvciA9IHRydWVcblxuICBfc2V0Q29uc3RhbnQ6ICh2YWx1ZSkgLT5cbiAgICBAaXNDb25zdGFudCA9IHRydWVcbiAgICBAZm4gPSAtPiB2YWx1ZVxuXG4gIF9zZXRGbjogKGZuKSAtPlxuICAgIEBmbiA9IGZuXG5cbiAgZXZhbHVhdGU6IChyZWZlcmVuY2VWYWx1ZXMpIC0+XG4gICAgcmV0dXJuIEBmbihyZWZlcmVuY2VWYWx1ZXMpXG5cbiAgX3dyYXBwZWQ6IC0+XG4gICAgcmVzdWx0ICAgID0gXCIndXNlIHN0cmljdCc7XFxuXCJcbiAgICByZXN1bHQgICArPSBcIihmdW5jdGlvbiAoJCQkcmVmZXJlbmNlVmFsdWVzKSB7XFxuXCJcblxuICAgIGZvciByZWZlcmVuY2VLZXkgaW4gQHJlZmVyZW5jZUtleXNcbiAgICAgIHJlc3VsdCArPSBcIiAgdmFyICN7cmVmZXJlbmNlS2V5fSA9ICQkJHJlZmVyZW5jZVZhbHVlcy4je3JlZmVyZW5jZUtleX07XFxuXCJcblxuICAgIGlmIEBleHByU3RyaW5nLmluZGV4T2YoXCJyZXR1cm5cIikgPT0gLTFcbiAgICAgIHJlc3VsdCArPSBcIiAgcmV0dXJuICN7QGV4cHJTdHJpbmd9O1xcblwiXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuI3tAZXhwclN0cmluZ31cXG5cXG5cIlxuXG4gICAgcmVzdWx0ICAgKz0gXCJ9KTtcIlxuICAgIHJldHVybiByZXN1bHRcblxuICBfd3JhcEZ1bmN0aW9uSW5TcHJlYWRDaGVjazogKGZuKSAtPlxuICAgIHJldHVybiA9PlxuICAgICAgcmVzdWx0ID0gZm4oYXJndW1lbnRzLi4uKVxuICAgICAgaWYgcmVzdWx0IGluc3RhbmNlb2YgRGF0YWZsb3cuU3ByZWFkXG4gICAgICAgIHJlc3VsdC5vcmlnaW4gPSBAYXR0cmlidXRlXG4gICAgICByZXR1cm4gcmVzdWx0XG5cblxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbnF1ZXJ5U3RyaW5nID0gcmVxdWlyZSBcInF1ZXJ5LXN0cmluZ1wiXG5EYXRhZmxvdyA9IHJlcXVpcmUgXCIuLi9EYXRhZmxvdy9EYXRhZmxvd1wiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuL01vZGVsXCJcblV0aWwgPSByZXF1aXJlIFwiLi4vVXRpbC9VdGlsXCJcblN0b3JhZ2UgPSByZXF1aXJlIFwiLi4vU3RvcmFnZS9TdG9yYWdlXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEVkaXRvclxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAX3NldHVwU2VyaWFsaXplcigpXG4gICAgQF9zZXR1cFByb2plY3QoKVxuICAgIEBfc2V0dXBSZXZpc2lvbigpXG4gICAgQF9wYXJzZVF1ZXJ5U3RyaW5nKClcblxuICBfc2V0dXBQcm9qZWN0OiAtPlxuICAgIEBsb2FkRnJvbUxvY2FsU3RvcmFnZSgpXG4gICAgaWYgIUBwcm9qZWN0XG4gICAgICBAY3JlYXRlTmV3UHJvamVjdCgpXG5cbiAgX3NldHVwU2VyaWFsaXplcjogLT5cbiAgICBidWlsdEluT2JqZWN0cyA9IFtdXG4gICAgZm9yIG93biBuYW1lLCBvYmplY3Qgb2YgQF9idWlsdEluKClcbiAgICAgIGlmIF8uaXNGdW5jdGlvbihvYmplY3QpXG4gICAgICAgIG9iamVjdCA9IG9iamVjdC5wcm90b3R5cGVcbiAgICAgIFV0aWwuYXNzaWduSWQob2JqZWN0LCBuYW1lKVxuICAgICAgYnVpbHRJbk9iamVjdHMucHVzaChvYmplY3QpXG4gICAgQHNlcmlhbGl6ZXIgPSBuZXcgU3RvcmFnZS5TZXJpYWxpemVyKGJ1aWx0SW5PYmplY3RzKVxuXG4gICMgQ2hlY2tzIGlmIHdlIHNob3VsZCBsb2FkIGFuIGV4dGVybmFsIEpTT04gZmlsZSBiYXNlZCBvbiB0aGUgcXVlcnkgc3RyaW5nXG4gICMgKHRoZSA/c3R1ZmYgYXQgdGhlIGVuZCBvZiB0aGUgVVJMKS5cbiAgX3BhcnNlUXVlcnlTdHJpbmc6IC0+XG4gICAgcGFyc2VkID0gcXVlcnlTdHJpbmcucGFyc2UobG9jYXRpb24uc2VhcmNoKVxuICAgIGlmIHBhcnNlZC5sb2FkXG4gICAgICBAbG9hZEZyb21VUkwocGFyc2VkLmxvYWQpXG5cbiAgIyBidWlsdEluIHJldHVybnMgYWxsIG9mIHRoZSBidWlsdCBpbiBjbGFzc2VzIGFuZCBvYmplY3RzIHRoYXQgYXJlIHVzZWQgYXNcbiAgIyB0aGUgXCJhbmNob3JzXCIgZm9yIHNlcmlhbGl6YXRpb24gYW5kIGRlc2VyaWFsaXphdGlvbi4gVGhhdCBpcywgYWxsIG9mIHRoZVxuICAjIG9iamVjdHMgYW5kIGNsYXNzZXMgd2hpY2ggc2hvdWxkIG5vdCB0aGVtc2VsdmVzIGJlIHNlcmlhbGl6ZWQgYnV0IGluc3RlYWRcbiAgIyBiZSAqcmVmZXJlbmNlZCogZnJvbSBhIHNlcmlhbGl6YXRpb24uIFdoZW4gZGVzZXJpYWxpemVkLCB0aGVzZSByZWZlcmVuY2VzXG4gICMgYXJlIHRoZW4gYm91bmQgYXBwcm9wcmlhdGVseS5cbiAgX2J1aWx0SW46IC0+XG4gICAgYnVpbHRJbiA9IF8uY2xvbmUoTW9kZWwpXG4gICAgYnVpbHRJbltcIlNwcmVhZEVudlwiXSA9IERhdGFmbG93LlNwcmVhZEVudlxuICAgIGJ1aWx0SW5bXCJNYXRyaXhcIl0gPSBVdGlsLk1hdHJpeFxuICAgIHJldHVybiBidWlsdEluXG5cbiAgIyBUT0RPOiBnZXQgdmVyc2lvbiB2aWEgYnVpbGQgcHJvY2VzcyAvIEVOViB2YXJpYWJsZT9cbiAgdmVyc2lvbjogXCIwLjQuMFwiXG5cbiAgbG9hZDogKGpzb25TdHJpbmcpIC0+XG4gICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZylcbiAgICBpZiBqc29uLnR5cGUgPT0gXCJBcHBhcmF0dXNcIiBhbmQganNvbi52ZXJzaW9uID09IEB2ZXJzaW9uXG4gICAgICBAcHJvamVjdCA9IEBzZXJpYWxpemVyLmRlanNvbmlmeShqc29uKVxuXG4gIHNhdmU6IC0+XG4gICAganNvbiA9IEBzZXJpYWxpemVyLmpzb25pZnkoQHByb2plY3QpXG4gICAganNvbi50eXBlID0gXCJBcHBhcmF0dXNcIlxuICAgIGpzb24udmVyc2lvbiA9IEB2ZXJzaW9uXG4gICAganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgcmV0dXJuIGpzb25TdHJpbmdcblxuICBjcmVhdGVOZXdQcm9qZWN0OiAtPlxuICAgIEBwcm9qZWN0ID0gbmV3IE1vZGVsLlByb2plY3QoKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBMb2NhbCBTdG9yYWdlXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgbG9jYWxTdG9yYWdlTmFtZTogXCJhcHBhcmF0dXNcIlxuXG4gIHNhdmVUb0xvY2FsU3RvcmFnZTogLT5cbiAgICBqc29uU3RyaW5nID0gQHNhdmUoKVxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbQGxvY2FsU3RvcmFnZU5hbWVdID0ganNvblN0cmluZ1xuICAgIHJldHVybiBqc29uU3RyaW5nXG5cbiAgbG9hZEZyb21Mb2NhbFN0b3JhZ2U6IC0+XG4gICAganNvblN0cmluZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbQGxvY2FsU3RvcmFnZU5hbWVdXG4gICAgaWYganNvblN0cmluZ1xuICAgICAgQGxvYWQoanNvblN0cmluZylcblxuICByZXNldExvY2FsU3RvcmFnZTogLT5cbiAgICBkZWxldGUgd2luZG93LmxvY2FsU3RvcmFnZVtAbG9jYWxTdG9yYWdlTmFtZV1cblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgRmlsZSBTeXN0ZW1cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBzYXZlVG9GaWxlOiAtPlxuICAgIGpzb25TdHJpbmcgPSBAc2F2ZSgpXG4gICAgZmlsZU5hbWUgPSBAcHJvamVjdC5lZGl0aW5nRWxlbWVudC5sYWJlbCArIFwiLmpzb25cIlxuICAgIFN0b3JhZ2Uuc2F2ZUZpbGUoanNvblN0cmluZywgZmlsZU5hbWUsIFwiYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04XCIpXG5cbiAgbG9hZEZyb21GaWxlOiAtPlxuICAgIFN0b3JhZ2UubG9hZEZpbGUgKGpzb25TdHJpbmcpID0+XG4gICAgICBAbG9hZChqc29uU3RyaW5nKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBFeHRlcm5hbCBVUkxcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAjIFRPRE86IERlYWwgd2l0aCBlcnJvciBjb25kaXRpb25zLCB0aW1lb3V0LCBldGMuXG4gICMgVE9ETzogTWF5YmUgbW92ZSB4aHIgc3R1ZmYgdG8gVXRpbC5cbiAgIyBUT0RPOiBTaG93IHNvbWUgc29ydCBvZiBsb2FkaW5nIGluZGljYXRvci5cbiAgbG9hZEZyb21VUkw6ICh1cmwpIC0+XG4gICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gPT5cbiAgICAgIHJldHVybiB1bmxlc3MgeGhyLnJlYWR5U3RhdGUgPT0gNFxuICAgICAgcmV0dXJuIHVubGVzcyB4aHIuc3RhdHVzID09IDIwMFxuICAgICAganNvblN0cmluZyA9IHhoci5yZXNwb25zZVRleHRcbiAgICAgIEBsb2FkKGpzb25TdHJpbmcpXG4gICAgICBAY2hlY2twb2ludCgpXG4gICAgICBBcHBhcmF0dXMucmVmcmVzaCgpICMgSEFDSzogY2FsbGluZyBBcHBhcmF0dXMgc2VlbXMgZnVua3kgaGVyZS5cbiAgICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpXG4gICAgeGhyLnNlbmQoKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBSZXZpc2lvbiBIaXN0b3J5XG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3NldHVwUmV2aXNpb246IC0+XG4gICAgIyBAY3VycmVudCBpcyBhIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS4gQHVuZG9TdGFjayBhbmRcbiAgICAjIEByZWRvU3RhY2sgYXJlIGFycmF5cyBvZiBzdWNoIEpTT04gc3RyaW5ncy5cbiAgICBAY3VycmVudCA9IEBzYXZlKClcbiAgICBAdW5kb1N0YWNrID0gW11cbiAgICBAcmVkb1N0YWNrID0gW11cbiAgICBAbWF4VW5kb1N0YWNrU2l6ZSA9IDEwMFxuXG4gIGNoZWNrcG9pbnQ6IC0+XG4gICAganNvblN0cmluZyA9IEBzYXZlVG9Mb2NhbFN0b3JhZ2UoKVxuICAgIHJldHVybiBpZiBAY3VycmVudCA9PSBqc29uU3RyaW5nXG4gICAgQHVuZG9TdGFjay5wdXNoKEBjdXJyZW50KVxuICAgIGlmIEB1bmRvU3RhY2subGVuZ3RoID4gQG1heFVuZG9TdGFja1NpemVcbiAgICAgIEB1bmRvU3RhY2suc2hpZnQoKVxuICAgIEByZWRvU3RhY2sgPSBbXVxuICAgIEBjdXJyZW50ID0ganNvblN0cmluZ1xuXG4gIHVuZG86IC0+XG4gICAgcmV0dXJuIHVubGVzcyBAaXNVbmRvYWJsZSgpXG4gICAgQHJlZG9TdGFjay5wdXNoKEBjdXJyZW50KVxuICAgIEBjdXJyZW50ID0gQHVuZG9TdGFjay5wb3AoKVxuICAgIEBsb2FkKEBjdXJyZW50KVxuICAgIEBzYXZlVG9Mb2NhbFN0b3JhZ2UoKVxuXG4gIHJlZG86IC0+XG4gICAgcmV0dXJuIHVubGVzcyBAaXNSZWRvYWJsZSgpXG4gICAgQHVuZG9TdGFjay5wdXNoKEBjdXJyZW50KVxuICAgIEBjdXJyZW50ID0gQHJlZG9TdGFjay5wb3AoKVxuICAgIEBsb2FkKEBjdXJyZW50KVxuICAgIEBzYXZlVG9Mb2NhbFN0b3JhZ2UoKVxuXG4gIGlzVW5kb2FibGU6IC0+XG4gICAgcmV0dXJuIEB1bmRvU3RhY2subGVuZ3RoID4gMFxuXG4gIGlzUmVkb2FibGU6IC0+XG4gICAgcmV0dXJuIEByZWRvU3RhY2subGVuZ3RoID4gMFxuXG5cblxuXG5cblxuXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuTm9kZSA9IHJlcXVpcmUgXCIuL05vZGVcIlxuTGluayA9IHJlcXVpcmUgXCIuL0xpbmtcIlxuTW9kZWwgPSByZXF1aXJlIFwiLi9Nb2RlbFwiXG5EYXRhZmxvdyA9IHJlcXVpcmUgXCIuLi9EYXRhZmxvdy9EYXRhZmxvd1wiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50ID0gTm9kZS5jcmVhdGVWYXJpYW50XG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgICMgQ2FsbCBcInN1cGVyXCIgY29uc3RydWN0b3JcbiAgICBOb2RlLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblxuICAgICMgQmVjYXVzZSB0aGUgZXhwYW5kZWQgcHJvcGVybHkgaXMgbm90IGluaGVyaXRlZCwgaXQgaXMgaW5pdGlhbGl6ZWQgaW5cbiAgICAjIHRoZSBjb25zdHJ1Y3RvciBmb3IgZXZlcnkgRWxlbWVudC5cbiAgICBAZXhwYW5kZWQgPSBmYWxzZVxuXG4gICAgIyBUaGVzZSBtZXRob2RzIG5lZWQgdG8gYmUgY2VsbHMgYmVjYXVzZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gY2FsbCB0aGVpclxuICAgICMgYXNTcHJlYWQgdmVyc2lvbi4gTm90ZSB0aGF0IHdlIG5lZWQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgbWV0aG9kIGFyb3VuZFxuICAgICMgKGFzIHRoZSBfdmVyc2lvbikgc28gdGhhdCBpbmhlcml0YW5jZSBkb2Vzbid0IHRyeSB0byBtYWtlIGEgY2VsbCBvdXQgb2ZcbiAgICAjIGEgY2VsbC5cbiAgICBwcm9wc1RvQ2VsbGlmeSA9IFtcbiAgICAgIFwiZ3JhcGhpY1wiXG4gICAgICBcImNvbnRleHRNYXRyaXhcIlxuICAgICAgXCJhY2N1bXVsYXRlZE1hdHJpeFwiXG4gICAgXVxuICAgIGZvciBwcm9wIGluIHByb3BzVG9DZWxsaWZ5XG4gICAgICB0aGlzW3Byb3BdID0gRGF0YWZsb3cuY2VsbCh0aGlzW1wiX1wiICsgcHJvcF0uYmluZCh0aGlzKSlcblxuICAjIHZpZXdNYXRyaXggZGV0ZXJtaW5lcyB0aGUgcGFuIGFuZCB6b29tIG9mIGFuIEVsZW1lbnQuIEl0IGlzIG9ubHkgdXNlZCBmb3JcbiAgIyBFbGVtZW50cyB0aGF0IGNhbiBiZSBhIFByb2plY3QuZWRpdGluZ0VsZW1lbnQgKGkuZS4gRWxlbWVudHMgd2l0aGluIHRoZVxuICAjIGNyZWF0ZSBwYW5lbCkuIFRoZSBkZWZhdWx0IGlzIHpvb21lZCB0byAxMDAgcGl4ZWxzIHBlciB1bml0LlxuICB2aWV3TWF0cml4OiBuZXcgVXRpbC5NYXRyaXgoMTAwLCAwLCAwLCAxMDAsIDAsIDApXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIEdldHRlcnNcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBjaGlsZEVsZW1lbnRzOiAtPiBAY2hpbGRyZW5PZlR5cGUoRWxlbWVudClcblxuICB2YXJpYWJsZXM6IC0+IEBjaGlsZHJlbk9mVHlwZShNb2RlbC5WYXJpYWJsZSlcblxuICBjb21wb25lbnRzOiAtPiBAY2hpbGRyZW5PZlR5cGUoTW9kZWwuQ29tcG9uZW50KVxuXG4gIGF0dHJpYnV0ZXM6IC0+XG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IgdmFyaWFibGUgaW4gQHZhcmlhYmxlcygpXG4gICAgICByZXN1bHQucHVzaCh2YXJpYWJsZSlcbiAgICBmb3IgY29tcG9uZW50IGluIEBjb21wb25lbnRzKClcbiAgICAgIGZvciBhdHRyaWJ1dGUgaW4gY29tcG9uZW50LmF0dHJpYnV0ZXMoKVxuICAgICAgICByZXN1bHQucHVzaChhdHRyaWJ1dGUpXG4gICAgcmV0dXJuIHJlc3VsdFxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBBY3Rpb25zXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgYWRkVmFyaWFibGU6IC0+XG4gICAgdmFyaWFibGUgPSBNb2RlbC5WYXJpYWJsZS5jcmVhdGVWYXJpYW50KClcbiAgICB2YXJpYWJsZS5zZXRFeHByZXNzaW9uKFwiMC4wMFwiKVxuICAgIEBhZGRDaGlsZCh2YXJpYWJsZSlcbiAgICByZXR1cm4gdmFyaWFibGVcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgQ29udHJvbGxlZCBBdHRyaWJ1dGVzXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29udHJvbGxlZEF0dHJpYnV0ZXM6IC0+XG4gICAgY29udHJvbGxlZEF0dHJpYnV0ZXMgPSBbXVxuICAgIGZvciBjb250cm9sbGVkQXR0cmlidXRlTGluayBpbiBAY2hpbGRyZW5PZlR5cGUoTW9kZWwuQ29udHJvbGxlZEF0dHJpYnV0ZUxpbmspXG4gICAgICBhdHRyaWJ1dGUgPSBjb250cm9sbGVkQXR0cmlidXRlTGluay50YXJnZXQoKVxuICAgICAgY29udHJvbGxlZEF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpXG4gICAgcmV0dXJuIGNvbnRyb2xsZWRBdHRyaWJ1dGVzXG5cbiAgYWRkQ29udHJvbGxlZEF0dHJpYnV0ZTogKGF0dHJpYnV0ZVRvQWRkKSAtPlxuICAgIGNvbnRyb2xsZWRBdHRyaWJ1dGVMaW5rID0gTW9kZWwuQ29udHJvbGxlZEF0dHJpYnV0ZUxpbmsuY3JlYXRlVmFyaWFudCgpXG4gICAgY29udHJvbGxlZEF0dHJpYnV0ZUxpbmsuc2V0VGFyZ2V0KGF0dHJpYnV0ZVRvQWRkKVxuICAgIEBhZGRDaGlsZChjb250cm9sbGVkQXR0cmlidXRlTGluaylcblxuICByZW1vdmVDb250cm9sbGVkQXR0cmlidXRlOiAoYXR0cmlidXRlVG9SZW1vdmUpIC0+XG4gICAgZm9yIGNvbnRyb2xsZWRBdHRyaWJ1dGVMaW5rIGluIEBjaGlsZHJlbk9mVHlwZShNb2RlbC5Db250cm9sbGVkQXR0cmlidXRlTGluaylcbiAgICAgIGF0dHJpYnV0ZSA9IGNvbnRyb2xsZWRBdHRyaWJ1dGVMaW5rLnRhcmdldCgpXG4gICAgICBpZiBhdHRyaWJ1dGUgPT0gYXR0cmlidXRlVG9SZW1vdmVcbiAgICAgICAgQHJlbW92ZUNoaWxkKGNvbnRyb2xsZWRBdHRyaWJ1dGVMaW5rKVxuXG4gIGlzQ29udHJvbGxlcjogLT5cbiAgICByZXR1cm4gQGNvbnRyb2xsZWRBdHRyaWJ1dGVzKCkubGVuZ3RoID4gMFxuXG4gICMgQW4gaW1wbGljaXRseSBjb250cm9sbGVkIGF0dHJpYnV0ZSBpcyBhIGNvbnRyb2xsZWQgYXR0cmlidXRlIG9yIGFcbiAgIyBkZXBlbmRlbmN5IG9mIGEgY29udHJvbGxlZCBhdHRyaWJ1dGUuXG4gIGltcGxpY2l0bHlDb250cm9sbGVkQXR0cmlidXRlczogLT5cbiAgICByZXR1cm4gQGFsbERlcGVuZGVuY2llcyhAY29udHJvbGxlZEF0dHJpYnV0ZXMoKSlcblxuICAjIEEgY29udHJvbGxhYmxlIGF0dHJpYnV0ZSBpcyBvbmUgd2hpY2gsIGlmIGNoYW5nZWQsIHdvdWxkIGFmZmVjdCBteVxuICAjIGdlb21ldHJ5LiBUaHVzIGFsbCBhdHRyaWJ1dGVzIHdpdGhpbiBUcmFuc2Zvcm0gY29tcG9uZW50cywgdGhlaXJcbiAgIyBkZXBlbmRlbmNpZXMsIGFzIHdlbGwgYXMgYWxsIGNvbnRyb2xsYWJsZSBhdHRyaWJ1dGVzIHVwIG15IHBhcmVudCBjaGFpbi5cbiAgY29udHJvbGxhYmxlQXR0cmlidXRlczogLT5cbiAgICBfLnVuaXF1ZShAX2NvbnRyb2xsYWJsZUF0dHJpYnV0ZXMoKSlcbiAgX2NvbnRyb2xsYWJsZUF0dHJpYnV0ZXM6IC0+XG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IgY29tcG9uZW50IGluIEBjb21wb25lbnRzKClcbiAgICAgIGNvbnRpbnVlIHVubGVzcyBjb21wb25lbnQuY29udHJvbGxhYmxlQXR0cmlidXRlcz9cbiAgICAgIGZvciBhdHRyaWJ1dGUgaW4gY29tcG9uZW50LmNvbnRyb2xsYWJsZUF0dHJpYnV0ZXMoKVxuICAgICAgICByZXN1bHQucHVzaChhdHRyaWJ1dGUpXG4gICAgICAgIHJlc3VsdC5wdXNoKGF0dHJpYnV0ZS5kZXBlbmRlbmNpZXMoKS4uLilcbiAgICBpZiBAcGFyZW50KClcbiAgICAgIHJlc3VsdC5wdXNoKEBwYXJlbnQoKS5fY29udHJvbGxhYmxlQXR0cmlidXRlcygpLi4uKVxuICAgIHJldHVybiByZXN1bHRcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgQXR0cmlidXRlcyB0byBjaGFuZ2VcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBhdHRyaWJ1dGVzVG9DaGFuZ2U6IC0+XG4gICAgYXR0cmlidXRlc1RvQ2hhbmdlID0gQGltcGxpY2l0bHlDb250cm9sbGVkQXR0cmlidXRlcygpXG4gICAgaWYgYXR0cmlidXRlc1RvQ2hhbmdlLmxlbmd0aCA9PSAwXG4gICAgICBhdHRyaWJ1dGVzVG9DaGFuZ2UgPSBAZGVmYXVsdEF0dHJpYnV0ZXNUb0NoYW5nZSgpXG4gICAgYXR0cmlidXRlc1RvQ2hhbmdlID0gQG9ubHlOdW1iZXJzKGF0dHJpYnV0ZXNUb0NoYW5nZSlcbiAgICByZXR1cm4gYXR0cmlidXRlc1RvQ2hhbmdlXG5cbiAgZGVmYXVsdEF0dHJpYnV0ZXNUb0NoYW5nZTogLT5cbiAgICByZXN1bHQgPSBbXVxuICAgIGZvciBjb21wb25lbnQgaW4gQGNvbXBvbmVudHMoKVxuICAgICAgY29udGludWUgdW5sZXNzIGNvbXBvbmVudC5kZWZhdWx0QXR0cmlidXRlc1RvQ2hhbmdlP1xuICAgICAgcmVzdWx0LnB1c2goY29tcG9uZW50LmRlZmF1bHRBdHRyaWJ1dGVzVG9DaGFuZ2UoKS4uLilcbiAgICByZXR1cm4gcmVzdWx0XG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIENvbnRyb2wgUG9pbnRzXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29udHJvbFBvaW50czogLT5cbiAgICByZXN1bHQgPSBbXVxuICAgIGZvciBjb21wb25lbnQgaW4gQGNvbXBvbmVudHMoKVxuICAgICAgY29udGludWUgdW5sZXNzIGNvbXBvbmVudC5jb250cm9sUG9pbnRzP1xuICAgICAgY29udHJvbFBvaW50cyA9IGNvbXBvbmVudC5jb250cm9sUG9pbnRzKClcbiAgICAgIGZvciBjb250cm9sUG9pbnQgaW4gY29udHJvbFBvaW50c1xuICAgICAgICBhdHRyaWJ1dGVzVG9DaGFuZ2UgPSBjb250cm9sUG9pbnQuYXR0cmlidXRlc1RvQ2hhbmdlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NoYW5nZSA9IEBhbGxEZXBlbmRlbmNpZXMoYXR0cmlidXRlc1RvQ2hhbmdlKVxuICAgICAgICBhdHRyaWJ1dGVzVG9DaGFuZ2UgPSBAb25seU51bWJlcnMoYXR0cmlidXRlc1RvQ2hhbmdlKVxuICAgICAgICBjb250cm9sUG9pbnQuYXR0cmlidXRlc1RvQ2hhbmdlID0gYXR0cmlidXRlc1RvQ2hhbmdlXG4gICAgICByZXN1bHQucHVzaChjb250cm9sUG9pbnRzLi4uKVxuICAgIHJldHVybiByZXN1bHRcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgQXR0cmlidXRlIExpc3QgSGVscGVyc1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGFsbERlcGVuZGVuY2llczogKGF0dHJpYnV0ZXMpIC0+XG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXNcbiAgICAgIHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSlcbiAgICAgIHJlc3VsdC5wdXNoKGF0dHJpYnV0ZS5kZXBlbmRlbmNpZXMoKS4uLilcbiAgICByZXR1cm4gXy51bmlxdWUocmVzdWx0KVxuXG4gIG9ubHlOdW1iZXJzOiAoYXR0cmlidXRlcykgLT5cbiAgICBfLmZpbHRlciBhdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSAtPlxuICAgICAgYXR0cmlidXRlLmlzTnVtYmVyKClcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgR2VvbWV0cnlcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBtYXRyaXg6IC0+XG4gICAgbWF0cml4ID0gbmV3IFV0aWwuTWF0cml4KClcbiAgICBmb3IgdHJhbnNmb3JtIGluIEBjaGlsZHJlbk9mVHlwZShNb2RlbC5UcmFuc2Zvcm0pXG4gICAgICBtYXRyaXggPSBtYXRyaXguY29tcG9zZSh0cmFuc2Zvcm0ubWF0cml4KCkpXG4gICAgcmV0dXJuIG1hdHJpeFxuXG4gIF9jb250ZXh0TWF0cml4OiAtPlxuICAgIHBhcmVudCA9IEBwYXJlbnQoKVxuICAgIGlmIHBhcmVudCBhbmQgcGFyZW50LmlzVmFyaWFudE9mKEVsZW1lbnQpXG4gICAgICByZXR1cm4gcGFyZW50LmFjY3VtdWxhdGVkTWF0cml4KClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IFV0aWwuTWF0cml4KClcblxuICBfYWNjdW11bGF0ZWRNYXRyaXg6IC0+XG4gICAgcmV0dXJuIEBjb250ZXh0TWF0cml4KCkuY29tcG9zZShAbWF0cml4KCkpXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIEdyYXBoaWNcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBfZ3JhcGhpYzogLT5cbiAgICBncmFwaGljID0gbmV3IEBncmFwaGljQ2xhc3MoKVxuXG4gICAgc3ByZWFkRW52ID0gRGF0YWZsb3cuY3VycmVudFNwcmVhZEVudigpXG4gICAgZ3JhcGhpYy5wYXJ0aWN1bGFyRWxlbWVudCA9IG5ldyBNb2RlbC5QYXJ0aWN1bGFyRWxlbWVudCh0aGlzLCBzcHJlYWRFbnYpXG5cbiAgICBncmFwaGljLm1hdHJpeCA9IEBhY2N1bXVsYXRlZE1hdHJpeCgpXG5cbiAgICBncmFwaGljLmNvbXBvbmVudHMgPSBfLm1hcCBAY29tcG9uZW50cygpLCAoY29tcG9uZW50KSAtPlxuICAgICAgY29tcG9uZW50LmdyYXBoaWMoKVxuXG4gICAgZ3JhcGhpYy5jaGlsZEdyYXBoaWNzID0gXy5mbGF0dGVuKF8ubWFwKEBjaGlsZEVsZW1lbnRzKCksIChlbGVtZW50KSAtPlxuICAgICAgZWxlbWVudC5hbGxHcmFwaGljcygpXG4gICAgKSlcblxuICAgIHJldHVybiBncmFwaGljXG5cbiAgYWxsR3JhcGhpY3M6IC0+XG4gICAgcmV0dXJuIFtdIGlmIEBfaXNCZXlvbmRNYXhEZXB0aCgpXG4gICAgcmVzdWx0ID0gQGdyYXBoaWMuYXNTcHJlYWQoKVxuICAgIGlmIHJlc3VsdCBpbnN0YW5jZW9mIERhdGFmbG93LlNwcmVhZFxuICAgICAgcmV0dXJuIHJlc3VsdC5mbGF0dGVuVG9BcnJheSgpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFtyZXN1bHRdXG5cbiAgX2lzQmV5b25kTWF4RGVwdGg6IC0+XG4gICAgIyBUaGlzIG1pZ2h0IHdhbnQgdG8gYmUgYWRqdXN0YWJsZSBzb21ld2hlcmUgcmF0aGVyIHRoYW4gaGFyZCBjb2RlZCBoZXJlLlxuICAgIHJldHVybiBAZGVwdGgoKSA+IDIwXG4iLCJOb2RlID0gcmVxdWlyZSBcIi4vTm9kZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gTGluayA9IE5vZGUuY3JlYXRlVmFyaWFudCB7XG4gIHNldFRhcmdldDogKEBfdGFyZ2V0KSAtPlxuXG4gIHRhcmdldDogLT5cbiAgICAjIEZpcnN0LCB0cmFjZSBiYWNrd2FyZHMgZnJvbSBtZSB0byB0aGUgbGluayB3aGljaCBvcmlnaW5hbGx5IGVzdGFibGlzaGVkXG4gICAgIyB0aGUgdGFyZ2V0LiBLZWVwIHRyYWNrIG9mIHRoZSBoZWFkcyBvZiBlYWNoIG9mIHRoZSBub2RlcyBhbG9uZyB0aGUgd2F5LlxuICAgIGhlYWRTdGFjayA9IFtdXG4gICAgY3Vyc29yID0gdGhpc1xuICAgIHdoaWxlICFjdXJzb3IuaGFzT3duUHJvcGVydHkoXCJfdGFyZ2V0XCIpXG4gICAgICBoZWFkU3RhY2sudW5zaGlmdChjdXJzb3IuaGVhZCgpKVxuICAgICAgY3Vyc29yID0gY3Vyc29yLm1hc3RlcigpXG5cbiAgICAjIE5vdywgdHJhY2UgZm9yd2FyZHMgZnJvbSB0aGUgb3JpZ2luYWwgdGFyZ2V0IHRvIHRoZSB0YXJnZXQgd2l0aGluIG15XG4gICAgIyB2YXJpYXRpb24uXG4gICAgY3Vyc29yID0gQF90YXJnZXRcbiAgICBmb3IgaGVhZCBpbiBoZWFkU3RhY2tcbiAgICAgIG5leHRDdXJzb3IgPSBjdXJzb3IuZmluZFZhcmlhbnRXaXRoSGVhZChoZWFkKVxuXG4gICAgICAjIFdoYXQgZG9lcyBpdCBtZWFuIGlmIG5leHRDdXJzb3IgaXMgbm90IGZvdW5kPyBUT0RPOiB0aGluayBhYm91dCB0aGlzXG4gICAgICAjIHBvc3NpYmlsaXR5LlxuICAgICAgYnJlYWsgdW5sZXNzIG5leHRDdXJzb3I/XG5cbiAgICAgIGN1cnNvciA9IG5leHRDdXJzb3JcblxuICAgIHJldHVybiBjdXJzb3Jcbn1cbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5EYXRhZmxvdyA9IHJlcXVpcmUgXCIuLi9EYXRhZmxvdy9EYXRhZmxvd1wiXG5HcmFwaGljID0gcmVxdWlyZSBcIi4uL0dyYXBoaWMvR3JhcGhpY1wiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbCA9IHt9XG5cbiMgVGhlc2UgYXJlICpjbGFzc2VzKlxuTW9kZWwuUHJvamVjdCA9IHJlcXVpcmUgXCIuL1Byb2plY3RcIlxuTW9kZWwuUGFydGljdWxhckVsZW1lbnQgPSByZXF1aXJlIFwiLi9QYXJ0aWN1bGFyRWxlbWVudFwiXG5cbiMgVGhlc2UgYXJlICp2YXJpYW50cyBvZiB0aGUgTm9kZSBvYmplY3QqXG5Nb2RlbC5Ob2RlID0gcmVxdWlyZSBcIi4vTm9kZVwiXG5Nb2RlbC5MaW5rID0gcmVxdWlyZSBcIi4vTGlua1wiXG5Nb2RlbC5BdHRyaWJ1dGUgPSByZXF1aXJlIFwiLi9BdHRyaWJ1dGVcIlxuTW9kZWwuRWxlbWVudCA9IHJlcXVpcmUgXCIuL0VsZW1lbnRcIlxuXG5cbk1vZGVsLkVkaXRvciA9IHJlcXVpcmUgXCIuL0VkaXRvclwiXG5cblxuTW9kZWwuVmFyaWFibGUgPSBNb2RlbC5BdHRyaWJ1dGUuY3JlYXRlVmFyaWFudCgpXG5cbiMgTGlua3MgYW4gRWxlbWVudCB0byB0aGUgQXR0cmlidXRlcyBpdCBjb250cm9scy5cbk1vZGVsLkNvbnRyb2xsZWRBdHRyaWJ1dGVMaW5rID0gTW9kZWwuTGluay5jcmVhdGVWYXJpYW50KClcblxuIyBMaW5rcyBhbiBBdHRyaWJ1dGUgdG8gdGhlIEF0dHJpYnV0ZXMgaXQgcmVmZXJlbmNlcyBpbiBpdHMgZXhwcmVzc2lvbi5cbk1vZGVsLlJlZmVyZW5jZUxpbmsgPSBNb2RlbC5MaW5rLmNyZWF0ZVZhcmlhbnQoKVxuXG5jcmVhdGVBdHRyaWJ1dGUgPSAobGFiZWwsIG5hbWUsIGV4cHJTdHJpbmcpIC0+XG4gIGF0dHJpYnV0ZSA9IE1vZGVsLkF0dHJpYnV0ZS5jcmVhdGVWYXJpYW50XG4gICAgbGFiZWw6IGxhYmVsXG4gICAgbmFtZTogbmFtZVxuICBhdHRyaWJ1dGUuc2V0RXhwcmVzc2lvbihleHByU3RyaW5nKVxuICByZXR1cm4gYXR0cmlidXRlXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgQ29tcG9uZW50c1xuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Nb2RlbC5Db21wb25lbnQgPSBNb2RlbC5Ob2RlLmNyZWF0ZVZhcmlhbnRcbiAgYXR0cmlidXRlczogLT5cbiAgICBAY2hpbGRyZW5PZlR5cGUoTW9kZWwuQXR0cmlidXRlKVxuXG4gIGdldEF0dHJpYnV0ZXNCeU5hbWU6IC0+XG4gICAgXy5pbmRleEJ5IEBhdHRyaWJ1dGVzKCksIFwibmFtZVwiXG5cbiAgZ2V0QXR0cmlidXRlc1ZhbHVlc0J5TmFtZTogLT5cbiAgICByZXN1bHQgPSB7fVxuICAgIGZvciBhdHRyaWJ1dGUgaW4gQGF0dHJpYnV0ZXMoKVxuICAgICAgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSgpXG4gICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZVxuICAgIHJldHVybiByZXN1bHRcblxuICBncmFwaGljQ2xhc3M6IEdyYXBoaWMuQ29tcG9uZW50XG5cbiAgZ3JhcGhpYzogLT5cbiAgICBncmFwaGljID0gbmV3IEBncmFwaGljQ2xhc3MoKVxuICAgIF8uZXh0ZW5kIGdyYXBoaWMsIEBnZXRBdHRyaWJ1dGVzVmFsdWVzQnlOYW1lKClcbiAgICByZXR1cm4gZ3JhcGhpY1xuXG5cblxuTW9kZWwuVHJhbnNmb3JtID0gTW9kZWwuQ29tcG9uZW50LmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiVHJhbnNmb3JtXCJcbiAgbWF0cml4OiAtPlxuICAgIHt4LCB5LCBzeCwgc3ksIHJvdGF0ZX0gPSBAZ2V0QXR0cmlidXRlc1ZhbHVlc0J5TmFtZSgpXG4gICAgcmV0dXJuIFV0aWwuTWF0cml4Lm5hdHVyYWxDb25zdHJ1Y3QoeCwgeSwgc3gsIHN5LCByb3RhdGUpXG4gIGRlZmF1bHRBdHRyaWJ1dGVzVG9DaGFuZ2U6IC0+XG4gICAge3gsIHl9ID0gQGdldEF0dHJpYnV0ZXNCeU5hbWUoKVxuICAgIHJldHVybiBbeCwgeV1cbiAgY29udHJvbGxhYmxlQXR0cmlidXRlczogLT5cbiAgICB7eCwgeSwgc3gsIHN5LCByb3RhdGV9ID0gQGdldEF0dHJpYnV0ZXNCeU5hbWUoKVxuICAgIHJldHVybiBbeCwgeSwgc3gsIHN5LCByb3RhdGVdXG4gIGNvbnRyb2xQb2ludHM6IC0+XG4gICAge3gsIHksIHN4LCBzeX0gPSBAZ2V0QXR0cmlidXRlc0J5TmFtZSgpXG4gICAgcmV0dXJuIFtcbiAgICAgIHtwb2ludDogWzAsIDBdLCBhdHRyaWJ1dGVzVG9DaGFuZ2U6IFt4LCB5XSwgZmlsbGVkOiB0cnVlfVxuICAgICAge3BvaW50OiBbMSwgMF0sIGF0dHJpYnV0ZXNUb0NoYW5nZTogW3N4XSwgZmlsbGVkOiBmYWxzZX1cbiAgICAgIHtwb2ludDogWzAsIDFdLCBhdHRyaWJ1dGVzVG9DaGFuZ2U6IFtzeV0sIGZpbGxlZDogZmFsc2V9XG4gICAgXVxuXG5Nb2RlbC5UcmFuc2Zvcm0uYWRkQ2hpbGRyZW4gW1xuICBjcmVhdGVBdHRyaWJ1dGUoXCJYXCIsIFwieFwiLCBcIjAuMDBcIilcbiAgY3JlYXRlQXR0cmlidXRlKFwiWVwiLCBcInlcIiwgXCIwLjAwXCIpXG4gIGNyZWF0ZUF0dHJpYnV0ZShcIlNjYWxlIFhcIiwgXCJzeFwiLCBcIjEuMDBcIilcbiAgY3JlYXRlQXR0cmlidXRlKFwiU2NhbGUgWVwiLCBcInN5XCIsIFwiMS4wMFwiKVxuICBjcmVhdGVBdHRyaWJ1dGUoXCJSb3RhdGVcIiwgXCJyb3RhdGVcIiwgXCIwLjAwXCIpXG5dXG5cblxuXG5Nb2RlbC5GaWxsID0gTW9kZWwuQ29tcG9uZW50LmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiRmlsbFwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5GaWxsXG5cbk1vZGVsLkZpbGwuYWRkQ2hpbGRyZW4gW1xuICBjcmVhdGVBdHRyaWJ1dGUoXCJGaWxsIENvbG9yXCIsIFwiY29sb3JcIiwgXCJyZ2JhKDAuOTMsIDAuOTMsIDAuOTMsIDEuMDApXCIpXG5dXG5cblxuTW9kZWwuU3Ryb2tlID0gTW9kZWwuQ29tcG9uZW50LmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiU3Ryb2tlXCJcbiAgZ3JhcGhpY0NsYXNzOiBHcmFwaGljLlN0cm9rZVxuXG5Nb2RlbC5TdHJva2UuYWRkQ2hpbGRyZW4gW1xuICBjcmVhdGVBdHRyaWJ1dGUoXCJTdHJva2UgQ29sb3JcIiwgXCJjb2xvclwiLCBcInJnYmEoMC42MCwgMC42MCwgMC42MCwgMS4wMClcIilcbiAgY3JlYXRlQXR0cmlidXRlKFwiTGluZSBXaWR0aFwiLCBcImxpbmVXaWR0aFwiLCBcIjFcIilcbl1cblxuXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4jIEVsZW1lbnRzXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbk1vZGVsLlNoYXBlID0gTW9kZWwuRWxlbWVudC5jcmVhdGVWYXJpYW50KClcbk1vZGVsLlNoYXBlLmFkZENoaWxkcmVuIFtcbiAgTW9kZWwuVHJhbnNmb3JtLmNyZWF0ZVZhcmlhbnQoKVxuXVxuXG5cbk1vZGVsLkdyb3VwID0gTW9kZWwuU2hhcGUuY3JlYXRlVmFyaWFudFxuICBsYWJlbDogXCJHcm91cFwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5Hcm91cFxuXG5cbk1vZGVsLkFuY2hvciA9IE1vZGVsLlNoYXBlLmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiQW5jaG9yXCJcbiAgZ3JhcGhpY0NsYXNzOiBHcmFwaGljLkFuY2hvclxuXG5jcmVhdGVBbmNob3IgPSAoeCwgeSkgLT5cbiAgYW5jaG9yID0gTW9kZWwuQW5jaG9yLmNyZWF0ZVZhcmlhbnQoKVxuICB0cmFuc2Zvcm0gPSBhbmNob3IuY2hpbGRPZlR5cGUoTW9kZWwuVHJhbnNmb3JtKVxuICBhdHRyaWJ1dGVzID0gdHJhbnNmb3JtLmdldEF0dHJpYnV0ZXNCeU5hbWUoKVxuICBhdHRyaWJ1dGVzLnguc2V0RXhwcmVzc2lvbih4KVxuICBhdHRyaWJ1dGVzLnkuc2V0RXhwcmVzc2lvbih5KVxuICByZXR1cm4gYW5jaG9yXG5cblxuTW9kZWwuUGF0aENvbXBvbmVudCA9IE1vZGVsLkNvbXBvbmVudC5jcmVhdGVWYXJpYW50XG4gIGxhYmVsOiBcIlBhdGhcIlxuICBncmFwaGljQ2xhc3M6IEdyYXBoaWMuUGF0aENvbXBvbmVudFxuXG5Nb2RlbC5QYXRoQ29tcG9uZW50LmFkZENoaWxkcmVuIFtcbiAgY3JlYXRlQXR0cmlidXRlKFwiQ2xvc2UgUGF0aFwiLCBcImNsb3NlZFwiLCBcInRydWVcIilcbl1cblxuTW9kZWwuUGF0aCA9IE1vZGVsLlNoYXBlLmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiUGF0aFwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5QYXRoXG5cbk1vZGVsLlBhdGguYWRkQ2hpbGRyZW4gW1xuICBNb2RlbC5QYXRoQ29tcG9uZW50LmNyZWF0ZVZhcmlhbnQoKVxuICBNb2RlbC5GaWxsLmNyZWF0ZVZhcmlhbnQoKVxuICBNb2RlbC5TdHJva2UuY3JlYXRlVmFyaWFudCgpXG5dXG5cblxuTW9kZWwuQ2lyY2xlID0gTW9kZWwuUGF0aC5jcmVhdGVWYXJpYW50XG4gIGxhYmVsOiBcIkNpcmNsZVwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5DaXJjbGVcblxuXG5Nb2RlbC5SZWN0YW5nbGUgPSBNb2RlbC5QYXRoLmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiUmVjdGFuZ2xlXCJcblxuTW9kZWwuUmVjdGFuZ2xlLmFkZENoaWxkcmVuIFtcbiAgY3JlYXRlQW5jaG9yKFwiMC4wMFwiLCBcIjAuMDBcIilcbiAgY3JlYXRlQW5jaG9yKFwiMC4wMFwiLCBcIjEuMDBcIilcbiAgY3JlYXRlQW5jaG9yKFwiMS4wMFwiLCBcIjEuMDBcIilcbiAgY3JlYXRlQW5jaG9yKFwiMS4wMFwiLCBcIjAuMDBcIilcbl1cblxuXG5Nb2RlbC5UZXh0Q29tcG9uZW50ID0gTW9kZWwuQ29tcG9uZW50LmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiVGV4dFwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5UZXh0Q29tcG9uZW50XG5cbk1vZGVsLlRleHRDb21wb25lbnQuYWRkQ2hpbGRyZW4gW1xuICBjcmVhdGVBdHRyaWJ1dGUoXCJUZXh0XCIsIFwidGV4dFwiLCAnXCJUZXh0XCInKVxuICBjcmVhdGVBdHRyaWJ1dGUoXCJGb250XCIsIFwiZm9udEZhbWlseVwiLCAnXCJMdWNpZGEgR3JhbmRlXCInKVxuICBjcmVhdGVBdHRyaWJ1dGUoXCJDb2xvclwiLCBcImNvbG9yXCIsIFwicmdiYSgwLjIwLCAwLjIwLCAwLjIwLCAxLjAwKVwiKVxuICBjcmVhdGVBdHRyaWJ1dGUoXCJBbGlnblwiLCBcInRleHRBbGlnblwiLCAnXCJzdGFydFwiJylcbiAgY3JlYXRlQXR0cmlidXRlKFwiQmFzZWxpbmVcIiwgXCJ0ZXh0QmFzZWxpbmVcIiwgJ1wiYWxwaGFiZXRpY1wiJylcbl1cblxuTW9kZWwuVGV4dCA9IE1vZGVsLlNoYXBlLmNyZWF0ZVZhcmlhbnRcbiAgbGFiZWw6IFwiVGV4dFwiXG4gIGdyYXBoaWNDbGFzczogR3JhcGhpYy5UZXh0XG5cbk1vZGVsLlRleHQuYWRkQ2hpbGRyZW4gW1xuICBNb2RlbC5UZXh0Q29tcG9uZW50LmNyZWF0ZVZhcmlhbnQoKVxuXVxuIiwiIyMjXG5cbiMgSW50cm9kdWN0aW9uXG5cblRoZSAqbm9kZSogaXMgdGhlICpmb3VuZGF0aW9uYWwgYWJzdHJhY3Rpb24qIGZvciBtYW5hZ2luZyB0aGUgKnNjZW5lIGdyYXBoKiBvZlxuZGlhZ3JhbXMgYXMgd2VsbCBhcyB0aGUgKmluaGVyaXRhbmNlIGhpZXJhcmNoeSouXG5cblRoZSBzY2VuZSBncmFwaCBpcyBtYW5hZ2VkIHRocm91Z2ggcGFyZW50IGFuZCBjaGlsZHJlbiByZWxhdGlvbnNoaXBzLiBUaGlzIGlzXG52ZXJ5IG11Y2ggbGlrZSB0aGUgRE9NOiBldmVyeSBub2RlIGNhbiBoYXZlIDAgb3IgMSBwYXJlbnQgYW5kIHRoZSBgYWRkQ2hpbGRgXG5hbmQgYHJlbW92ZUNoaWxkYCBtZXRob2RzIGVuc3VyZSB0aGF0IGFsbCB0aGUgcGFyZW50L2NoaWxkcmVuIHBvaW50ZXJzIHBvaW50XG5hdCB0aGUgcmlnaHQgdGhpbmcuXG5cbk5vZGVzIGNhbiBoYXZlIHByb3BlcnRpZXMgaW4gYWRkaXRpb24gdG8gY2hpbGRyZW4uIFRoZXNlIGFyZSBtYW5hZ2VkIHNpbXBseSBhc1xuamF2YXNjcmlwdCBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlIG9iamVjdHMuXG5cbkluaGVyaXRhbmNlIGlzIGhhbmRsZWQgYSBsaXR0bGUgZGlmZmVyZW50bHkuIFRvIHJlZHVjZSBjb25mdXNpb24sIHdlIHVzZSBhXG5kaWZmZXJlbnQgbm9tZW5jbGF0dXJlIHRoYW4gY2xhc3MtaW5zdGFuY2Ugb3IgcHJvdG90eXBlLT8/LiBXZSBjYWxsIGEgbm9kZSBhXG4qbWFzdGVyKiBhbmQgc2F5IHRoYXQgaXQgY2FuIGhhdmUgKnZhcmlhbnRzKi4gWW91IGNhbiBjcmVhdGUgYSBuZXcgdmFyaWFudFxuc2ltcGx5IGJ5IGNhbGxpbmcgdGhlIGBjcmVhdGVWYXJpYW50YCBtZXRob2QuXG5cblRoZSBtYXN0ZXItdmFyaWFudCByZWxhdGlvbnNoaXAgaXMgc2ltaWxhciB0byB0aGUgcHJvdG90eXBlIHJlbGF0aW9uc2hpcC5cbkluZGVlZCB3ZSB1c2UgamF2YXNjcmlwdCdzIGJ1aWx0LWluIHByb3RvdHlwZSB0cmVlLCBzbyBpZiBBIGlzIHRoZSBtYXN0ZXIgb2ZcbkIsIHRoZW4gQi5fX3Byb3RvX18gPT0gQS4gVGh1cyBwcm9wZXJ0aWVzIGluaGVyaXQgYXMgaW4gcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblxuQ2hpbGRyZW4sIGhvd2V2ZXIsIGluaGVyaXQgYSBsaXR0bGUgZGlmZmVyZW50bHkuIFNwZWNpZmljYWxseSwgdGhlIGVudGlyZVxuc2NlbmUgZ3JhcGggKnN0cnVjdHVyZSogaXMgYWxzbyBpbmhlcml0ZWQuXG5cblNvIHdoZW4geW91IGNyZWF0ZSBhIHZhcmlhbnQgb2YgYSBub2RlLCB5b3UgYWxzbyBpbXBsaWNpdGx5IGNyZWF0ZVxuY29ycmVzcG9uZGluZyB2YXJpYW50cyBvZiBlYWNoIG9mIHRoZSBub2RlJ3MgY2hpbGRyZW4gYW5kIHNvIG9uIHJlY3Vyc2l2ZWx5LlxuVGhhdCBpcywgeW91IGNyZWF0ZSBhIGRlZXAgY2xvbmUgb2YgdGhlIG5vZGUgaW4gc3VjaCBhIHdheSB0aGF0IGV2ZXJ5IGNyZWF0ZWRcbm5vZGUgaGFzIGFzIGl0cyBtYXN0ZXIgdGhlIGFuYWxvZ291cyBub2RlIGluIHRoZSBvcmlnaW5hbCB0cmVlLiBTbyBpZiBJIGhhdmUgYVxubm9kZSBBIHdpdGggY2hpbGRyZW4gQiBhbmQgQyBhbmQgSSBjcmVhdGUgYSB2YXJpYW50IG9mIEEgY2FsbGVkIEEnLCB0aGVuIEEnXG53aWxsIGF1dG9tYXRpY2FsbHkgaGF2ZSBhcyBpdHMgY2hpbGRyZW4gQicgYW5kIEMnIHdoaWNoIGFyZSB2YXJpYW50cyBvZiBCIGFuZFxuQyByZXNwZWN0aXZlbHkuXG5cbkFkZGl0aW9uYWxseSwgZXZlcnkgdmFyaWFudCBub2RlIGFsc28gaGFzIGEgcG9pbnRlciB0byBpdHMgKmhlYWQqLiBUaGUgaGVhZCBpc1xudGhlIHJvb3Qgb2YgdGhlIGNsb25lZCB0cmVlLiBTbyBpZiBJIGhhdmUgTm9kZSBBIHdpdGggY2hpbGQgTm9kZSBCIGFuZCBJXG5jcmVhdGUgYSB2YXJpYW50IG9mIEEgdG8gbWFrZSBBJyB3aXRoIGNoaWxkIEInLCB0aGVuIGJvdGggQScgYW5kIEInIHdpbGwgaGF2ZVxuYXMgdGhlaXIgaGVhZCBBJy4gV2Uga2VlcCB0cmFjayBvZiB0aGlzIGluIG9yZGVyIHRvIGZpbmQgKmFuYWxvZ291cyogbm9kZXNcbmZyb20gb25lIHRyZWUgdG8gYW5vdGhlci5cblxuXG4jIE92ZXJyaWRpbmdcblxuSW4gYWRkaXRpb24gdG8gYSB2YXJpYW50IG92ZXJyaWRpbmcgcHJvcGVydGllcyBvZiBpdHMgbWFzdGVyLCBhcyBpbiBub3JtYWxcbnByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIGEgdmFyaWFudCBjYW4gYWxzbyBvdmVycmlkZSB0aGUgY2hpbGRyZW4gc3RydWN0dXJlIG9mXG5pdHMgbWFzdGVyLiBUaGF0IGlzLCB5b3UgY2FuIGFkZCBhbmQgcmVtb3ZlIGNoaWxkcmVuIGZyb20gdGhlIHZhcmlhbnQuIFRoZXNlXG5jaGFuZ2VzICp3aWxsIG5vdCogcHJvcGFnYXRlIGJhY2sgdXAgdG8gdGhlIG1hc3Rlci4gSG93ZXZlciwgY2hhbmdlcyBtYWRlIHRvIGFcbm1hc3RlciAoYWRkaW5nIGFuZCByZW1vdmluZyBjaGlsZHJlbikgKndpbGwqIHByb3BhZ2F0ZSBkb3duIHRvIGl0cyB2YXJpYW50cy5cblxuXG4jIExhenkgSW1wbGVtZW50YXRpb25cblxuV2UgdXNlIGEgbGF6eSBpbXBsZW1lbnRhdGlvbiBpbiBvcmRlciB0byBzdXBwb3J0IGluZmluaXRlIHJlY3Vyc2lvbi4gQW5cbmV4YW1wbGUgb2YgcmVjdXJzaW9uIHdvdWxkIGJlIE5vZGUgQSBoYXMgYXMgYSBjaGlsZCBOb2RlIEEnIHdoaWNoIGlzIGEgY2xvbmVcbm9mIEEuIFlvdSBjYW4gZm9sbG93IHRoZSBjaGlsZHJlbiBkb3duIGFzIGZhciBhcyB5b3Ugd2FudCB0byBnbyAoYnkgY2FsbGluZ1xuTm9kZS5jaGlsZHJlbigpIHJlY3Vyc2l2ZWx5KSwgYnV0IHRoZSBzeXN0ZW0gd29uJ3QgY3Jhc2ggYnkgdHJ5aW5nIHRvIGNyZWF0ZVxuYW4gaW5maW5pdGUgZGF0YSBzdHJ1Y3R1cmUuXG5cbldlIGFjaGlldmUgdGhpcyB3aXRoIGEgXCJ0aHVua1wiIHN0cmF0ZWd5LiBXaGVuIE5vZGVzIGFyZSBpbml0aWFsbHkgY3JlYXRlZCB0aGV5XG5hcmUgXCJlZ2dzXCIuIEl0IGlzIG9ubHkgd2hlbiB0aGV5IGFyZSBhc2tlZCBhYm91dCB0aGVpciBjaGlsZHJlbiB0aGF0IHRoZXlcblwiaGF0Y2hcIiBhbmQgaW5zdGFudGlhdGUgdGhlaXIgY2hpbGRyZW4uIChBbmQgdGhlaXIgY2hpbGRyZW4gYXJlIGluc3RhbnRpYXRlZFxuYXMgZWdncywgb2YgY291cnNlLilcblxuV2Ugd2FudCBjb25zdW1lcnMgb2YgdGhpcyBBUEkgdG8gbmV2ZXIga25vdyB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBsYXp5LlxuSXQgc2hvdWxkIGFwcGVhciB0aGF0IHlvdSBjYW4ganVzdCBhY2Nlc3MgTm9kZS5jaGlsZHJlbigpLCBldGMuIGFuZCBhbHdheXMgZ2V0XG5iYWNrIHRoZSBjb3JyZWN0IE5vZGUocyksIGFzIGlmIHdlIGhhZCBpbmZpbml0ZSBtZW1vcnkuIFRodXMgd2UgbmVlZCB0byBoYXRjaFxudGhlIGFwcHJvcHJpYXRlIE5vZGUocykgd2hlbiBjZXJ0YWluIGNhbGxzIGFyZSBtYWRlLS1iYXNpY2FsbHkgd2hlbmV2ZXIgd2UgZ29cblwiZG93blwiIHRoZSB0cmVlLlxuXG4jIyNcblxuXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGUgPSB7XG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIEBfbWFzdGVyID0gbnVsbFxuICAgIEBfdmFyaWFudHMgPSBbXVxuXG4gICAgQF9wYXJlbnQgPSBudWxsXG4gICAgQF9jaGlsZHJlbiA9IFtdXG5cbiAgICBAX2hlYWQgPSBudWxsXG5cbiAgICBAX2lzSGF0Y2hlZCA9IGZhbHNlXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIEFjY2Vzc29yc1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIG1hc3RlcjogLT4gQF9tYXN0ZXJcblxuICB2YXJpYW50czogLT5cbiAgICAjIElmIHdlIGp1c3QgcmV0dXJuZWQgQF92YXJpYW50cyB0aGlzIHdvdWxkIGV4cG9zZSB0aGUgbGF6eVxuICAgICMgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgYW5zd2VyIGRlcGVuZHMgb24gd2hhdCdzIGhhdGNoZWQuIEZvclxuICAgICMgZXhhbXBsZSwgaWYgQSBpcyB0aGUgcGFyZW50IG9mIEIgYW5kIEEnIGlzIGEgdmFyaWFudCBvZiBBIGJ1dCBpcyBub3RcbiAgICAjIGhhdGNoZWQsIHRoZW4gQi52YXJpYW50cygpIHdpbGwgbm90IHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBCJ1xuICAgICMgYmVjYXVzZSBpdCBkb2Vzbid0IGV4aXN0IHlldCAoYmVjYXVzZSBBJyBpcyBub3QgaGF0Y2hlZCkuXG5cbiAgICAjIEJ1dCBieSBoYXRjaGluZyBhbGwgbXkgcGFyZW50J3MgdmFyaWFudHMsIHdlIGd1YXJhbnRlZSB0aGF0IGFsbCBvZiBteVxuICAgICMgdmFyaWFudHMgbXVzdCBleGlzdCwgYW5kIHRoZXJlZm9yZSBtdXN0IGJlIGluIEBfdmFyaWFudHMuXG4gICAgaWYgcGFyZW50ID0gQHBhcmVudCgpXG4gICAgICBwYXJlbnRWYXJpYW50cyA9IHBhcmVudC52YXJpYW50cygpXG4gICAgICBmb3IgcGFyZW50VmFyaWFudCBpbiBwYXJlbnRWYXJpYW50c1xuICAgICAgICBwYXJlbnRWYXJpYW50Ll9oYXRjaCgpXG5cbiAgICByZXR1cm4gQF92YXJpYW50c1xuXG4gIHBhcmVudDogLT5cbiAgICBAX3BhcmVudFxuXG4gIGNoaWxkcmVuOiAtPlxuICAgIEBfaGF0Y2goKVxuICAgIHJldHVybiBAX2NoaWxkcmVuXG5cbiAgaGVhZDogLT4gQF9oZWFkXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIEhhdGNoaW5nIChyZXF1aXJlZCB0byB3b3JrIHdpdGggY2hpbGRyZW4pXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX2hhdGNoOiAtPlxuICAgIHJldHVybiBpZiBAX2lzSGF0Y2hlZFxuXG4gICAgIyBNYWtlIHN1cmUgbXkgbWFzdGVyIGlzIGhhdGNoZWQuXG4gICAgQF9tYXN0ZXI/Ll9oYXRjaCgpXG5cbiAgICBAX2lzSGF0Y2hlZCA9IHRydWVcblxuICAgIGlmIEBfbWFzdGVyP1xuICAgICAgZm9yIG1hc3RlckNoaWxkIGluIEBfbWFzdGVyLmNoaWxkcmVuKClcbiAgICAgICAgbXlDaGlsZCA9IG1hc3RlckNoaWxkLl9jcmVhdGVWYXJpYW50V2l0aEhlYWQoQF9oZWFkKVxuICAgICAgICBAYWRkQ2hpbGQobXlDaGlsZClcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgV29ya2luZyB3aXRoIGNoaWxkcmVuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgYWRkQ2hpbGQ6IChjaGlsZFRvQWRkLCBpbnNlcnRpb25JbmRleD1JbmZpbml0eSkgLT5cbiAgICAjIFdpbGwgYWRkIGNoaWxkVG9BZGQgdG8gY2hpbGRyZW4gc3VjaCB0aGF0IGl0IGFwcGVhcnMgaW4gY2hpbGRyZW4oKSBhdFxuICAgICMgaW5zZXJ0aW9uSW5kZXguXG5cbiAgICBAX2hhdGNoKClcblxuICAgIGV4aXN0aW5nUGFyZW50ID0gY2hpbGRUb0FkZC5wYXJlbnQoKVxuXG4gICAgIyBSZW1vdmUgY2hpbGQgZnJvbSBpdHMgZXhpc3RpbmcgcGFyZW50LlxuICAgIGlmIGV4aXN0aW5nUGFyZW50XG4gICAgICBleGlzdGluZ1BhcmVudC5yZW1vdmVDaGlsZChjaGlsZFRvQWRkKVxuXG4gICAgIyBBZGQgY2hpbGRcbiAgICBAX2NoaWxkcmVuLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgY2hpbGRUb0FkZClcbiAgICBjaGlsZFRvQWRkLl9wYXJlbnQgPSB0aGlzXG5cbiAgICAjIEFkZCBhIGNvcnJlc3BvbmRpbmcgY2hpbGQgdG8gZWFjaCBvZiBteSBoYXRjaGVkIHZhcmlhbnRzLlxuICAgIGZvciB2YXJpYW50IGluIEBfdmFyaWFudHNcbiAgICAgICMgRG9uJ3QgYm90aGVyIGlmIHRoZSB2YXJpYW50IGlzbid0IGhhdGNoZWQuIEl0IHdpbGwgY3JlYXRlIGEgdmFyaWFudCBvZlxuICAgICAgIyB0aGUgY2hpbGQgb25jZSBpdCBoYXRjaGVzLlxuICAgICAgY29udGludWUgdW5sZXNzIHZhcmlhbnQuX2lzSGF0Y2hlZFxuXG4gICAgICBoZWFkID0gdmFyaWFudC5oZWFkKClcblxuICAgICAgIyBGaXJzdCBsb29rIHRvIHNlZSBpZiB0aGUgdmFyaWFudCBjaGlsZCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgIGNvcnJlc3BvbmRpbmdDaGlsZCA9IGNoaWxkVG9BZGQuZmluZFZhcmlhbnRXaXRoSGVhZChoZWFkKVxuXG4gICAgICBpZiAhY29ycmVzcG9uZGluZ0NoaWxkXG4gICAgICAgICMgSWYgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgZG9lcyBub3QgZXhpc3QsIGNyZWF0ZSBpdCBieSBjcmVhdGluZyBhXG4gICAgICAgICMgdmFyaWFudCBvZiBjaGlsZFRvQWRkLlxuICAgICAgICBjb3JyZXNwb25kaW5nQ2hpbGQgPSBjaGlsZFRvQWRkLl9jcmVhdGVWYXJpYW50V2l0aEhlYWQoaGVhZClcblxuICAgICAgdmFyaWFudC5hZGRDaGlsZChjb3JyZXNwb25kaW5nQ2hpbGQsIGluc2VydGlvbkluZGV4KVxuXG4gIHJlbW92ZUNoaWxkOiAoY2hpbGRUb1JlbW92ZSkgLT5cbiAgICBAX2hhdGNoKClcblxuICAgICMgUmVtb3ZlIHRoZSBjaGlsZFxuICAgIGluc2VydGlvbkluZGV4ID0gQF9jaGlsZHJlbi5pbmRleE9mKGNoaWxkVG9SZW1vdmUpXG4gICAgaWYgaW5zZXJ0aW9uSW5kZXggPT0gLTFcbiAgICAgIHRocm93IFwiQ2Fubm90IHJlbW92ZSBhIGNoaWxkIHRoYXQgZG9lc24ndCBleGlzdFwiXG5cbiAgICBAX2NoaWxkcmVuLnNwbGljZShpbnNlcnRpb25JbmRleCwgMSlcbiAgICBjaGlsZFRvUmVtb3ZlLl9wYXJlbnQgPSBudWxsXG5cbiAgICAjIFJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBjaGlsZCBpbiBlYWNoIG9mIG15IGhhdGNoZWQgdmFyaWFudHMuXG4gICAgZm9yIHZhcmlhbnQgaW4gQF92YXJpYW50c1xuICAgICAgIyBEb24ndCBib3RoZXIgaWYgdGhlIHZhcmlhbnQgaXNuJ3QgaGF0Y2hlZC4gSXQgd2lsbCB0YWtlIG9uIHRoZVxuICAgICAgIyBhcHByb3ByaWF0ZSBjaGlsZHJlbiB3aGVuIGl0IGhhdGNoZXMuXG4gICAgICBjb250aW51ZSB1bmxlc3MgdmFyaWFudC5faXNIYXRjaGVkXG5cbiAgICAgIGhlYWQgPSB2YXJpYW50LmhlYWQoKVxuXG4gICAgICBjb3JyZXNwb25kaW5nQ2hpbGQgPSBjaGlsZFRvUmVtb3ZlLmZpbmRWYXJpYW50V2l0aEhlYWQoaGVhZClcbiAgICAgIGlmIGNvcnJlc3BvbmRpbmdDaGlsZD8ucGFyZW50KCkgPT0gdmFyaWFudFxuICAgICAgICB2YXJpYW50LnJlbW92ZUNoaWxkKGNvcnJlc3BvbmRpbmdDaGlsZClcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgQ3JlYXRpbmcgVmFyaWFudHNcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBfY3JlYXRlVmFyaWFudFdpdGhIZWFkOiAoaGVhZD1udWxsLCBzcGVjKSAtPlxuICAgIHZhcmlhbnQgPSBPYmplY3QuY3JlYXRlKHRoaXMpXG4gICAgXy5leHRlbmQodmFyaWFudCwgc3BlYykgaWYgc3BlYz9cbiAgICB2YXJpYW50LmNvbnN0cnVjdG9yKClcblxuICAgIGlmICFoZWFkP1xuICAgICAgaGVhZCA9IHZhcmlhbnRcblxuICAgIHZhcmlhbnQuX2hlYWQgPSBoZWFkXG4gICAgdmFyaWFudC5fbWFzdGVyID0gdGhpc1xuICAgIEBfdmFyaWFudHMucHVzaCh2YXJpYW50KVxuXG4gICAgcmV0dXJuIHZhcmlhbnRcblxuICBjcmVhdGVWYXJpYW50OiAoc3BlYykgLT5cbiAgICByZXR1cm4gQF9jcmVhdGVWYXJpYW50V2l0aEhlYWQobnVsbCwgc3BlYylcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgRmluZGluZyB2YXJpYW50cy5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmaW5kVmFyaWFudFdpdGhIZWFkOiAoaGVhZCkgLT5cbiAgICByZXR1cm4gXy5maW5kIEB2YXJpYW50cygpLCAodmFyaWFudCkgLT5cbiAgICAgIHZhcmlhbnQuaGVhZCgpID09IGhlYWRcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgSGVscGVyc1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGlzVmFyaWFudE9mOiAoZ3JhbmRNYXN0ZXIpIC0+XG4gICAgcmV0dXJuIGdyYW5kTWFzdGVyID09IHRoaXMgb3IgZ3JhbmRNYXN0ZXIuaXNQcm90b3R5cGVPZih0aGlzKVxuXG4gIGlzQW5jZXN0b3JPZjogKGdyYW5kQ2hpbGQpIC0+XG4gICAgaWYgdGhpcyA9PSBncmFuZENoaWxkXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGlmIHBhcmVudCA9IGdyYW5kQ2hpbGQucGFyZW50KClcbiAgICAgIHJldHVybiBAaXNBbmNlc3Rvck9mKHBhcmVudClcbiAgICByZXR1cm4gZmFsc2VcblxuICBhZGRDaGlsZHJlbjogKGNoaWxkcmVuKSAtPlxuICAgIEBhZGRDaGlsZChjaGlsZCkgZm9yIGNoaWxkIGluIGNoaWxkcmVuXG5cbiAgY2hpbGRyZW5PZlR5cGU6ICh0eXBlKSAtPlxuICAgIF8uZmlsdGVyIEBjaGlsZHJlbigpLCAoY2hpbGQpIC0+IGNoaWxkLmlzVmFyaWFudE9mKHR5cGUpXG5cbiAgY2hpbGRPZlR5cGU6ICh0eXBlKSAtPlxuICAgIF8uZmluZCBAY2hpbGRyZW4oKSwgKGNoaWxkKSAtPiBjaGlsZC5pc1ZhcmlhbnRPZih0eXBlKVxuXG4gIGRlcHRoOiAtPlxuICAgIHJldHVybiAwIGlmICFAcGFyZW50KClcbiAgICByZXR1cm4gMSArIEBwYXJlbnQoKS5kZXB0aCgpXG5cbiAgcmVwbGFjZUNoaWxkV2l0aDogKGNoaWxkVG9SZXBsYWNlLCByZXBsYWNlbWVudE5vZGUpIC0+XG4gICAgaW5kZXggPSBAY2hpbGRyZW4oKS5pbmRleE9mKGNoaWxkVG9SZXBsYWNlKVxuICAgIEByZW1vdmVDaGlsZChjaGlsZFRvUmVwbGFjZSlcbiAgICBAYWRkQ2hpbGQocmVwbGFjZW1lbnROb2RlLCBpbmRleClcblxufVxuXG5Ob2RlLmNvbnN0cnVjdG9yKClcbiIsIkRhdGFmbG93ID0gcmVxdWlyZSBcIi4uL0RhdGFmbG93L0RhdGFmbG93XCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBhcnRpY3VsYXJFbGVtZW50XG4gIGNvbnN0cnVjdG9yOiAoQGVsZW1lbnQsIEBzcHJlYWRFbnYpIC0+XG4gICAgQHNwcmVhZEVudiA/PSBEYXRhZmxvdy5TcHJlYWRFbnYuZW1wdHlcblxuICBpc0VxdWFsVG86IChwYXJ0aWN1bGFyRWxlbWVudCkgLT5cbiAgICByZXR1cm4gQGVsZW1lbnQgPT0gcGFydGljdWxhckVsZW1lbnQuZWxlbWVudCBhbmRcbiAgICAgIEBzcHJlYWRFbnYuaXNFcXVhbFRvKHBhcnRpY3VsYXJFbGVtZW50LnNwcmVhZEVudilcblxuICBpc0FuY2VzdG9yT2Y6IChwYXJ0aWN1bGFyRWxlbWVudCkgLT5cbiAgICByZXR1cm4gQGVsZW1lbnQuaXNBbmNlc3Rvck9mKHBhcnRpY3VsYXJFbGVtZW50LmVsZW1lbnQpIGFuZFxuICAgICAgQHNwcmVhZEVudi5jb250YWlucyhwYXJ0aWN1bGFyRWxlbWVudC5zcHJlYWRFbnYpXG5cbiAgYWNjdW11bGF0ZWRNYXRyaXg6IC0+XG4gICAgYWNjdW11bGF0ZWRNYXRyaXggPSBAZWxlbWVudC5hY2N1bXVsYXRlZE1hdHJpeC5hc1NwcmVhZCgpXG4gICAgYWNjdW11bGF0ZWRNYXRyaXggPSBAc3ByZWFkRW52LnJlc29sdmVXaXRoRGVmYXVsdChhY2N1bXVsYXRlZE1hdHJpeClcbiAgICByZXR1cm4gYWNjdW11bGF0ZWRNYXRyaXhcblxuICBjb250ZXh0TWF0cml4OiAtPlxuICAgIGNvbnRleHRNYXRyaXggPSBAZWxlbWVudC5jb250ZXh0TWF0cml4LmFzU3ByZWFkKClcbiAgICBjb250ZXh0TWF0cml4ID0gQHNwcmVhZEVudi5yZXNvbHZlV2l0aERlZmF1bHQoY29udGV4dE1hdHJpeClcbiAgICByZXR1cm4gY29udGV4dE1hdHJpeFxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbk1vZGVsID0gcmVxdWlyZSBcIi4vTW9kZWxcIlxuRGF0YWZsb3cgPSByZXF1aXJlIFwiLi4vRGF0YWZsb3cvRGF0YWZsb3dcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvamVjdFxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBpbml0aWFsRWxlbWVudCA9IEBjcmVhdGVOZXdFbGVtZW50KClcblxuICAgIEBlZGl0aW5nRWxlbWVudCA9IGluaXRpYWxFbGVtZW50XG4gICAgQHNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQgPSBudWxsXG5cbiAgICBAY3JlYXRlUGFuZWxFbGVtZW50cyA9IFtcbiAgICAgIE1vZGVsLlJlY3RhbmdsZVxuICAgICAgTW9kZWwuQ2lyY2xlXG4gICAgICBNb2RlbC5UZXh0XG4gICAgICBpbml0aWFsRWxlbWVudFxuICAgIF1cblxuICAgIHByb3BzVG9NZW1vaXplID0gW1xuICAgICAgXCJjb250cm9sbGVkQXR0cmlidXRlc1wiXG4gICAgICBcImltcGxpY2l0bHlDb250cm9sbGVkQXR0cmlidXRlc1wiXG4gICAgICBcImNvbnRyb2xsYWJsZUF0dHJpYnV0ZXNcIlxuICAgIF1cbiAgICBmb3IgcHJvcCBpbiBwcm9wc1RvTWVtb2l6ZVxuICAgICAgdGhpc1twcm9wXSA9IERhdGFmbG93Lm1lbW9pemUodGhpc1twcm9wXS5iaW5kKHRoaXMpKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBTZWxlY3Rpb25cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBzZXRFZGl0aW5nOiAoZWxlbWVudCkgLT5cbiAgICBAZWRpdGluZ0VsZW1lbnQgPSBlbGVtZW50XG4gICAgQHNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQgPSBudWxsXG5cbiAgc2VsZWN0OiAocGFydGljdWxhckVsZW1lbnQpIC0+XG4gICAgaWYgIXBhcnRpY3VsYXJFbGVtZW50XG4gICAgICBAc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudCA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50ID0gcGFydGljdWxhckVsZW1lbnRcbiAgICBAX2V4cGFuZFRvRWxlbWVudChwYXJ0aWN1bGFyRWxlbWVudC5lbGVtZW50KVxuXG4gIF9leHBhbmRUb0VsZW1lbnQ6IChlbGVtZW50KSAtPlxuICAgIHdoaWxlIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCgpXG4gICAgICBlbGVtZW50LmV4cGFuZGVkID0gdHJ1ZVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBBY3Rpb25zXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY3JlYXRlTmV3RWxlbWVudDogLT5cbiAgICBlbGVtZW50ID0gTW9kZWwuR3JvdXAuY3JlYXRlVmFyaWFudCgpXG4gICAgZWxlbWVudC5leHBhbmRlZCA9IHRydWVcbiAgICByZXR1cm4gZWxlbWVudFxuXG4gIHJlbW92ZVNlbGVjdGVkRWxlbWVudDogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50XG4gICAgc2VsZWN0ZWRFbGVtZW50ID0gQHNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQuZWxlbWVudFxuICAgIHBhcmVudCA9IHNlbGVjdGVkRWxlbWVudC5wYXJlbnQoKVxuICAgIHJldHVybiB1bmxlc3MgcGFyZW50XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHNlbGVjdGVkRWxlbWVudClcbiAgICBAc2VsZWN0KG51bGwpXG5cbiAgZ3JvdXBTZWxlY3RlZEVsZW1lbnQ6IC0+XG4gICAgcmV0dXJuIHVubGVzcyBAc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudFxuICAgIHNlbGVjdGVkRWxlbWVudCA9IEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50LmVsZW1lbnRcbiAgICBwYXJlbnQgPSBzZWxlY3RlZEVsZW1lbnQucGFyZW50KClcbiAgICByZXR1cm4gdW5sZXNzIHBhcmVudFxuICAgIGdyb3VwID0gTW9kZWwuR3JvdXAuY3JlYXRlVmFyaWFudCgpXG4gICAgZ3JvdXAuZXhwYW5kZWQgPSB0cnVlXG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZFdpdGgoc2VsZWN0ZWRFbGVtZW50LCBncm91cClcbiAgICBncm91cC5hZGRDaGlsZChzZWxlY3RlZEVsZW1lbnQpXG4gICAgQHNlbGVjdChuZXcgTW9kZWwuUGFydGljdWxhckVsZW1lbnQoZ3JvdXApKVxuXG4gIGR1cGxpY2F0ZVNlbGVjdGVkRWxlbWVudDogLT5cbiAgICAjIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYSBsaXR0bGUga29va3kgaW4gdGhhdCBpdCBjcmVhdGVzIGEgbWFzdGVyIHRoYXRcbiAgICAjIGlzIG5vdCBpbiBjcmVhdGVQYW5lbEVsZW1lbnRzLiBUaGlzIGxlYWRzIHRvIHdlaXJkbmVzcyB3aXRoIHNob3dpbmdcbiAgICAjIG5vdmVsIGF0dHJpYnV0ZXMgaW4gdGhlIHJpZ2h0IHNpZGViYXIuXG4gICAgcmV0dXJuIHVubGVzcyBAc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudFxuICAgIHNlbGVjdGVkRWxlbWVudCA9IEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50LmVsZW1lbnRcbiAgICBwYXJlbnQgPSBzZWxlY3RlZEVsZW1lbnQucGFyZW50KClcbiAgICByZXR1cm4gdW5sZXNzIHBhcmVudFxuICAgIGZpcnN0Q2xvbmUgPSBzZWxlY3RlZEVsZW1lbnQuY3JlYXRlVmFyaWFudCgpXG4gICAgc2Vjb25kQ2xvbmUgPSBzZWxlY3RlZEVsZW1lbnQuY3JlYXRlVmFyaWFudCgpXG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZFdpdGgoc2VsZWN0ZWRFbGVtZW50LCBmaXJzdENsb25lKVxuICAgIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuKCkuaW5kZXhPZihmaXJzdENsb25lKVxuICAgIHBhcmVudC5hZGRDaGlsZChzZWNvbmRDbG9uZSwgaW5kZXgrMSlcbiAgICBAc2VsZWN0KG5ldyBNb2RlbC5QYXJ0aWN1bGFyRWxlbWVudChzZWNvbmRDbG9uZSkpXG5cbiAgY3JlYXRlU3ltYm9sRnJvbVNlbGVjdGVkRWxlbWVudDogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50XG4gICAgc2VsZWN0ZWRFbGVtZW50ID0gQHNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQuZWxlbWVudFxuICAgIHBhcmVudCA9IHNlbGVjdGVkRWxlbWVudC5wYXJlbnQoKVxuICAgIHJldHVybiB1bmxlc3MgcGFyZW50XG4gICAgbWFzdGVyID0gc2VsZWN0ZWRFbGVtZW50XG4gICAgdmFyaWFudCA9IHNlbGVjdGVkRWxlbWVudC5jcmVhdGVWYXJpYW50KClcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkV2l0aChzZWxlY3RlZEVsZW1lbnQsIHZhcmlhbnQpXG4gICAgQHNlbGVjdChuZXcgTW9kZWwuUGFydGljdWxhckVsZW1lbnQodmFyaWFudCkpXG4gICAgIyBJbnNlcnQgbWFzdGVyIGludG8gY3JlYXRlUGFuZWxFbGVtZW50cy5cbiAgICBpbmRleCA9IEBjcmVhdGVQYW5lbEVsZW1lbnRzLmluZGV4T2YoQGVkaXRpbmdFbGVtZW50KVxuICAgIEBjcmVhdGVQYW5lbEVsZW1lbnRzLnNwbGljZShpbmRleCwgMCwgbWFzdGVyKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBNZW1vaXplZCBhdHRyaWJ1dGUgc2V0c1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbnRyb2xsZWRBdHRyaWJ1dGVzOiAtPlxuICAgIHJldHVybiBAc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudD8uZWxlbWVudC5jb250cm9sbGVkQXR0cmlidXRlcygpID8gW11cblxuICBpbXBsaWNpdGx5Q29udHJvbGxlZEF0dHJpYnV0ZXM6IC0+XG4gICAgcmV0dXJuIEBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50Py5lbGVtZW50LmltcGxpY2l0bHlDb250cm9sbGVkQXR0cmlidXRlcygpID8gW11cblxuICBjb250cm9sbGFibGVBdHRyaWJ1dGVzOiAtPlxuICAgIHJldHVybiBAc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudD8uZWxlbWVudC5jb250cm9sbGFibGVBdHRyaWJ1dGVzKCkgPyBbXVxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblV0aWwgPSByZXF1aXJlIFwiLi4vVXRpbC9VdGlsXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlcmlhbGl6ZXJcbiAgY29uc3RydWN0b3I6IChidWlsdEluT2JqZWN0cykgLT5cbiAgICBAYnVpbHRJbiA9IHt9XG4gICAgZm9yIG9iamVjdCBpbiBidWlsdEluT2JqZWN0c1xuICAgICAgaWQgPSBVdGlsLmdldElkKG9iamVjdClcbiAgICAgIEBidWlsdEluW2lkXSA9IG9iamVjdFxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBTZXJpYWxpemF0aW9uXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgc2hvdWxkU2VyaWFsaXplUHJvcGVydHk6IChrZXksIHZhbHVlKSAtPlxuICAgICMgV29uJ3Qgc2VyaWFsaXplIGZ1bmN0aW9ucy5cbiAgICByZXR1cm4gZmFsc2UgaWYgXy5pc0Z1bmN0aW9uKHZhbHVlKVxuICAgICMgV29uJ3Qgc2VyaWFsaXplIGEga2V5IHN0YXJ0aW5nIHdpdGggX19cbiAgICByZXR1cm4gZmFsc2UgaWYga2V5LnNsaWNlKDAsIDIpID09IFwiX19cIlxuICAgIHJldHVybiB0cnVlXG5cbiAganNvbmlmeTogKHJvb3RWYWx1ZSkgLT5cbiAgICBvYmplY3RzID0ge30gIyBpZCA6IGpzb25cblxuICAgIGpzb25pZnlWYWx1ZSA9ICh2YWx1ZSkgPT5cbiAgICAgIGlmIF8uaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGpzb25pZnlBcnJheSh2YWx1ZSlcbiAgICAgIGVsc2UgaWYgXy5pc09iamVjdCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZVRvKHZhbHVlKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gdmFsdWVcblxuICAgIGpzb25pZnlBcnJheSA9IChhcnJheSkgPT5cbiAgICAgIHJldHVybiAoanNvbmlmeVZhbHVlKGNoaWxkVmFsdWUpIGZvciBjaGlsZFZhbHVlIGluIGFycmF5KVxuXG4gICAgcmVmZXJlbmNlVG8gPSAob2JqZWN0KSA9PlxuICAgICAgaWQgPSBVdGlsLmdldElkKG9iamVjdClcbiAgICAgIGlmICFAYnVpbHRJbltpZF0gYW5kICFvYmplY3RzW2lkXVxuICAgICAgICAjIFdlJ2xsIG5lZWQgdG8ganNvbmlmeSB0aGUgb2JqZWN0IGFuZCBhZGQgaXQgdG8gb2JqZWN0cy4gRmlyc3QsIHNldCBhXG4gICAgICAgICMgcGxhY2Vob2xkZXIgdmFsdWUgc28gcmVjdXJzaXZlIHJlZmVyZW5jZXMgd29yay5cbiAgICAgICAgb2JqZWN0c1tpZF0gPSBcIlBST0NFU1NJTkdcIlxuICAgICAgICBvYmplY3RzW2lkXSA9IGpzb25pZnlPYmplY3Qob2JqZWN0KVxuICAgICAgcmV0dXJuIHtfX3JlZjogaWR9XG5cbiAgICBqc29uaWZ5T2JqZWN0ID0gKG9iamVjdCkgPT5cbiAgICAgIHJlc3VsdCA9IHt9XG4gICAgICAjIEFubm90YXRlIGtleS92YWx1ZXMuXG4gICAgICBmb3Igb3duIGtleSwgdmFsdWUgb2Ygb2JqZWN0XG4gICAgICAgIGlmIEBzaG91bGRTZXJpYWxpemVQcm9wZXJ0eShrZXksIHZhbHVlKVxuICAgICAgICAgIHJlc3VsdFtrZXldID0ganNvbmlmeVZhbHVlKHZhbHVlKVxuICAgICAgIyBBbm5vdGF0ZSBwcm90b3R5cGUuXG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpXG4gICAgICB1bmxlc3MgcHJvdG8gPT0gT2JqZWN0LnByb3RvdHlwZVxuICAgICAgICByZXN1bHQuX19wcm90byA9IGpzb25pZnlWYWx1ZShwcm90bylcbiAgICAgIHJldHVybiByZXN1bHRcblxuICAgIHJvb3QgPSBqc29uaWZ5VmFsdWUocm9vdFZhbHVlKVxuICAgIHJldHVybiB7b2JqZWN0cywgcm9vdH1cblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgRGVzZXJpYWxpemF0aW9uXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZGVqc29uaWZ5OiAoe29iamVjdHMsIHJvb3R9KSAtPlxuICAgICMgRmlyc3QgY29uc3RydWN0IGFsbCB0aGUgb2JqZWN0cyB3aXRoIGFwcHJvcHJpYXRlIHByb3RvdHlwZSBjaGFpbi5cbiAgICBjb25zdHJ1Y3RlZE9iamVjdHMgPSB7fSAjIGlkIDogb2JqZWN0XG5cbiAgICBjb25zdHJ1Y3RPYmplY3QgPSAoaWQpID0+XG4gICAgICByZXR1cm4gY29uc3RydWN0ZWRPYmplY3RzW2lkXSBpZiBjb25zdHJ1Y3RlZE9iamVjdHNbaWRdP1xuICAgICAgcmV0dXJuIEBidWlsdEluW2lkXSBpZiBAYnVpbHRJbltpZF0/XG4gICAgICBvYmplY3RKc29uID0gb2JqZWN0c1tpZF1cbiAgICAgIHByb3RvUmVmID0gb2JqZWN0SnNvbi5fX3Byb3RvXG4gICAgICBpZiBwcm90b1JlZlxuICAgICAgICBwcm90byA9IGNvbnN0cnVjdE9iamVjdChwcm90b1JlZi5fX3JlZilcbiAgICAgICAgY29uc3RydWN0ZWRPYmplY3QgPSBPYmplY3QuY3JlYXRlKHByb3RvKVxuICAgICAgICBjb25zdHJ1Y3RlZE9iamVjdC5jb25zdHJ1Y3Rvcj8oKVxuICAgICAgZWxzZVxuICAgICAgICBjb25zdHJ1Y3RlZE9iamVjdCA9IHt9XG4gICAgICByZXR1cm4gY29uc3RydWN0ZWRPYmplY3RzW2lkXSA9IGNvbnN0cnVjdGVkT2JqZWN0XG5cbiAgICBmb3Igb3duIGlkLCBvYmplY3Qgb2Ygb2JqZWN0c1xuICAgICAgY29uc3RydWN0T2JqZWN0KGlkKVxuXG4gICAgIyBBc3NpZ24ga2V5L3ZhbHVlcy5cbiAgICBhc3NpZ25LZXlWYWx1ZXMgPSAoaWQsIHNwZWMpID0+XG4gICAgICBjb25zdHJ1Y3RlZE9iamVjdCA9IGNvbnN0cnVjdGVkT2JqZWN0c1tpZF1cbiAgICAgIGZvciBvd24ga2V5LCB2YWx1ZSBvZiBzcGVjXG4gICAgICAgIGNvbnRpbnVlIGlmIGtleSA9PSBcIl9fcHJvdG9cIlxuICAgICAgICBjb25zdHJ1Y3RlZE9iamVjdFtrZXldID0gZGVyZWYodmFsdWUpXG5cbiAgICBkZXJlZiA9ICh2YWx1ZSkgPT5cbiAgICAgIGlmIF8uaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIF8ubWFwIHZhbHVlLCBkZXJlZlxuICAgICAgaWYgXy5pc09iamVjdCh2YWx1ZSlcbiAgICAgICAgaWYgdmFsdWUuX19yZWY/XG4gICAgICAgICAgaWQgPSB2YWx1ZS5fX3JlZlxuICAgICAgICAgIHJldHVybiBAYnVpbHRJbltpZF0gPyBjb25zdHJ1Y3RlZE9iamVjdHNbaWRdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gXy5tYXBPYmplY3QgdmFsdWUsIGRlcmVmXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB2YWx1ZVxuXG4gICAgZm9yIG93biBpZCwgb2JqZWN0IG9mIG9iamVjdHNcbiAgICAgIGFzc2lnbktleVZhbHVlcyhpZCwgb2JqZWN0KVxuXG4gICAgcmV0dXJuIGRlcmVmKHJvb3QpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2UgPSB7fVxuXG5cblN0b3JhZ2UuU2VyaWFsaXplciA9IHJlcXVpcmUgXCIuL1NlcmlhbGl6ZXJcIlxuXG4jIGB0ZXh0YCBzaG91bGQgYmUgYSBzdHJpbmcgb2YgdGV4dCB0aGF0IHNob3VsZCBiZSB3cml0dGVuIHRvIHRoZSBmaWxlLCBgbmFtZWBcbiMgYHRoZSBmaWxlIG5hbWUgKGUuZy4gYFwiaGVsbG8uanNvblwiYCksIGFuZCBgdHlwZWAgdGhlIGNvbnRlbnQgdHlwZSAoZS5nLlxuIyBgYFwiYXBwbGljYXRpb24vanNvblwiYCkuXG5TdG9yYWdlLnNhdmVGaWxlID0gKHRleHQsIG5hbWUsIHR5cGUpIC0+XG4gIGR1bW15TGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpXG4gIGZpbGUgPSBuZXcgQmxvYihbdGV4dF0sIHt0eXBlfSlcbiAgZHVtbXlMaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gIGR1bW15TGluay5kb3dubG9hZCA9IG5hbWVcbiAgZHVtbXlMaW5rLmNsaWNrKClcblxuIyBUaGlzIHdpbGwgcG9wIG9wZW4gdGhlIGZpbGUgb3BlbiBkaWFsb2cgYm94LiBJZiBhIGZpbGUgaXMgbG9hZGVkXG4jIHN1Y2Nlc3NmdWxseSwgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHN0cmluZyB0aGF0IGlzIHRoZSB0ZXh0IG9mIHRoZVxuIyBmaWxlLlxuU3RvcmFnZS5sb2FkRmlsZSA9IChjYWxsYmFjaykgLT5cbiAgZHVtbXlJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKVxuICBkdW1teUlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJmaWxlXCIpXG4gIGR1bW15SW5wdXQuYWRkRXZlbnRMaXN0ZW5lciBcImNoYW5nZVwiLCAoY2hhbmdlRXZlbnQpIC0+XG4gICAgZmlsZXMgPSBkdW1teUlucHV0LmZpbGVzXG4gICAgZmlsZSA9IGZpbGVzWzBdXG4gICAgcmV0dXJuIHVubGVzcyBmaWxlXG4gICAgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5vbmxvYWQgPSAtPlxuICAgICAgY2FsbGJhY2socmVhZGVyLnJlc3VsdClcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuICBkdW1teUlucHV0LmNsaWNrKClcbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWF0cml4XG4gIGNvbnN0cnVjdG9yOiAoQGE9MSwgQGI9MCwgQGM9MCwgQGQ9MSwgQGU9MCwgQGY9MCkgLT5cblxuICB0cmFuc2xhdGU6ICh4LCB5KSAtPlxuICAgIEB0cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeCwgeSlcblxuICBzY2FsZTogKHgsIHkpIC0+XG4gICAgQHRyYW5zZm9ybSh4LCAwLCAwLCB5LCAwLCAwKVxuXG4gIHJvdGF0ZTogKGFuZ2xlKSAtPlxuICAgIGMgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICBzID0gTWF0aC5zaW4oYW5nbGUpXG4gICAgQHRyYW5zZm9ybShjLCBzLCAtcywgYywgMCwgMClcblxuICB0cmFuc2Zvcm06IChhLCBiLCBjLCBkLCBlLCBmKSAtPlxuICAgIG5ldyBNYXRyaXgoXG4gICAgICBAYSAqIGEgKyBAYyAqIGJcbiAgICAgIEBiICogYSArIEBkICogYlxuICAgICAgQGEgKiBjICsgQGMgKiBkXG4gICAgICBAYiAqIGMgKyBAZCAqIGRcbiAgICAgIEBhICogZSArIEBjICogZiArIEBlXG4gICAgICBAYiAqIGUgKyBAZCAqIGYgKyBAZlxuICAgIClcblxuICBjb21wb3NlOiAobSkgLT5cbiAgICBAdHJhbnNmb3JtKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpXG5cbiAgaW52ZXJzZTogLT5cbiAgICByZXR1cm4gQF9pbnZlcnNlIGlmIEBfaW52ZXJzZT9cbiAgICBhZF9taW51c19iYyA9IEBhICogQGQgLSBAYiAqIEBjXG4gICAgYmNfbWludXNfYWQgPSBAYiAqIEBjIC0gQGEgKiBAZFxuICAgIEBfaW52ZXJzZSA9IG5ldyBNYXRyaXgoXG4gICAgICBAZCAvIGFkX21pbnVzX2JjLFxuICAgICAgQGIgLyBiY19taW51c19hZCxcbiAgICAgIEBjIC8gYmNfbWludXNfYWQsXG4gICAgICBAYSAvIGFkX21pbnVzX2JjLFxuICAgICAgKEBkICogQGUgLSBAYyAqIEBmKSAvIGJjX21pbnVzX2FkXG4gICAgICAoQGIgKiBAZSAtIEBhICogQGYpIC8gYWRfbWludXNfYmNcbiAgICApXG5cbiAgZnJvbUxvY2FsOiAoW3gsIHldKSAtPlxuICAgIFtcbiAgICAgIEBhICogeCArIEBjICogeSArIEBlXG4gICAgICBAYiAqIHggKyBAZCAqIHkgKyBAZlxuICAgIF1cblxuICB0b0xvY2FsOiAoW3gsIHldKSAtPlxuICAgIEBpbnZlcnNlKCkuZnJvbUxvY2FsKFt4LCB5XSlcblxuICBvcmlnaW46IC0+XG4gICAgW0BlLCBAZl1cblxuXG4gIHRvU1ZHOiAtPlxuICAgIFwibWF0cml4KCN7QG0uam9pbihcIiBcIil9KVwiXG5cbiAgY2FudmFzU2V0VHJhbnNmb3JtOiAoY3R4KSAtPlxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oQGEsIEBiLCBAYywgQGQsIEBlLCBAZilcblxuICBjYW52YXNUcmFuc2Zvcm06IChjdHgpIC0+XG4gICAgY3R4LnRyYW5zZm9ybShAYSwgQGIsIEBjLCBAZCwgQGUsIEBmKVxuXG5cbk1hdHJpeC5uYXR1cmFsQ29uc3RydWN0ID0gKHgsIHksIHN4LCBzeSwgcm90YXRlKSAtPlxuICBjID0gTWF0aC5jb3Mocm90YXRlKVxuICBzID0gTWF0aC5zaW4ocm90YXRlKVxuICByZXR1cm4gbmV3IE1hdHJpeChcbiAgICBjICogc3hcbiAgICBzICogc3hcbiAgICAtcyAqIHN5XG4gICAgYyAqIHN5XG4gICAgeFxuICAgIHlcbiAgKVxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcbm51bWVyaWMgPSByZXF1aXJlIFwibnVtZXJpY1wiXG5cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsID0ge31cblV0aWwuTWF0cml4ID0gcmVxdWlyZSBcIi4vTWF0cml4XCJcblxuXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4jIERPTVxuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5VdGlsLm1hdGNoZXMgPSAoZWwsIHNlbGVjdG9yKSAtPlxuICBtYXRjaGVzU2VsZWN0b3IgPSBFbGVtZW50Ojp3ZWJraXRNYXRjaGVzU2VsZWN0b3IgPyBFbGVtZW50Ojptb3pNYXRjaGVzU2VsZWN0b3IgPyBFbGVtZW50OjpvTWF0Y2hlc1NlbGVjdG9yXG4gIG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsLCBzZWxlY3RvcilcblxuVXRpbC5jbG9zZXN0ID0gKGVsLCBzZWxlY3RvcikgLT5cbiAgcmV0dXJuIHVuZGVmaW5lZCB1bmxlc3MgZWw/IGFuZCBlbC5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERVxuXG4gIGlmIF8uaXNTdHJpbmcoc2VsZWN0b3IpXG4gICAgZm4gPSAoZWwpIC0+IFV0aWwubWF0Y2hlcyhlbCwgc2VsZWN0b3IpXG4gIGVsc2VcbiAgICBmbiA9IHNlbGVjdG9yXG5cbiAgaWYgZm4oZWwpXG4gICAgcmV0dXJuIGVsXG4gIGVsc2VcbiAgICBwYXJlbnQgPSBlbC5wYXJlbnROb2RlXG4gICAgcmV0dXJuIFV0aWwuY2xvc2VzdChwYXJlbnQsIGZuKVxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgRE9NIEV2ZW50c1xuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5VdGlsLm1vdXNlRG93blByZXZlbnREZWZhdWx0ID0gKGUpIC0+XG4gIGUucHJldmVudERlZmF1bHQoKVxuICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKVxuICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKClcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG5cbiAgIyBVbmZvY3VzIGFueSBmb2N1c2VkIENvZGUgTWlycm9yc1xuICBmb3IgZWwgaW4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5Db2RlTWlycm9yLWZvY3VzZWRcIilcbiAgICBlbC5Db2RlTWlycm9yLmdldElucHV0RmllbGQoKS5ibHVyKClcblxuIyB0ZXh0Rm9jdXMgcmV0dXJucyBhIENvZGVNaXJyb3IgaW5zdGFuY2Ugb3IgYSBjb250ZW50ZWRpdGFibGUgRE9NIGVsZW1lbnRcbiMgdGhhdCBpcyBmb2N1c2VkIG9yIG51bGwgaWYgbm90aGluZyBpcyBmb2N1c2VkLlxuVXRpbC50ZXh0Rm9jdXMgPSAtPlxuICBpZiBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuQ29kZU1pcnJvci1mb2N1c2VkXCIpXG4gICAgcmV0dXJuIGVsLkNvZGVNaXJyb3JcbiAgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudD8uaXNDb250ZW50RWRpdGFibGVcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICByZXR1cm4gbnVsbFxuXG5VdGlsLmNsZWFyVGV4dEZvY3VzID0gLT5cbiAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKClcbiAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpXG4gIGRvY3VtZW50LmJvZHkuZm9jdXMoKVxuXG4gICMgVW5mb2N1cyBhbnkgZm9jdXNlZCBDb2RlIE1pcnJvcnNcbiAgZm9yIGVsIGluIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuQ29kZU1pcnJvci1mb2N1c2VkXCIpXG4gICAgZWwuQ29kZU1pcnJvci5nZXRJbnB1dEZpZWxkKCkuYmx1cigpXG5cblxuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIyBJRHNcbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuVXRpbC5nZXRJZCA9IChvYmplY3QpIC0+XG4gIHJldHVybiBvYmplY3QuaWQgaWYgb2JqZWN0Lmhhc093blByb3BlcnR5KFwiaWRcIilcbiAgcmV0dXJuIFV0aWwuYXNzaWduSWQob2JqZWN0LCBVdGlsLmdlbmVyYXRlSWQoKSlcblxuVXRpbC5hc3NpZ25JZCA9IChvYmplY3QsIGlkKSAtPlxuICByZXR1cm4gb2JqZWN0LmlkID0gaWRcblxuY291bnRlciA9IDBcblV0aWwuZ2VuZXJhdGVJZCA9IC0+XG4gIHJldHVybiBcImlkXCIgK1xuICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA2KSArXG4gICAgRGF0ZS5ub3coKS50b1N0cmluZygzNikgK1xuICAgIChjb3VudGVyKyspLnRvU3RyaW5nKDM2KVxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgTnVtZXJpY1xuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5VdGlsLnF1YWRyYW5jZSA9IChwMSwgcDIpIC0+XG4gIGQgPSBudW1lcmljWyctJ10ocDEsIHAyKVxuICBudW1lcmljLmRvdChkLCBkKVxuXG5VdGlsLnNvbHZlID0gKG9iamVjdGl2ZSwgc3RhcnRBcmdzKSAtPlxuICB1bmNtaW4gPSBudW1lcmljLnVuY21pbihvYmplY3RpdmUsIHN0YXJ0QXJncylcbiAgaWYgaXNOYU4odW5jbWluLmYpXG4gICAgY29uc29sZS53YXJuIFwiTmFOXCJcbiAgICByZXR1cm4gc3RhcnRBcmdzXG4gIGVsc2VcbiAgICBzb2x1dGlvbiA9IHVuY21pbi5zb2x1dGlvblxuICAgIHJldHVybiBzb2x1dGlvblxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgUHJlY2lzaW9uXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblV0aWwucHJlY2lzaW9uID0gKHgpIC0+XG4gIHggPSBcIlwiK3hcbiAgIyBUT0RPOiBEZWFsIHdpdGggZUUgc3R1ZmYuXG4gIGRlY2ltYWxJbmRleCA9IHguaW5kZXhPZihcIi5cIilcbiAgcmV0dXJuIDAgaWYgZGVjaW1hbEluZGV4ID09IC0xXG4gIHJldHVybiB4Lmxlbmd0aCAtIGRlY2ltYWxJbmRleCAtIDFcblxuVXRpbC50b1ByZWNpc2lvbiA9ICh4LCBwcmVjaXNpb24pIC0+XG4gIHggPSBVdGlsLnJvdW5kVG9QcmVjaXNpb24oeCwgcHJlY2lzaW9uKVxuICByZXR1cm4geC50b0ZpeGVkKHByZWNpc2lvbilcblxuVXRpbC50b01heFByZWNpc2lvbiA9ICh4LCBwcmVjaXNpb24pIC0+XG4gIHggPSBVdGlsLnRvUHJlY2lzaW9uKHgsIHByZWNpc2lvbilcbiAgaWYgeC5pbmRleE9mKFwiLlwiKVxuICAgIHggPSB4LnJlcGxhY2UoL1xcLj8wKyQvLCBcIlwiKVxuICByZXR1cm4geFxuXG5VdGlsLnJvdW5kVG9QcmVjaXNpb24gPSAoeCwgcHJlY2lzaW9uKSAtPlxuICBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbilcbiAgeCA9IE1hdGgucm91bmQoeCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllclxuICByZXR1cm4geFxuXG5cbiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiMgU3RyaW5nXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiMgc3RyaW5nTWF0Y2hJbmRpY2VzIHNlYXJjaGVzIGhheXN0YWNrIHN0cmluZyBmb3IgdGhlIG5lZWRsZSBzdHJpbmcgYW5kXG4jIHJldHVybnMgYWxsIG9mIHRoZSBpbmRpY2VzIHdoZXJlIGl0J3MgZm91bmQuXG5VdGlsLnN0cmluZ01hdGNoSW5kaWNlcyA9IChoYXlzdGFjaywgbmVlZGxlKSAtPlxuICBpbmRpY2VzID0gW11cbiAgY3Vyc29yID0gLTFcbiAgd2hpbGUgdHJ1ZVxuICAgIGN1cnNvciA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBjdXJzb3IrMSlcbiAgICBicmVhayBpZiBjdXJzb3IgPT0gLTFcbiAgICBpbmRpY2VzLnB1c2goY3Vyc29yKVxuICByZXR1cm4gaW5kaWNlc1xuXG4jIENvZGVNaXJyb3IgbGlrZXMgd29ya2luZyB3aXRoIHtsaW5lLCBjaH0gb2JqZWN0cyBidXQgc29tZXRpbWVzIGl0J3MgZWFzaWVyXG4jIHRvIHdvcmsgd2l0aCBqdXN0IGEgc3RyYWlnaHQgY2hhcmFjdGVyIGluZGV4LiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGFcbiMgY2hhcmFjdGVyIGluZGV4IHRvIGEge2xpbmUsIGNofSBieSBjb3VudGluZyBuZXcgbGluZXMgaW4gdGhlIHN0cmluZy5cblV0aWwuY2hhclRvTGluZUNoID0gKHN0cmluZywgY2hhcikgLT5cbiAgc3RyaW5nVXBUb0NoYXIgPSBzdHJpbmcuc3Vic3RyKDAsIGNoYXIpXG4gIGxpbmVzID0gc3RyaW5nVXBUb0NoYXIuc3BsaXQoXCJcXG5cIilcbiAgcmV0dXJuIHtsaW5lOiBsaW5lcy5sZW5ndGgtMSwgY2g6IF8ubGFzdChsaW5lcykubGVuZ3RofVxuXG5VdGlsLmlzTnVtYmVyU3RyaW5nID0gKHN0cmluZykgLT5cbiAgcmV0dXJuIC9eWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/JC8udGVzdChzdHJpbmcpXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuUiA9IHJlcXVpcmUgXCIuL1JcIlxuTW9kZWwgPSByZXF1aXJlIFwiLi4vTW9kZWwvTW9kZWxcIlxuVXRpbCA9IHJlcXVpcmUgXCIuLi9VdGlsL1V0aWxcIlxuXG5cblIuY3JlYXRlIFwiQXR0cmlidXRlUm93XCIsXG4gIHByb3BUeXBlczpcbiAgICBhdHRyaWJ1dGU6IE1vZGVsLkF0dHJpYnV0ZVxuXG4gIGNvbnRleHRUeXBlczpcbiAgICBwcm9qZWN0OiBNb2RlbC5Qcm9qZWN0XG4gICAgaG92ZXJNYW5hZ2VyOiBSLkhvdmVyTWFuYWdlclxuXG4gIHJlbmRlcjogLT5cbiAgICBhdHRyaWJ1dGUgPSBAcHJvcHMuYXR0cmlidXRlXG5cbiAgICBSLmRpdiB7Y2xhc3NOYW1lOiBSLmN4IHtcbiAgICAgIEF0dHJpYnV0ZVJvdzogdHJ1ZVxuICAgICAgaXNJbmhlcml0ZWQ6ICFhdHRyaWJ1dGUuaXNOb3ZlbCgpXG4gICAgICBpc1dyYXBwZWQ6IEBfaXNXcmFwcGVkKClcbiAgICAgIGlzR29pbmdUb0NoYW5nZTogQF9pc0dvaW5nVG9DaGFuZ2UoKVxuICAgIH19LFxuICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJBdHRyaWJ1dGVSb3dDb250cm9sXCJ9LFxuICAgICAgICBSLmRpdiB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBSLmN4IHtcbiAgICAgICAgICAgIEF0dHJpYnV0ZUNvbnRyb2w6IHRydWVcbiAgICAgICAgICAgIEludGVyYWN0aXZlOiB0cnVlXG4gICAgICAgICAgICBpc0NvbnRyb2xsYWJsZTogQF9pc0NvbnRyb2xsYWJsZSgpXG4gICAgICAgICAgICBpc0NvbnRyb2xsZWQ6IEBfaXNDb250cm9sbGVkKClcbiAgICAgICAgICAgIGlzSW1wbGljaXRseUNvbnRyb2xsZWQ6IEBfaXNJbXBsaWNpdHlDb250cm9sbGVkKClcbiAgICAgICAgICB9XG4gICAgICAgICAgb25DbGljazogQF90b2dnbGVDb250cm9sXG4gICAgICAgIH1cbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQXR0cmlidXRlUm93TGFiZWxcIn0sXG4gICAgICAgIFIuQXR0cmlidXRlTGFiZWwge2F0dHJpYnV0ZX1cbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQXR0cmlidXRlUm93RXhwcmVzc2lvblwifSxcbiAgICAgICAgUi5FeHByZXNzaW9uIHthdHRyaWJ1dGV9XG5cbiAgX2lzV3JhcHBlZDogLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHJldHVybiBhdHRyaWJ1dGUuZXhwclN0cmluZy5pbmRleE9mKFwiXFxuXCIpICE9IC0xXG5cbiAgX2lzR29pbmdUb0NoYW5nZTogLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHtob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcbiAgICByZXR1cm4gXy5jb250YWlucyhob3Zlck1hbmFnZXIuYXR0cmlidXRlc1RvQ2hhbmdlLCBhdHRyaWJ1dGUpXG5cbiAgX3NlbGVjdGVkRWxlbWVudDogLT5cbiAgICB7cHJvamVjdH0gPSBAY29udGV4dFxuICAgIHJldHVybiBzZWxlY3RlZEVsZW1lbnQgPSBwcm9qZWN0LnNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQ/LmVsZW1lbnRcblxuICBfaXNDb250cm9sbGVkOiAtPlxuICAgIHJldHVybiBfLmNvbnRhaW5zKEBjb250ZXh0LnByb2plY3QuY29udHJvbGxlZEF0dHJpYnV0ZXMoKSwgQHByb3BzLmF0dHJpYnV0ZSlcblxuICBfaXNJbXBsaWNpdHlDb250cm9sbGVkOiAtPlxuICAgIHJldHVybiBfLmNvbnRhaW5zKEBjb250ZXh0LnByb2plY3QuaW1wbGljaXRseUNvbnRyb2xsZWRBdHRyaWJ1dGVzKCksIEBwcm9wcy5hdHRyaWJ1dGUpXG5cbiAgX2lzQ29udHJvbGxhYmxlOiAtPlxuICAgIHJldHVybiBfLmNvbnRhaW5zKEBjb250ZXh0LnByb2plY3QuY29udHJvbGxhYmxlQXR0cmlidXRlcygpLCBAcHJvcHMuYXR0cmlidXRlKVxuXG4gIF90b2dnbGVDb250cm9sOiAtPlxuICAgIHthdHRyaWJ1dGV9ID0gQHByb3BzXG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcbiAgICBzZWxlY3RlZEVsZW1lbnQgPSBwcm9qZWN0LnNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQ/LmVsZW1lbnRcbiAgICByZXR1cm4gdW5sZXNzIHNlbGVjdGVkRWxlbWVudFxuICAgIGlmIEBfaXNDb250cm9sbGVkKClcbiAgICAgIHNlbGVjdGVkRWxlbWVudC5yZW1vdmVDb250cm9sbGVkQXR0cmlidXRlKGF0dHJpYnV0ZSlcbiAgICBlbHNlXG4gICAgICBzZWxlY3RlZEVsZW1lbnQuYWRkQ29udHJvbGxlZEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG5cblxuUi5jcmVhdGUgXCJBdHRyaWJ1dGVMYWJlbFwiLFxuICBwcm9wVHlwZXM6XG4gICAgYXR0cmlidXRlOiBNb2RlbC5BdHRyaWJ1dGVcblxuICBjb250ZXh0VHlwZXM6XG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcbiAgICBob3Zlck1hbmFnZXI6IFIuSG92ZXJNYW5hZ2VyXG5cbiAgbWl4aW5zOiBbUi5Bbm5vdGF0ZU1peGluXVxuXG4gIHJlbmRlcjogLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHtob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcblxuICAgIFIuZGl2IHtcbiAgICAgIGNsYXNzTmFtZTogUi5jeCB7XG4gICAgICAgIEF0dHJpYnV0ZUxhYmVsOiB0cnVlXG4gICAgICAgIEludGVyYWN0aXZlOiB0cnVlXG4gICAgICAgIGlzSG92ZXJlZDogaG92ZXJNYW5hZ2VyLmhvdmVyZWRBdHRyaWJ1dGUgPT0gYXR0cmlidXRlXG4gICAgICAgIGlzR29pbmdUb0NoYW5nZTogXy5jb250YWlucyhob3Zlck1hbmFnZXIuYXR0cmlidXRlc1RvQ2hhbmdlLCBhdHRyaWJ1dGUpXG4gICAgICB9XG4gICAgICBvbk1vdXNlRG93bjogQF9vbk1vdXNlRG93blxuICAgICAgb25Nb3VzZUVudGVyOiBAX29uTW91c2VFbnRlclxuICAgICAgb25Nb3VzZUxlYXZlOiBAX29uTW91c2VMZWF2ZVxuICAgIH0sXG4gICAgICBSLkVkaXRhYmxlVGV4dCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJFZGl0YWJsZVRleHRJbmxpbmUgSW50ZXJhY3RpdmVcIlxuICAgICAgICB2YWx1ZTogYXR0cmlidXRlLmxhYmVsXG4gICAgICAgIHNldFZhbHVlOiAobmV3VmFsdWUpIC0+XG4gICAgICAgICAgYXR0cmlidXRlLmxhYmVsID0gbmV3VmFsdWVcbiAgICAgIH1cblxuICBhbm5vdGF0aW9uOiAtPlxuICAgICMgRm9yIGF1dG9jb21wbGV0ZSB0byBmaW5kIGFsbCB0aGUgYXR0cmlidXRlcyBvbiB0aGUgc2NyZWVuLlxuICAgIHthdHRyaWJ1dGU6IEBwcm9wcy5hdHRyaWJ1dGV9XG5cbiAgX29uTW91c2VEb3duOiAobW91c2VEb3duRXZlbnQpIC0+XG4gICAgcmV0dXJuIGlmIFV0aWwuY2xvc2VzdChtb3VzZURvd25FdmVudC50YXJnZXQsIFwiLkVkaXRhYmxlVGV4dElubGluZVwiKVxuXG4gICAge2F0dHJpYnV0ZX0gPSBAcHJvcHNcbiAgICB7ZHJhZ01hbmFnZXIsIGhvdmVyTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIG1vdXNlRG93bkV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBkcmFnTWFuYWdlci5zdGFydCBtb3VzZURvd25FdmVudCxcbiAgICAgIHR5cGU6IFwidHJhbnNjbHVkZUF0dHJpYnV0ZVwiXG4gICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZVxuICAgICAgeDogbW91c2VEb3duRXZlbnQuY2xpZW50WFxuICAgICAgeTogbW91c2VEb3duRXZlbnQuY2xpZW50WVxuICAgICAgb25Nb3ZlOiAobW91c2VNb3ZlRXZlbnQpIC0+XG4gICAgICAgIGRyYWdNYW5hZ2VyLmRyYWcueCA9IG1vdXNlTW92ZUV2ZW50LmNsaWVudFhcbiAgICAgICAgZHJhZ01hbmFnZXIuZHJhZy55ID0gbW91c2VNb3ZlRXZlbnQuY2xpZW50WVxuICAgICAgb25Ecm9wOiAtPlxuICAgICAgICBob3Zlck1hbmFnZXIuaG92ZXJlZEF0dHJpYnV0ZSA9IG51bGxcbiAgICAgICMgY3Vyc29yXG4gICAgICBvbkNhbmNlbDogPT5cbiAgICAgICAgQF90cmFuc2NsdWRlSW50b0ZvY3VzZWRFeHByZXNzaW9uKClcblxuICBfdHJhbnNjbHVkZUludG9Gb2N1c2VkRXhwcmVzc2lvbjogLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIGZvY3VzZWRDb2RlTWlycm9yRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLkNvZGVNaXJyb3ItZm9jdXNlZFwiKVxuICAgIHJldHVybiB1bmxlc3MgZm9jdXNlZENvZGVNaXJyb3JFbFxuICAgIGV4cHJlc3Npb25Db2RlRWwgPSBVdGlsLmNsb3Nlc3QoZm9jdXNlZENvZGVNaXJyb3JFbCwgXCIuRXhwcmVzc2lvbkNvZGVcIilcbiAgICBleHByZXNzaW9uQ29kZSA9IGV4cHJlc3Npb25Db2RlRWwuYW5ub3RhdGlvbi5jb21wb25lbnRcbiAgICBleHByZXNzaW9uQ29kZS50cmFuc2NsdWRlQXR0cmlidXRlKGF0dHJpYnV0ZSlcblxuICBfb25Nb3VzZUVudGVyOiAoZSkgLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHtkcmFnTWFuYWdlciwgaG92ZXJNYW5hZ2VyfSA9IEBjb250ZXh0XG4gICAgcmV0dXJuIGlmIGRyYWdNYW5hZ2VyLmRyYWc/XG4gICAgaG92ZXJNYW5hZ2VyLmhvdmVyZWRBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVcblxuICBfb25Nb3VzZUxlYXZlOiAoZSkgLT5cbiAgICB7ZHJhZ01hbmFnZXIsIGhvdmVyTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIHJldHVybiBpZiBkcmFnTWFuYWdlci5kcmFnP1xuICAgIGhvdmVyTWFuYWdlci5ob3ZlcmVkQXR0cmlidXRlID0gbnVsbFxuXG5cblIuY3JlYXRlIFwiQXR0cmlidXRlVG9rZW5cIixcbiAgcHJvcFR5cGVzOlxuICAgIGF0dHJpYnV0ZTogTW9kZWwuQXR0cmlidXRlXG4gICAgY29udGV4dEVsZW1lbnQ6IFwiYW55XCIgIyBUT0RPOiBzaG91bGQgYmUgTW9kZWwuRWxlbWVudCBvciBudWxsXG5cbiAgY29udGV4dFR5cGVzOlxuICAgIGRyYWdNYW5hZ2VyOiBSLkRyYWdNYW5hZ2VyXG4gICAgaG92ZXJNYW5hZ2VyOiBSLkhvdmVyTWFuYWdlclxuXG4gIHJlbmRlcjogLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHtob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcblxuICAgIFIuc3BhbiB7XG4gICAgICBjbGFzc05hbWU6IFIuY3gge1xuICAgICAgICBSZWZlcmVuY2VUb2tlbjogdHJ1ZVxuICAgICAgICBpc0hvdmVyZWQ6IGhvdmVyTWFuYWdlci5ob3ZlcmVkQXR0cmlidXRlID09IGF0dHJpYnV0ZVxuICAgICAgICBpc0dvaW5nVG9DaGFuZ2U6IF8uY29udGFpbnMoaG92ZXJNYW5hZ2VyLmF0dHJpYnV0ZXNUb0NoYW5nZSwgYXR0cmlidXRlKVxuICAgICAgfVxuICAgICAgb25Nb3VzZUVudGVyOiBAX29uTW91c2VFbnRlclxuICAgICAgb25Nb3VzZUxlYXZlOiBAX29uTW91c2VMZWF2ZVxuICAgIH0sXG4gICAgICBAX2xhYmVsKClcblxuICBfbGFiZWw6IC0+XG4gICAge2F0dHJpYnV0ZSwgY29udGV4dEVsZW1lbnR9ID0gQHByb3BzXG4gICAgcGFyZW50RWxlbWVudCA9IGF0dHJpYnV0ZS5wYXJlbnRFbGVtZW50KClcbiAgICBpZiBjb250ZXh0RWxlbWVudFxuICAgICAgaXNTYW1lQ29udGV4dCA9IHBhcmVudEVsZW1lbnQuaXNBbmNlc3Rvck9mKGNvbnRleHRFbGVtZW50KVxuICAgIGVsc2VcbiAgICAgIGlzU2FtZUNvbnRleHQgPSBmYWxzZVxuICAgIGlmIGlzU2FtZUNvbnRleHRcbiAgICAgIHJldHVybiBhdHRyaWJ1dGUubGFiZWxcbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCIje3BhcmVudEVsZW1lbnQubGFiZWx94oCZcyAje2F0dHJpYnV0ZS5sYWJlbH1cIlxuXG4gIF9vbk1vdXNlRW50ZXI6IChlKSAtPlxuICAgIHthdHRyaWJ1dGV9ID0gQHByb3BzXG4gICAge2RyYWdNYW5hZ2VyLCBob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcbiAgICByZXR1cm4gaWYgZHJhZ01hbmFnZXIuZHJhZz9cbiAgICBob3Zlck1hbmFnZXIuaG92ZXJlZEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZVxuXG4gIF9vbk1vdXNlTGVhdmU6IChlKSAtPlxuICAgIHtkcmFnTWFuYWdlciwgaG92ZXJNYW5hZ2VyfSA9IEBjb250ZXh0XG4gICAgcmV0dXJuIGlmIGRyYWdNYW5hZ2VyLmRyYWc/XG4gICAgaG92ZXJNYW5hZ2VyLmhvdmVyZWRBdHRyaWJ1dGUgPSBudWxsXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5udW1lcmljID0gcmVxdWlyZSBcIm51bWVyaWNcIlxua2V5ID0gcmVxdWlyZSBcImtleW1hc3RlclwiXG5SID0gcmVxdWlyZSBcIi4vUlwiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuLi9Nb2RlbC9Nb2RlbFwiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxuUi5jcmVhdGUgXCJDYW52YXNcIixcbiAgY29udGV4dFR5cGVzOlxuICAgIHByb2plY3Q6IE1vZGVsLlByb2plY3RcbiAgICBob3Zlck1hbmFnZXI6IFIuSG92ZXJNYW5hZ2VyXG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcblxuICByZW5kZXI6IC0+XG4gICAgUi5kaXYge1xuICAgICAgY2xhc3NOYW1lOiBcIkNhbnZhc1wiXG4gICAgICAjIHN0eWxlOlxuICAgICAgIyAgIGN1cnNvcjogQF9jdXJzb3IoKVxuICAgICAgb25Nb3VzZURvd246IEBfb25Nb3VzZURvd25cbiAgICAgIG9uTW91c2VFbnRlcjogQF9vbk1vdXNlRW50ZXJcbiAgICAgIG9uTW91c2VMZWF2ZTogQF9vbk1vdXNlTGVhdmVcbiAgICAgIG9uTW91c2VNb3ZlOiBAX29uTW91c2VNb3ZlXG4gICAgICBvbldoZWVsOiBAX29uV2hlZWxcbiAgICB9LFxuICAgICAgUi5IVE1MQ2FudmFzIHtcbiAgICAgICAgcmVmOiBcIkhUTUxDYW52YXNcIlxuICAgICAgICBkcmF3OiBAX2RyYXdcbiAgICAgIH1cblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBcInJlc2l6ZVwiLCBAX29uUmVzaXplXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBEcmF3aW5nXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX2RyYXc6IChjdHgpIC0+XG4gICAge3Byb2plY3QsIGhvdmVyTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIHZpZXdNYXRyaXggPSBAX3ZpZXdNYXRyaXgoKVxuXG4gICAgaGlnaGxpZ2h0ID0gKGdyYXBoaWMpIC0+XG4gICAgICBwYXJ0aWN1bGFyRWxlbWVudCA9IGdyYXBoaWMucGFydGljdWxhckVsZW1lbnRcbiAgICAgIGlmIGhvdmVyTWFuYWdlci5jb250cm9sbGVyUGFydGljdWxhckVsZW1lbnQ/LmlzQW5jZXN0b3JPZihwYXJ0aWN1bGFyRWxlbWVudClcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogXCIjYzAwXCIsIGxpbmVXaWR0aDogMi41fVxuICAgICAgaWYgcHJvamVjdC5zZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50Py5pc0FuY2VzdG9yT2YocGFydGljdWxhckVsZW1lbnQpXG4gICAgICAgIHJldHVybiB7Y29sb3I6IFwiIzA5Y1wiLCBsaW5lV2lkdGg6IDIuNX1cbiAgICAgIGlmIGhvdmVyTWFuYWdlci5ob3ZlcmVkUGFydGljdWxhckVsZW1lbnQ/LmlzQW5jZXN0b3JPZihwYXJ0aWN1bGFyRWxlbWVudClcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogXCIjMGM5XCIsIGxpbmVXaWR0aDogMi41fVxuXG4gICAgcmVuZGVyT3B0cyA9IHtjdHgsIHZpZXdNYXRyaXgsIGhpZ2hsaWdodH1cblxuICAgICMgSEFDSzogVGhpcyBmZWF0dXJlIHNob3VsZCBleGlzdCBidXQgdGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBzZXRcbiAgICAjIGlzR3JpZEhpZGRlbiBpbiB0aGUgVUkgKHlvdSBjYW4gb25seSBzZXQgaXQgaW4gdGhlIGNvbnNvbGUuLi4pXG4gICAgdW5sZXNzIEBfZWRpdGluZ0VsZW1lbnQoKS5pc0dyaWRIaWRkZW5cbiAgICAgIEBfZHJhd0JhY2tncm91bmRHcmlkKGN0eClcblxuICAgIGZvciBncmFwaGljIGluIEBfZ3JhcGhpY3MoKVxuICAgICAgZ3JhcGhpYy5yZW5kZXIocmVuZGVyT3B0cylcblxuICAgIEBfZHJhd0NvbnRyb2xQb2ludHMoY3R4KVxuXG4gIF9kcmF3Q29udHJvbFBvaW50czogKGN0eCkgLT5cbiAgICB7aG92ZXJNYW5hZ2VyfSA9IEBjb250ZXh0XG4gICAgZm9yIGNvbnRyb2xQb2ludCBpbiBAX2NvbnRyb2xQb2ludHMoKVxuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICBbeCwgeV0gPSBjb250cm9sUG9pbnQucG9pbnRcbiAgICAgIGN0eC5hcmMoeCwgeSwgQF9jb250cm9sUG9pbnRSYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSlcblxuICAgICAgY29sb3IgPSBcIiMwOWNcIlxuICAgICAgaWYgY29udHJvbFBvaW50LmF0dHJpYnV0ZXNUb0NoYW5nZS5sZW5ndGggPiAwXG4gICAgICAgIGlmIF8uaW50ZXJzZWN0aW9uKGNvbnRyb2xQb2ludC5hdHRyaWJ1dGVzVG9DaGFuZ2UsIGhvdmVyTWFuYWdlci5hdHRyaWJ1dGVzVG9DaGFuZ2UpLmxlbmd0aCA+IDBcbiAgICAgICAgICBjb2xvciA9IFwiI2MwMFwiXG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBpZiBjb250cm9sUG9pbnQuZmlsbGVkIHRoZW4gY29sb3IgZWxzZSBcIiNmZmZcIlxuICAgICAgY3R4LmZpbGwoKVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3JcbiAgICAgIGN0eC5zdHJva2UoKVxuXG4gIF9kcmF3QmFja2dyb3VuZEdyaWQ6IChjdHgpIC0+XG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcblxuICAgIG1hdHJpeCA9IHByb2plY3Quc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudD8uY29udGV4dE1hdHJpeCgpXG4gICAgbWF0cml4ID89IG5ldyBVdGlsLk1hdHJpeCgpXG5cbiAgICBtYXRyaXggPSBAX3ZpZXdNYXRyaXgoKS5jb21wb3NlKG1hdHJpeClcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBtYXRyaXguY2FudmFzVHJhbnNmb3JtKGN0eClcblxuICAgIGZvciB4IGluIFstMTAgLi4gMTBdXG4gICAgICBjdHgubW92ZVRvKHgsIC0xMClcbiAgICAgIGN0eC5saW5lVG8oeCwgIDEwKVxuICAgIGZvciB5IGluIFstMTAgLi4gMTBdXG4gICAgICBjdHgubW92ZVRvKC0xMCwgeSlcbiAgICAgIGN0eC5saW5lVG8oIDEwLCB5KVxuXG4gICAgY3R4LnJlc3RvcmUoKVxuXG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2VlZVwiXG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNVxuICAgIGN0eC5zdHJva2UoKVxuICAgIGN0eC5yZXN0b3JlKClcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBtYXRyaXguY2FudmFzVHJhbnNmb3JtKGN0eClcblxuICAgIGN0eC5tb3ZlVG8oLTEwLCAwKVxuICAgIGN0eC5saW5lVG8oIDEwLCAwKVxuICAgIGN0eC5tb3ZlVG8oMCwgLTEwKVxuICAgIGN0eC5saW5lVG8oMCwgIDEwKVxuICAgIGN0eC5yZXN0b3JlKClcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNjY2NcIlxuICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LnJlc3RvcmUoKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBDb250cm9sIFBvaW50c1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICMgTm90ZTogY29udHJvbCBwb2ludHMgYXJlIG5vdCB0byBiZSBjb25mdXNlZCB3aXRoIGNvbnRyb2xsZXJzLiBIb3dldmVyLCBpblxuICAjIGEgZnV0dXJlIGl0ZXJhdGlvbiBJIHdvdWxkIGxpa2UgdG8gdW5pZnkgdGhlc2UsIHNvIHRoYXQgY29udHJvbCBwb2ludHNcbiAgIyByZWFsbHkgKmFyZSogY29udHJvbGxlcnMuIFRoaXMgd291bGQgYWxsb3cgbW9yZSBmbGV4aWJsZSBjb250cm9sIHBvaW50cyB0b1xuICAjIGJlIGRldmVsb3BlZCwgZm9yIGV4YW1wbGUgZm9yIG1hbmlwdWxhdGluZyBiZXppZXJzIG9yIGZvciBjcmVhdGluZyBjdXN0b21cbiAgIyBjb250cm9sIHBvaW50cyBmb3IgY2VydGFpbiBlbGVtZW50cy5cblxuICBfY29udHJvbFBvaW50UmFkaXVzOiA1XG5cbiAgX2NvbnRyb2xQb2ludHM6IC0+XG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcbiAgICBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50ID0gcHJvamVjdC5zZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50XG4gICAgcmV0dXJuIFtdIHVubGVzcyBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50XG5cbiAgICBtYXRyaXggPSBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50LmFjY3VtdWxhdGVkTWF0cml4KClcbiAgICBtYXRyaXggPSBAX3ZpZXdNYXRyaXgoKS5jb21wb3NlKG1hdHJpeClcblxuICAgIGNvbnRyb2xQb2ludHMgPSBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50LmVsZW1lbnQuY29udHJvbFBvaW50cygpXG4gICAgZm9yIGNvbnRyb2xQb2ludCBpbiBjb250cm9sUG9pbnRzXG4gICAgICBjb250cm9sUG9pbnQucG9pbnQgPSBtYXRyaXguZnJvbUxvY2FsKGNvbnRyb2xQb2ludC5wb2ludClcblxuICAgIHJldHVybiBjb250cm9sUG9pbnRzXG5cbiAgX2hpdERldGVjdENvbnRyb2xQb2ludDogKG1vdXNlRXZlbnQpIC0+XG4gICAgbW91c2VQaXhlbCA9IEBfbW91c2VQb3NpdGlvbihtb3VzZUV2ZW50KVxuICAgIGNvbnRyb2xQb2ludHMgPSBAX2NvbnRyb2xQb2ludHMoKVxuICAgIHF1YWRyYW5jZSA9IEBfY29udHJvbFBvaW50UmFkaXVzICogQF9jb250cm9sUG9pbnRSYWRpdXNcbiAgICBmb3IgY29udHJvbFBvaW50IGluIGNvbnRyb2xQb2ludHNcbiAgICAgIGlmIFV0aWwucXVhZHJhbmNlKG1vdXNlUGl4ZWwsIGNvbnRyb2xQb2ludC5wb2ludCkgPD0gcXVhZHJhbmNlXG4gICAgICAgIHJldHVybiBjb250cm9sUG9pbnRcbiAgICByZXR1cm4gbnVsbFxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBFdmVudCBMb2dpY1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF9vbk1vdXNlRG93bjogKG1vdXNlRXZlbnQpIC0+XG4gICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgVXRpbC5jbGVhclRleHRGb2N1cygpXG5cbiAgICBpc0RvdWJsZUNsaWNrID0gQF9pc0RvdWJsZUNsaWNrKClcbiAgICBAX3VwZGF0ZVNlbGVjdGVkKG1vdXNlRXZlbnQsIGlzRG91YmxlQ2xpY2spXG4gICAgQF91cGRhdGVIb3ZlckFuZEN1cnNvcihtb3VzZUV2ZW50KVxuICAgIEBfc3RhcnRBcHByb3ByaWF0ZURyYWcobW91c2VFdmVudClcblxuICBfb25Nb3VzZU1vdmU6IChtb3VzZUV2ZW50KSAtPlxuICAgIGRyYWdNYW5hZ2VyID0gQGNvbnRleHQuZHJhZ01hbmFnZXJcbiAgICBpZiAhZHJhZ01hbmFnZXIuZHJhZ1xuICAgICAgQF91cGRhdGVIb3ZlckFuZEN1cnNvcihtb3VzZUV2ZW50KVxuXG4gIF9vbk1vdXNlRW50ZXI6IChtb3VzZUV2ZW50KSAtPlxuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIHJldHVybiB1bmxlc3MgZHJhZ01hbmFnZXIuZHJhZz8udHlwZSA9PSBcImNyZWF0ZUVsZW1lbnRcIlxuXG4gICAgZWxlbWVudCA9IGRyYWdNYW5hZ2VyLmRyYWcuZWxlbWVudFxuICAgIEBfY3JlYXRlRWxlbWVudChtb3VzZUV2ZW50LCBlbGVtZW50KVxuXG4gIF9vbk1vdXNlTGVhdmU6IChtb3VzZUV2ZW50KSAtPlxuICAgICMgVE9ET1xuXG4gIF9vbldoZWVsOiAod2hlZWxFdmVudCkgLT5cbiAgICB3aGVlbEV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBAX3pvb20od2hlZWxFdmVudClcblxuICBfaXNEb3VibGVDbGljazogLT5cbiAgICBkb3VibGVDbGlja1RocmVzaG9sZCA9IDQwMFxuICAgIEBfbGFzdE1vdXNlRG93blRpbWUgPz0gMFxuICAgIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGlzRG91YmxlQ2xpY2sgPSAoY3VycmVudFRpbWUgLSBAX2xhc3RNb3VzZURvd25UaW1lIDwgZG91YmxlQ2xpY2tUaHJlc2hvbGQpXG4gICAgQF9sYXN0TW91c2VEb3duVGltZSA9IGN1cnJlbnRUaW1lXG4gICAgcmV0dXJuIGlzRG91YmxlQ2xpY2tcblxuICBfb25SZXNpemU6IC0+XG4gICAgQHJlZnMuSFRNTENhbnZhcy5yZXNpemUoKVxuICAgIEBfcmVjdENhY2hlZCA9IG51bGxcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgSG92ZXIgYW5kIFNlbGVjdGlvblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF9pbnRlbnQ6IChtb3VzZUV2ZW50KSAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAgc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudCA9IHByb2plY3Quc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudFxuXG4gICAgaGl0cyA9IEBfaGl0RGV0ZWN0KG1vdXNlRXZlbnQpXG5cbiAgICBjb250cm9sUG9pbnQgPSBAX2hpdERldGVjdENvbnRyb2xQb2ludChtb3VzZUV2ZW50KVxuXG4gICAgIyBXaGF0IHRvIGNvbnRyb2wuXG4gICAgY29udHJvbGxlciA9IGRvIC0+XG4gICAgICByZXR1cm4gbnVsbCBpZiBjb250cm9sUG9pbnRcbiAgICAgIHJldHVybiBudWxsIHVubGVzcyBoaXRzXG4gICAgICBmb3IgaGl0IGluIGhpdHNcbiAgICAgICAgcmV0dXJuIGhpdCBpZiBoaXQuZWxlbWVudC5pc0NvbnRyb2xsZXIoKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgICMgV2hhdCB0byBzZWxlY3QgaWYgaXQncyBhIGRvdWJsZSBjbGljay5cbiAgICBuZXh0U2VsZWN0RG91YmxlID0gZG8gLT5cbiAgICAgIHJldHVybiBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50IGlmIGNvbnRyb2xQb2ludFxuICAgICAgcmV0dXJuIG51bGwgdW5sZXNzIGhpdHNcblxuICAgICAgaWYgIXNlbGVjdGVkUGFydGljdWxhckVsZW1lbnRcbiAgICAgICAgIyBTZWNvbmQgdG8gbGFzdCBvciBsYXN0IGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBoaXRzW2hpdHMubGVuZ3RoIC0gMl0gPyBoaXRzW2hpdHMubGVuZ3RoIC0gMV1cblxuICAgICAgIyBGaW5kIFwiZGVlcGVzdCBzaWJsaW5nXCJcbiAgICAgIGZvciBoaXQsIGluZGV4IGluIGhpdHNcbiAgICAgICAgbmV4dEhpdCA9IGhpdHNbaW5kZXggKyAxXVxuICAgICAgICBpZiAhbmV4dEhpdCBvciBuZXh0SGl0LmlzQW5jZXN0b3JPZihzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50KVxuICAgICAgICAgIHJldHVybiBoaXRcblxuICAgICMgV2hhdCB0byBzZWxlY3QgaWYgaXQncyBhIHNpbmdsZSBjbGljay5cbiAgICBuZXh0U2VsZWN0U2luZ2xlID0gZG8gLT5cbiAgICAgIHJldHVybiBudWxsIGlmICFuZXh0U2VsZWN0RG91YmxlXG4gICAgICByZXR1cm4gc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudCBpZiBjb250cm9sbGVyIG9yIGNvbnRyb2xQb2ludFxuICAgICAgaWYgc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudD8uaXNBbmNlc3Rvck9mKG5leHRTZWxlY3REb3VibGUpXG4gICAgICAgIHJldHVybiBzZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBuZXh0U2VsZWN0RG91YmxlXG5cbiAgICBpZiBjb250cm9sUG9pbnRcbiAgICAgIGF0dHJpYnV0ZXNUb0NoYW5nZSA9IGNvbnRyb2xQb2ludC5hdHRyaWJ1dGVzVG9DaGFuZ2VcbiAgICBlbHNlIGlmIGNvbnRyb2xsZXJcbiAgICAgIGF0dHJpYnV0ZXNUb0NoYW5nZSA9IGNvbnRyb2xsZXIuZWxlbWVudC5hdHRyaWJ1dGVzVG9DaGFuZ2UoKVxuICAgIGVsc2UgaWYgbmV4dFNlbGVjdFNpbmdsZVxuICAgICAgYXR0cmlidXRlc1RvQ2hhbmdlID0gbmV4dFNlbGVjdFNpbmdsZS5lbGVtZW50LmF0dHJpYnV0ZXNUb0NoYW5nZSgpXG4gICAgZWxzZVxuICAgICAgYXR0cmlidXRlc1RvQ2hhbmdlID0gW11cblxuICAgIHJldHVybiB7Y29udHJvbFBvaW50LCBjb250cm9sbGVyLCBuZXh0U2VsZWN0RG91YmxlLCBuZXh0U2VsZWN0U2luZ2xlLCBhdHRyaWJ1dGVzVG9DaGFuZ2V9XG5cbiAgX3VwZGF0ZUhvdmVyQW5kQ3Vyc29yOiAobW91c2VFdmVudCkgLT5cbiAgICB7aG92ZXJNYW5hZ2VyfSA9IEBjb250ZXh0XG4gICAge2NvbnRyb2xQb2ludCwgY29udHJvbGxlciwgbmV4dFNlbGVjdFNpbmdsZSwgYXR0cmlidXRlc1RvQ2hhbmdlfSA9IEBfaW50ZW50KG1vdXNlRXZlbnQpXG4gICAgaG92ZXJNYW5hZ2VyLmhvdmVyZWRQYXJ0aWN1bGFyRWxlbWVudCA9IG5leHRTZWxlY3RTaW5nbGVcbiAgICBob3Zlck1hbmFnZXIuY29udHJvbGxlclBhcnRpY3VsYXJFbGVtZW50ID0gY29udHJvbGxlclxuICAgIGhvdmVyTWFuYWdlci5hdHRyaWJ1dGVzVG9DaGFuZ2UgPSBhdHRyaWJ1dGVzVG9DaGFuZ2VcbiAgICAjIFRPRE86IHNldCBjdXJzb3JcblxuICBfdXBkYXRlU2VsZWN0ZWQ6IChtb3VzZUV2ZW50LCBpc0RvdWJsZUNsaWNrKSAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAge25leHRTZWxlY3REb3VibGUsIG5leHRTZWxlY3RTaW5nbGV9ID0gQF9pbnRlbnQobW91c2VFdmVudClcbiAgICBpZiBpc0RvdWJsZUNsaWNrXG4gICAgICBwcm9qZWN0LnNlbGVjdChuZXh0U2VsZWN0RG91YmxlKVxuICAgIGVsc2VcbiAgICAgIHByb2plY3Quc2VsZWN0KG5leHRTZWxlY3RTaW5nbGUpXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIERyYWdnaW5nIGFuZCBDcmVhdGluZyBFbGVtZW50c1xuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF9zdGFydEFwcHJvcHJpYXRlRHJhZzogKG1vdXNlRG93bkV2ZW50KSAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAge2NvbnRyb2xQb2ludCwgY29udHJvbGxlciwgbmV4dFNlbGVjdFNpbmdsZSwgYXR0cmlidXRlc1RvQ2hhbmdlfSA9IEBfaW50ZW50KG1vdXNlRG93bkV2ZW50KVxuXG4gICAgaWYgY29udHJvbFBvaW50XG4gICAgICBwYXJ0aWN1bGFyRWxlbWVudFRvRHJhZyA9IHByb2plY3Quc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudFxuICAgIGVsc2VcbiAgICAgIHBhcnRpY3VsYXJFbGVtZW50VG9EcmFnID0gY29udHJvbGxlciA/IG5leHRTZWxlY3RTaW5nbGVcblxuICAgIGlmIHBhcnRpY3VsYXJFbGVtZW50VG9EcmFnXG4gICAgICBhY2N1bXVsYXRlZE1hdHJpeCA9IHBhcnRpY3VsYXJFbGVtZW50VG9EcmFnLmFjY3VtdWxhdGVkTWF0cml4KClcbiAgICAgIG9yaWdpbmFsTW91c2VQaXhlbCA9IEBfbW91c2VQb3NpdGlvbihtb3VzZURvd25FdmVudClcbiAgICAgIG9yaWdpbmFsTW91c2VMb2NhbCA9IEBfdmlld01hdHJpeCgpLmNvbXBvc2UoYWNjdW11bGF0ZWRNYXRyaXgpLnRvTG9jYWwob3JpZ2luYWxNb3VzZVBpeGVsKVxuICAgICAgQF9zdGFydERyYWcobW91c2VEb3duRXZlbnQsIHBhcnRpY3VsYXJFbGVtZW50VG9EcmFnLCBhdHRyaWJ1dGVzVG9DaGFuZ2UsIG9yaWdpbmFsTW91c2VMb2NhbClcbiAgICBlbHNlXG4gICAgICBAX3N0YXJ0UGFuKG1vdXNlRG93bkV2ZW50KVxuXG4gIF9zdGFydERyYWc6IChtb3VzZURvd25FdmVudCwgcGFydGljdWxhckVsZW1lbnRUb0RyYWcsIGF0dHJpYnV0ZXNUb0NoYW5nZSwgb3JpZ2luYWxNb3VzZUxvY2FsLCBzdGFydEltbWVkaWF0ZWx5PWZhbHNlKSAtPlxuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuXG4gICAgZHJhZ01hbmFnZXIuc3RhcnQgbW91c2VEb3duRXZlbnQsXG4gICAgICBvbk1vdmU6IChtb3VzZU1vdmVFdmVudCkgPT5cbiAgICAgICAgcmV0dXJuIHVubGVzcyBzdGFydEltbWVkaWF0ZWx5IG9yIGRyYWdNYW5hZ2VyLmRyYWcuY29uc3VtbWF0ZWRcbiAgICAgICAgY3VycmVudE1vdXNlUGl4ZWwgPSBAX21vdXNlUG9zaXRpb24obW91c2VNb3ZlRXZlbnQpXG4gICAgICAgIGluaXRpYWxWYWx1ZXMgPSBmb3IgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXNUb0NoYW5nZVxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSgpXG4gICAgICAgIHByZWNpc2lvbnMgPSBmb3IgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXNUb0NoYW5nZVxuICAgICAgICAgIFV0aWwucHJlY2lzaW9uKGF0dHJpYnV0ZS5leHByU3RyaW5nKVxuXG4gICAgICAgIG9iamVjdGl2ZSA9ICh0cmlhbFZhbHVlcykgPT5cbiAgICAgICAgICBmb3IgYXR0cmlidXRlLCBpbmRleCBpbiBhdHRyaWJ1dGVzVG9DaGFuZ2VcbiAgICAgICAgICAgIHRyaWFsVmFsdWUgPSB0cmlhbFZhbHVlc1tpbmRleF1cbiAgICAgICAgICAgICMgTm90ZTogSGVyZSBpcyBhIG11dGF0aW9uIHdpdGhpbiBhbiBvYmplY3RpdmUgZnVuY3Rpb24gdGhhdFxuICAgICAgICAgICAgIyByZWFsbHkgb3VnaHQgdG8gYmUgcHVyZSAobm8gc2lkZSBlZmZlY3RzKS4gQnV0IHNldHRpbmcgdGhlXG4gICAgICAgICAgICAjIGF0dHJpYnV0ZXMgZGlyZWN0bHkgaXMganVzdCB0aGUgZWFzaWVzdCB3YXkgdG8gdGVzdCB0aGVcbiAgICAgICAgICAgICMgdHJpYWxWYWx1ZXMuIE1heWJlIGlmIHRoaXMgZXZlciBiZWNvbWVzIGEgcHJvYmxlbSB3ZSBjb3VsZCBoYXZlXG4gICAgICAgICAgICAjIHRoZSBvYmplY3RpdmUgXCJjbGVhbiB1cFwiIGFmdGVyIGl0c2VsZiwgc2V0dGluZyB0aGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgIyBiYWNrIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlcywgdG8gbWFrZSBpdCBwdXJlLlxuICAgICAgICAgICAgYXR0cmlidXRlLnNldEV4cHJlc3Npb24odHJpYWxWYWx1ZSlcbiAgICAgICAgICB0cmlhbEFjY3VtdWxhdGVkTWF0cml4ID0gcGFydGljdWxhckVsZW1lbnRUb0RyYWcuYWNjdW11bGF0ZWRNYXRyaXgoKVxuICAgICAgICAgIHRyaWFsTW91c2VQaXhlbCA9IEBfdmlld01hdHJpeCgpLmNvbXBvc2UodHJpYWxBY2N1bXVsYXRlZE1hdHJpeCkuZnJvbUxvY2FsKG9yaWdpbmFsTW91c2VMb2NhbClcbiAgICAgICAgICBlcnJvciA9IFV0aWwucXVhZHJhbmNlKHRyaWFsTW91c2VQaXhlbCwgY3VycmVudE1vdXNlUGl4ZWwpXG4gICAgICAgICAgcmV0dXJuIGVycm9yXG5cbiAgICAgICAgc29sdmVkVmFsdWVzID0gVXRpbC5zb2x2ZShvYmplY3RpdmUsIGluaXRpYWxWYWx1ZXMpXG4gICAgICAgIGZvciBhdHRyaWJ1dGUsIGluZGV4IGluIGF0dHJpYnV0ZXNUb0NoYW5nZVxuICAgICAgICAgIHNvbHZlZFZhbHVlID0gc29sdmVkVmFsdWVzW2luZGV4XVxuICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbnNbaW5kZXhdXG4gICAgICAgICAgIyBIb2xkIHRoZSBjb21tYW5kIGtleSB0byBcInNuYXAtZHJhZ1wiIHRvIG9uZSBsZXZlbCBjb2Fyc2VyXG4gICAgICAgICAgIyBwcmVjaXNpb24uXG4gICAgICAgICAgaWYga2V5LmNvbW1hbmRcbiAgICAgICAgICAgIHNvbHZlZFZhbHVlID0gVXRpbC5yb3VuZFRvUHJlY2lzaW9uKHNvbHZlZFZhbHVlLCBwcmVjaXNpb24gLSAxKVxuICAgICAgICAgIHNvbHZlZFZhbHVlID0gVXRpbC50b1ByZWNpc2lvbihzb2x2ZWRWYWx1ZSwgcHJlY2lzaW9uKVxuICAgICAgICAgIGF0dHJpYnV0ZS5zZXRFeHByZXNzaW9uKHNvbHZlZFZhbHVlKVxuXG4gICAgaWYgc3RhcnRJbW1lZGlhdGVseVxuICAgICAgZHJhZ01hbmFnZXIuZHJhZy5vbk1vdmUobW91c2VEb3duRXZlbnQpXG5cbiAgX2NyZWF0ZUVsZW1lbnQ6IChtb3VzZUV2ZW50LCBlbGVtZW50KSAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG5cbiAgICBwYXJlbnQgPSBAX2VkaXRpbmdFbGVtZW50KClcbiAgICBuZXdFbGVtZW50ID0gZWxlbWVudC5jcmVhdGVWYXJpYW50KClcbiAgICBwYXJlbnQuYWRkQ2hpbGQobmV3RWxlbWVudClcblxuICAgIG5ld1BhcnRpY3VsYXJFbGVtZW50ID0gbmV3IE1vZGVsLlBhcnRpY3VsYXJFbGVtZW50KG5ld0VsZW1lbnQpXG4gICAgcHJvamVjdC5zZWxlY3QobmV3UGFydGljdWxhckVsZW1lbnQpXG5cbiAgICBhdHRyaWJ1dGVzVG9DaGFuZ2UgPSBuZXdQYXJ0aWN1bGFyRWxlbWVudC5lbGVtZW50LmF0dHJpYnV0ZXNUb0NoYW5nZSgpXG5cbiAgICBAX3N0YXJ0RHJhZyhtb3VzZUV2ZW50LCBuZXdQYXJ0aWN1bGFyRWxlbWVudCwgYXR0cmlidXRlc1RvQ2hhbmdlLCBbMCwgMF0sIHRydWUpXG5cblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAjIFBhbiBhbmQgWm9vbVxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF9zdGFydFBhbjogKG1vdXNlRG93bkV2ZW50KSAtPlxuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIGVsZW1lbnQgPSBAX2VkaXRpbmdFbGVtZW50KClcbiAgICBvcmlnaW5hbE1vdXNlUGl4ZWwgPSBAX21vdXNlUG9zaXRpb24obW91c2VEb3duRXZlbnQpXG4gICAgb3JpZ2luYWxNb3VzZUxvY2FsID0gQF92aWV3TWF0cml4KCkudG9Mb2NhbChvcmlnaW5hbE1vdXNlUGl4ZWwpXG4gICAgZHJhZ01hbmFnZXIuc3RhcnQgbW91c2VEb3duRXZlbnQsXG4gICAgICBvbk1vdmU6IChtb3VzZU1vdmVFdmVudCkgPT5cbiAgICAgICAgcmV0dXJuIHVubGVzcyBkcmFnTWFuYWdlci5kcmFnLmNvbnN1bW1hdGVkXG4gICAgICAgIGN1cnJlbnRNb3VzZVBpeGVsID0gQF9tb3VzZVBvc2l0aW9uKG1vdXNlTW92ZUV2ZW50KVxuICAgICAgICBjdXJyZW50TW91c2VMb2NhbCA9IEBfdmlld01hdHJpeCgpLnRvTG9jYWwoY3VycmVudE1vdXNlUGl4ZWwpXG4gICAgICAgIG9mZnNldCA9IG51bWVyaWMuc3ViKGN1cnJlbnRNb3VzZUxvY2FsLCBvcmlnaW5hbE1vdXNlTG9jYWwpXG4gICAgICAgIGVsZW1lbnQudmlld01hdHJpeCA9IGVsZW1lbnQudmlld01hdHJpeC50cmFuc2xhdGUob2Zmc2V0Li4uKVxuXG4gIF96b29tOiAod2hlZWxFdmVudCkgLT5cbiAgICBlbGVtZW50ID0gQF9lZGl0aW5nRWxlbWVudCgpXG4gICAgc2NhbGVGYWN0b3IgPSBNYXRoLnBvdygxLjAwMSwgLXdoZWVsRXZlbnQuZGVsdGFZKVxuICAgIG1vdXNlUGl4ZWwgPSBAX21vdXNlUG9zaXRpb24od2hlZWxFdmVudClcbiAgICBbeCwgeV0gPSBAX3ZpZXdNYXRyaXgoKS50b0xvY2FsKG1vdXNlUGl4ZWwpXG5cbiAgICBtYXRyaXggPSBlbGVtZW50LnZpZXdNYXRyaXhcbiAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKHgsIHkpXG4gICAgbWF0cml4ID0gbWF0cml4LnNjYWxlKHNjYWxlRmFjdG9yLCBzY2FsZUZhY3RvcilcbiAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKC14LCAteSlcbiAgICBlbGVtZW50LnZpZXdNYXRyaXggPSBtYXRyaXhcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgSGl0IERldGVjdGlvblxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF9oaXREZXRlY3Q6IChtb3VzZUV2ZW50KSAtPlxuICAgIHZpZXdNYXRyaXggPSBAX3ZpZXdNYXRyaXgoKVxuICAgIFt4LCB5XSA9IEBfbW91c2VQb3NpdGlvbihtb3VzZUV2ZW50KVxuXG4gICAgaGl0RGV0ZWN0T3B0cyA9IHt2aWV3TWF0cml4LCB4LCB5fVxuXG4gICAgaGl0cyA9IG51bGxcbiAgICBmb3IgZ3JhcGhpYyBpbiBAX2dyYXBoaWNzKHRydWUpXG4gICAgICBoaXRzID0gZ3JhcGhpYy5oaXREZXRlY3QoaGl0RGV0ZWN0T3B0cykgPyBoaXRzXG5cbiAgICByZXR1cm4gaGl0c1xuXG4gIF9tb3VzZVBvc2l0aW9uOiAobW91c2VFdmVudCkgLT5cbiAgICByZWN0ID0gQF9yZWN0KClcbiAgICB4ID0gbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0XG4gICAgeSA9IG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgcmV0dXJuIFt4LCB5XVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBIZWxwZXJzXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3JlY3Q6IC0+XG4gICAgcmV0dXJuIEBfcmVjdENhY2hlZCBpZiBAX3JlY3RDYWNoZWQ/XG4gICAgZWwgPSBAZ2V0RE9NTm9kZSgpXG4gICAgcmV0dXJuIEBfcmVjdENhY2hlZCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgX2VkaXRpbmdFbGVtZW50OiAtPlxuICAgIHByb2plY3QgPSBAY29udGV4dC5wcm9qZWN0XG4gICAgZWxlbWVudCA9IHByb2plY3QuZWRpdGluZ0VsZW1lbnRcbiAgICByZXR1cm4gZWxlbWVudFxuXG4gIF9ncmFwaGljczogKHVzZUNhY2hlZD1mYWxzZSkgLT5cbiAgICBpZiB1c2VDYWNoZWQgYW5kIEBfY2FjaGVkR3JhcGhpY3NcbiAgICAgIHJldHVybiBAX2NhY2hlZEdyYXBoaWNzXG4gICAgZWxlbWVudCA9IEBfZWRpdGluZ0VsZW1lbnQoKVxuICAgIHJldHVybiBAX2NhY2hlZEdyYXBoaWNzID0gZWxlbWVudC5hbGxHcmFwaGljcygpXG5cbiAgX3ZpZXdNYXRyaXg6IC0+XG4gICAgZWxlbWVudCA9IEBfZWRpdGluZ0VsZW1lbnQoKVxuICAgIHJlY3QgPSBAX3JlY3QoKVxuICAgIHt3aWR0aCwgaGVpZ2h0fSA9IHJlY3RcbiAgICBzY3JlZW5NYXRyaXggPSBuZXcgVXRpbC5NYXRyaXgoMSwgMCwgMCwgLTEsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcbiAgICBlbGVtZW50Vmlld01hdHJpeCA9IGVsZW1lbnQudmlld01hdHJpeFxuICAgIHJldHVybiBzY3JlZW5NYXRyaXguY29tcG9zZShlbGVtZW50Vmlld01hdHJpeClcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5SID0gcmVxdWlyZSBcIi4vUlwiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuLi9Nb2RlbC9Nb2RlbFwiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxuUi5jcmVhdGUgXCJDcmVhdGVQYW5lbFwiLFxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuXG4gIHJlbmRlcjogLT5cbiAgICBwcm9qZWN0ID0gQGNvbnRleHQucHJvamVjdFxuICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQ3JlYXRlUGFuZWxcIn0sXG4gICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIkhlYWRlclwifSwgXCJTeW1ib2xzXCJcbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiU2Nyb2xsZXJcIn0sXG4gICAgICAgIGZvciBlbGVtZW50IGluIHByb2plY3QuY3JlYXRlUGFuZWxFbGVtZW50c1xuICAgICAgICAgIFIuQ3JlYXRlUGFuZWxJdGVtIHtlbGVtZW50LCBrZXk6IFV0aWwuZ2V0SWQoZWxlbWVudCl9XG5cbiAgICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJDcmVhdGVQYW5lbEFkZEl0ZW1cIn0sXG4gICAgICAgICAgUi5idXR0b24ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkFkZEJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogQF9jcmVhdGVOZXdFbGVtZW50XG4gICAgICAgICAgfVxuXG4gIF9jcmVhdGVOZXdFbGVtZW50OiAtPlxuICAgIHByb2plY3QgPSBAY29udGV4dC5wcm9qZWN0XG4gICAgZWxlbWVudCA9IHByb2plY3QuY3JlYXRlTmV3RWxlbWVudCgpXG4gICAgcHJvamVjdC5jcmVhdGVQYW5lbEVsZW1lbnRzLnB1c2goZWxlbWVudClcbiAgICBwcm9qZWN0LnNldEVkaXRpbmcoZWxlbWVudClcblxuXG5SLmNyZWF0ZSBcIkNyZWF0ZVBhbmVsSXRlbVwiLFxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuICAgIGRyYWdNYW5hZ2VyOiBSLkRyYWdNYW5hZ2VyXG5cbiAgcHJvcFR5cGVzOlxuICAgIGVsZW1lbnQ6IE1vZGVsLkVsZW1lbnRcblxuICByZW5kZXI6IC0+XG4gICAgZWxlbWVudCA9IEBwcm9wcy5lbGVtZW50XG4gICAgUi5kaXYge1xuICAgICAgY2xhc3NOYW1lOiBSLmN4IHtcbiAgICAgICAgXCJDcmVhdGVQYW5lbEl0ZW1cIjogdHJ1ZVxuICAgICAgICBcImlzRWRpdGluZ1wiOiBAX2lzRWRpdGluZygpXG4gICAgICB9XG4gICAgfSxcbiAgICAgIFIuZGl2IHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIkNyZWF0ZVBhbmVsVGh1bWJuYWlsXCJcbiAgICAgICAgb25Nb3VzZURvd246IEBfb25Nb3VzZURvd25cbiAgICAgIH0sXG4gICAgICAgIFIuVGh1bWJuYWlsIHtlbGVtZW50fVxuXG4gICAgICBpZiBAX2lzRWRpdGFibGUoKVxuICAgICAgICBSLnNwYW4ge30sXG4gICAgICAgICAgUi5kaXYge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNyZWF0ZVBhbmVsSXRlbUVkaXRCdXR0b24gaWNvbi1wZW5jaWxcIlxuICAgICAgICAgICAgb25DbGljazogQF9lZGl0RWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgIGlmIEBfaXNFZGl0YWJsZSgpIGFuZCAhQF9pc0VkaXRpbmcoKVxuICAgICAgICAgIFIuZGl2IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDcmVhdGVQYW5lbEl0ZW1SZW1vdmVCdXR0b24gaWNvbi14XCJcbiAgICAgICAgICAgIG9uQ2xpY2s6IEBfcmVtb3ZlXG4gICAgICAgICAgfVxuXG4gICAgICBSLmRpdiB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJDcmVhdGVQYW5lbExhYmVsXCJcbiAgICAgIH0sXG4gICAgICAgIFIuRWRpdGFibGVUZXh0IHtcbiAgICAgICAgICB2YWx1ZTogZWxlbWVudC5sYWJlbFxuICAgICAgICAgIHNldFZhbHVlOiBAX3NldExhYmVsVmFsdWVcbiAgICAgICAgfVxuXG4gIF9pc0VkaXRpbmc6IC0+XG4gICAge2VsZW1lbnR9ID0gQHByb3BzXG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcbiAgICByZXR1cm4gZWxlbWVudCA9PSBwcm9qZWN0LmVkaXRpbmdFbGVtZW50XG5cbiAgX2lzRWRpdGFibGU6IC0+XG4gICAge2VsZW1lbnR9ID0gQHByb3BzXG4gICAgYnVpbHRJbiA9IF8udmFsdWVzKE1vZGVsKVxuICAgIHJldHVybiAhXy5jb250YWlucyhidWlsdEluLCBlbGVtZW50KVxuXG4gIF9zZXRMYWJlbFZhbHVlOiAobmV3VmFsdWUpIC0+XG4gICAgQHByb3BzLmVsZW1lbnQubGFiZWwgPSBuZXdWYWx1ZVxuXG4gIF9lZGl0RWxlbWVudDogLT5cbiAgICB7ZWxlbWVudH0gPSBAcHJvcHNcbiAgICB7cHJvamVjdH0gPSBAY29udGV4dFxuICAgIHByb2plY3Quc2V0RWRpdGluZyhlbGVtZW50KVxuXG4gIF9yZW1vdmU6IC0+XG4gICAge2VsZW1lbnR9ID0gQHByb3BzXG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcbiAgICBwcm9qZWN0LmNyZWF0ZVBhbmVsRWxlbWVudHMgPSBfLndpdGhvdXQocHJvamVjdC5jcmVhdGVQYW5lbEVsZW1lbnRzLCBlbGVtZW50KVxuXG4gIF9vbk1vdXNlRG93bjogKG1vdXNlRG93bkV2ZW50KSAtPlxuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuXG4gICAgbW91c2VEb3duRXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIFV0aWwuY2xlYXJUZXh0Rm9jdXMoKVxuXG4gICAgZHJhZ01hbmFnZXIuc3RhcnQgbW91c2VEb3duRXZlbnQsXG4gICAgICB0eXBlOiBcImNyZWF0ZUVsZW1lbnRcIlxuICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgb25DYW5jZWw6ID0+XG4gICAgICAgIGlmIEBfaXNFZGl0YWJsZSgpXG4gICAgICAgICAgQF9lZGl0RWxlbWVudCgpXG4gICAgICAjIGN1cnNvclxuIiwiUiA9IHJlcXVpcmUgXCIuL1JcIlxuTW9kZWwgPSByZXF1aXJlIFwiLi4vTW9kZWwvTW9kZWxcIlxuXG5cblIuY3JlYXRlIFwiRWRpdG9yXCIsXG4gIHByb3BUeXBlczpcbiAgICBlZGl0b3I6IE1vZGVsLkVkaXRvclxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOlxuICAgIGVkaXRvcjogTW9kZWwuRWRpdG9yXG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuICAgIGRyYWdNYW5hZ2VyOiBSLkRyYWdNYW5hZ2VyXG4gICAgaG92ZXJNYW5hZ2VyOiBSLkhvdmVyTWFuYWdlclxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogLT5cbiAgICBAX2RyYWdNYW5hZ2VyID0gbmV3IFIuRHJhZ01hbmFnZXIoKVxuICAgIEBfaG92ZXJNYW5hZ2VyID0gbmV3IFIuSG92ZXJNYW5hZ2VyKClcblxuICBnZXRDaGlsZENvbnRleHQ6IC0+XG4gICAge2VkaXRvcn0gPSBAcHJvcHNcbiAgICB7XG4gICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgcHJvamVjdDogZWRpdG9yLnByb2plY3RcbiAgICAgIGRyYWdNYW5hZ2VyOiBAX2RyYWdNYW5hZ2VyXG4gICAgICBob3Zlck1hbmFnZXI6IEBfaG92ZXJNYW5hZ2VyXG4gICAgfVxuXG4gIHJlbmRlcjogLT5cbiAgICBjdXJzb3IgPSBAX2RyYWdNYW5hZ2VyLmRyYWc/LmN1cnNvclxuXG4gICAgUi5kaXYge1xuICAgICAgY2xhc3NOYW1lOiBSLmN4IHtcbiAgICAgICAgQ3Vyc29yT3ZlcnJpZGU6IGN1cnNvcj9cbiAgICAgIH1cbiAgICAgIHN0eWxlOiB7Y3Vyc29yOiBjdXJzb3IgPyBcIlwifVxuICAgIH0sXG4gICAgICBSLkRyYWdIaW50IHt9XG5cbiAgICAgIFIuQ3JlYXRlUGFuZWwge31cbiAgICAgIFIuT3V0bGluZSB7fVxuICAgICAgUi5JbnNwZWN0b3Ige31cbiAgICAgIFIuTWVudWJhciB7fVxuICAgICAgUi5DYW52YXMge31cblxuXG5cblxuXG5cblxuXG5cbiMgVGhpcyB3cmFwcGVyIGlzIHVzZWQgaW4gRXhwcmVzc2lvbiB3aGVyZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gcmVuZGVyXG4jIFJlYWN0RWxlbWVudHMgd2l0aGluIGEgQ29kZU1pcnJvciBtYXJrLiBJdCBtYXkgbm90IGJlIG5lZWRlZCBpbiB0aGUgZnV0dXJlXG4jIGlmIFJlYWN0IG1pZ3JhdGVzIGZyb20gY29udGV4dCBjb21pbmcgZnJvbSBvd25lciB0byBjb250ZXh0IGNvbWluZyBmcm9tXG4jIHBhcmVudC4gU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qaW1mYi8wZWI2ZTYxZjMwMGE4YzFiMmNlN1xuUi5jcmVhdGUgXCJDb250ZXh0V3JhcHBlclwiLFxuICBwcm9wVHlwZXM6XG4gICAgY2hpbGRSZW5kZXI6IEZ1bmN0aW9uXG4gICAgY29udGV4dDogT2JqZWN0XG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6XG4gICAgZWRpdG9yOiBNb2RlbC5FZGl0b3JcbiAgICBwcm9qZWN0OiBNb2RlbC5Qcm9qZWN0XG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcbiAgICBob3Zlck1hbmFnZXI6IFIuSG92ZXJNYW5hZ2VyXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiAtPlxuICAgIEBwcm9wcy5jb250ZXh0XG5cbiAgcmVuZGVyOiAtPiBAcHJvcHMuY2hpbGRSZW5kZXIoKVxuXG5cblxuUi5jcmVhdGUgXCJEcmFnSGludFwiLFxuICBjb250ZXh0VHlwZXM6XG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcblxuICByZW5kZXI6IC0+XG4gICAge2RyYWdNYW5hZ2VyfSA9IEBjb250ZXh0XG5cbiAgICBkcmFnID0gZHJhZ01hbmFnZXIuZHJhZ1xuXG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJEcmFnSGludENvbnRhaW5lclwifSxcbiAgICAgIGlmIGRyYWc/LnR5cGUgPT0gXCJ0cmFuc2NsdWRlQXR0cmlidXRlXCIgYW5kIGRyYWcuY29uc3VtbWF0ZWRcbiAgICAgICAgUi5kaXYge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJEcmFnSGludFwiXG4gICAgICAgICAgc3R5bGU6XG4gICAgICAgICAgICBsZWZ0OiBkcmFnLnggKyA1XG4gICAgICAgICAgICB0b3A6ICBkcmFnLnkgKyA1XG4gICAgICAgIH0sXG4gICAgICAgICAgUi5BdHRyaWJ1dGVUb2tlbiB7YXR0cmlidXRlOiBkcmFnLmF0dHJpYnV0ZSwgY29udGV4dEVsZW1lbnQ6IG51bGx9XG5cblxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblIgPSByZXF1aXJlIFwiLi9SXCJcbk1vZGVsID0gcmVxdWlyZSBcIi4uL01vZGVsL01vZGVsXCJcbkRhdGFmbG93ID0gcmVxdWlyZSBcIi4uL0RhdGFmbG93L0RhdGFmbG93XCJcblV0aWwgPSByZXF1aXJlIFwiLi4vVXRpbC9VdGlsXCJcblxuXG5SLmNyZWF0ZSBcIkV4cHJlc3Npb25cIixcbiAgcHJvcFR5cGVzOlxuICAgIGF0dHJpYnV0ZTogTW9kZWwuQXR0cmlidXRlXG5cbiAgcmVuZGVyOiAtPlxuICAgIGF0dHJpYnV0ZSA9IEBwcm9wcy5hdHRyaWJ1dGVcblxuICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiRXhwcmVzc2lvblwifSxcbiAgICAgIFIuRXhwcmVzc2lvbkNvZGUge2F0dHJpYnV0ZX1cbiAgICAgIFIuRXhwcmVzc2lvblZhbHVlIHthdHRyaWJ1dGV9XG5cblIuY3JlYXRlIFwiRXhwcmVzc2lvblZhbHVlXCIsXG4gIHByb3BUeXBlczpcbiAgICBhdHRyaWJ1dGU6IE1vZGVsLkF0dHJpYnV0ZVxuICByZW5kZXI6IC0+XG4gICAgYXR0cmlidXRlID0gQHByb3BzLmF0dHJpYnV0ZVxuICAgIGlmIGF0dHJpYnV0ZS5pc1RyaXZpYWwoKVxuICAgICAgUi5zcGFuIHt9XG4gICAgZWxzZVxuICAgICAgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUoKVxuICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJFeHByZXNzaW9uVmFsdWVcIn0sXG4gICAgICAgIFIuVmFsdWUge3ZhbHVlOiB2YWx1ZX1cblxuUi5jcmVhdGUgXCJWYWx1ZVwiLFxuICBwcm9wVHlwZXM6XG4gICAgdmFsdWU6IFwiYW55XCJcbiAgcmVuZGVyOiAtPlxuICAgIHZhbHVlID0gQHByb3BzLnZhbHVlXG4gICAgUi5zcGFuIHtjbGFzc05hbWU6IFwiVmFsdWVcIn0sXG4gICAgICBpZiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgIFwiKEVycm9yKVwiXG4gICAgICBlbHNlIGlmIF8uaXNGdW5jdGlvbih2YWx1ZSlcbiAgICAgICAgXCIoRnVuY3Rpb24pXCJcbiAgICAgIGVsc2UgaWYgdmFsdWUgaW5zdGFuY2VvZiBEYXRhZmxvdy5TcHJlYWRcbiAgICAgICAgIyBUT0RPOiBNYWtlIHRoaXMgYmV0dGVyXG4gICAgICAgIFwiKFNwcmVhZCkgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZS5pdGVtcylcbiAgICAgIGVsc2UgaWYgXy5pc051bWJlcih2YWx1ZSlcbiAgICAgICAgVXRpbC50b01heFByZWNpc2lvbih2YWx1ZSwgMylcbiAgICAgIGVsc2VcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG5cblIuY3JlYXRlIFwiU3ByZWFkVmFsdWVcIixcbiAgcHJvcFR5cGVzOlxuICAgIHNwcmVhZDogXCJhbnlcIlxuICBtYXhTcHJlYWRJdGVtczogNVxuICByZW5kZXI6IC0+XG4gICAgUi5zcGFuIHtjbGFzc05hbWU6IFwiU3ByZWFkVmFsdWVcIn0sXG4gICAgICBmb3IgaW5kZXggaW4gWzAuLi5NYXRoLm1pbihAc3ByZWFkLmxlbmd0aCwgQG1heFNwcmVhZEl0ZW1zKV1cbiAgICAgICAgdmFsdWUgPSBAc3ByZWFkLnRha2UoaW5kZXgpXG4gICAgICAgIFIuc3BhbiB7Y2xhc3NOYW1lOiBcIlNwcmVhZFZhbHVlSXRlbVwifSxcbiAgICAgICAgICBSLlZhbHVlIHt2YWx1ZTogdmFsdWV9XG4gICAgICBpZiBAc3ByZWFkLmxlbmd0aCA+IEBtYXhTcHJlYWRJdGVtc1xuICAgICAgICBcIi4uLlwiXG4iLCJyZXF1aXJlIFwiY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludFwiXG5yZXF1aXJlIFwiY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiXG5Db2RlTWlycm9yID0gcmVxdWlyZSBcImNvZGVtaXJyb3JcIlxuXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblIgPSByZXF1aXJlIFwiLi9SXCJcbk1vZGVsID0gcmVxdWlyZSBcIi4uL01vZGVsL01vZGVsXCJcblV0aWwgPSByZXF1aXJlIFwiLi4vVXRpbC9VdGlsXCJcblxuXG5cblIuY3JlYXRlIFwiRXhwcmVzc2lvbkNvZGVcIixcbiAgcHJvcFR5cGVzOlxuICAgIGF0dHJpYnV0ZTogTW9kZWwuQXR0cmlidXRlXG5cbiAgY29udGV4dFR5cGVzOlxuICAgIGVkaXRvcjogTW9kZWwuRWRpdG9yICMgZXh0cmFuZW91c1xuICAgIHByb2plY3Q6IE1vZGVsLlByb2plY3QgIyBleHRyYW5lb3VzXG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcbiAgICBob3Zlck1hbmFnZXI6IFIuSG92ZXJNYW5hZ2VyICMgZXh0cmFuZW91c1xuICAgICMgTm90ZTogd2UgbmVlZCB0byBpbmNsdWRlIGFsbCB0aGUgY29udGV4dCB2YXJpYWJsZXMgdG8gcGFzcyBkb3duIHRvXG4gICAgIyBDb250ZXh0V3JhcHBlciAoZm9yIENvZGVNaXJyb3IgbWFya3MpLiBNYXliZSB0aGUgbmV4dCB2ZXJzaW9uIG9mIFJlYWN0XG4gICAgIyB3b24ndCBuZWVkIENvbnRleHRXcmFwcGVyIHNvIHdlIGNhbiBnZXQgcmlkIG9mIHRoZSBvbmVzIG1hcmtlZFxuICAgICMgZXh0cmFuZW91cy5cblxuICBtaXhpbnM6IFtSLkFubm90YXRlTWl4aW5dXG5cbiAgcmVuZGVyOiAtPlxuICAgIGF0dHJpYnV0ZSA9IEBwcm9wcy5hdHRyaWJ1dGVcblxuICAgIFIuZGl2IHtcbiAgICAgIGNsYXNzTmFtZTogXCJFeHByZXNzaW9uQ29kZSBJbnRlcmFjdGl2ZVwiXG4gICAgICBvbk1vdXNlVXA6IEBfb25Nb3VzZVVwXG4gICAgfVxuXG4gIGFubm90YXRpb246IC0+XG4gICAgIyBXZSBhbm5vdGF0ZSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMgdG8gc3VwcG9ydCBBdHRyaWJ1dGVMYWJlbCdzIFwiY2xpY2tcbiAgICAjIGFuIGF0dHJpYnV0ZSB0byB0cmFuc2NsdWRlIGl0XCIgZmVhdHVyZS5cbiAgICB7Y29tcG9uZW50OiB0aGlzfVxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIGVsID0gQGdldERPTU5vZGUoKVxuXG4gICAgQG1pcnJvciA9IENvZGVNaXJyb3IoZWwsIHtcbiAgICAgIG1vZGU6IFwiamF2YXNjcmlwdFwiXG5cbiAgICAgICMgTmVlZGVkIGZvciBhdXRvLWV4cGFuZGluZyBoZWlnaHQgdG8gd29yayBwcm9wZXJseS5cbiAgICAgIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eVxuXG4gICAgICAjIFVzZSB0YWJzIHRvIGluZGVudC5cbiAgICAgIHNtYXJ0SW5kZW50OiB0cnVlXG4gICAgICBpbmRlbnRVbml0OiAyXG4gICAgICB0YWJTaXplOiAyXG4gICAgICBpbmRlbnRXaXRoVGFiczogdHJ1ZVxuXG4gICAgICAjIERpc2FibGUgc2Nyb2xsaW5nXG4gICAgICBsaW5lV3JhcHBpbmc6IHRydWVcbiAgICAgIHNjcm9sbGJhclN0eWxlOiBcIm51bGxcIlxuXG4gICAgICAjIERpc2FibGUgdW5kb1xuICAgICAgdW5kb0RlcHRoOiAwXG5cbiAgICAgICMgIyBFeHRyYSBrZXkgaGFuZGxlcnNcbiAgICAgICMgZXh0cmFLZXlzOiBAZXh0cmFLZXlzXG4gICAgfSlcblxuICAgIEBtaXJyb3Iub24oXCJjaGFuZ2VcIiwgQF9vbkNoYW5nZSlcbiAgICBAbWlycm9yLm9uKFwibW91c2Vkb3duXCIsIEBfb25NaXJyb3JNb3VzZURvd24pXG4gICAgQGNvbXBvbmVudERpZFVwZGF0ZSgpXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiAtPlxuICAgIEBfdXBkYXRlTWlycm9yRnJvbUF0dHJpYnV0ZSgpXG5cbiAgX29uQ2hhbmdlOiAtPlxuICAgIEBfdXBkYXRlQXR0cmlidXRlRnJvbU1pcnJvcigpXG4gICAgaWYgQG1pcnJvci5oYXNGb2N1cygpXG4gICAgICBAX3Nob3dBdXRvY29tcGxldGUoKVxuXG4gIF9vbk1pcnJvck1vdXNlRG93bjogKG1pcnJvciwgbW91c2VEb3duRXZlbnQpIC0+XG4gICAgZWwgPSBtb3VzZURvd25FdmVudC50YXJnZXRcbiAgICBpZiBVdGlsLm1hdGNoZXMoZWwsIFwiLmNtLW51bWJlclwiKVxuICAgICAgbW91c2VEb3duRXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgQF9zdGFydE51bWJlclNjcnViKG1vdXNlRG93bkV2ZW50KVxuXG4gIF9vbk1vdXNlVXA6IChtb3VzZVVwRXZlbnQpIC0+XG4gICAge2F0dHJpYnV0ZX0gPSBAcHJvcHNcbiAgICB7ZHJhZ01hbmFnZXJ9ID0gQGNvbnRleHRcbiAgICBpZiBkcmFnTWFuYWdlci5kcmFnPy50eXBlID09IFwidHJhbnNjbHVkZUF0dHJpYnV0ZVwiXG4gICAgICBAdHJhbnNjbHVkZUF0dHJpYnV0ZShkcmFnTWFuYWdlci5kcmFnLmF0dHJpYnV0ZSlcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgVXBkYXRpbmcgKGZyb20gYm90aCBkaXJlY3Rpb25zKVxuICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIF91cGRhdGVNaXJyb3JGcm9tQXR0cmlidXRlOiAtPlxuICAgIGF0dHJpYnV0ZSA9IEBwcm9wcy5hdHRyaWJ1dGVcbiAgICB2YWx1ZSA9IGF0dHJpYnV0ZS5leHByU3RyaW5nID8gXCJcIlxuICAgIGlmIEBtaXJyb3IuZ2V0VmFsdWUoKSAhPSB2YWx1ZVxuICAgICAgQG1pcnJvci5zZXRWYWx1ZSh2YWx1ZSlcbiAgICBAX3VwZGF0ZU1hcmtzKClcblxuICBfdXBkYXRlQXR0cmlidXRlRnJvbU1pcnJvcjogLT5cbiAgICBhdHRyaWJ1dGUgPSBAcHJvcHMuYXR0cmlidXRlXG4gICAgbmV3RXhwclN0cmluZyA9IEBtaXJyb3IuZ2V0VmFsdWUoKVxuICAgIGlmIGF0dHJpYnV0ZS5leHByU3RyaW5nICE9IG5ld0V4cHJTdHJpbmdcbiAgICAgICMgV2UgY2xlYW4gdXAgcmVmZXJlbmNlcyB0byBnZXQgcmlkIG9mIGF0dHJpYnV0ZSByZWZlcmVuY2VzIHdoaWNoIG5vXG4gICAgICAjIGxvbmdlciBhcHBlYXIgaW4gZXhwclN0cmluZy5cbiAgICAgIG9sZFJlZmVyZW5jZXMgPSBhdHRyaWJ1dGUucmVmZXJlbmNlcygpXG4gICAgICBuZXdSZWZlcmVuY2VzID0ge31cbiAgICAgIGZvciBvd24gcmVmZXJlbmNlS2V5LCByZWZlcmVuY2VOb2RlIG9mIG9sZFJlZmVyZW5jZXNcbiAgICAgICAgaXNVc2VkID0gKG5ld0V4cHJTdHJpbmcuaW5kZXhPZihyZWZlcmVuY2VLZXkpICE9IC0xKVxuICAgICAgICBpZiBpc1VzZWRcbiAgICAgICAgICBuZXdSZWZlcmVuY2VzW3JlZmVyZW5jZUtleV0gPSByZWZlcmVuY2VOb2RlXG4gICAgICBhdHRyaWJ1dGUuc2V0RXhwcmVzc2lvbihuZXdFeHByU3RyaW5nLCBuZXdSZWZlcmVuY2VzKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBUcmFuc2NsdWRpbmcgYW4gYXR0cmlidXRlIChjcmVhdGluZyBhIHJlZmVyZW5jZSlcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB0cmFuc2NsdWRlQXR0cmlidXRlOiAocmVmZXJlbmNlQXR0cmlidXRlKSAtPlxuICAgIGlmIEBtaXJyb3IuaGFzRm9jdXMoKVxuICAgICAgQF9yZXBsYWNlU2VsZWN0aW9uV2l0aFJlZmVyZW5jZShyZWZlcmVuY2VBdHRyaWJ1dGUpXG4gICAgZWxzZVxuICAgICAgQF9yZXBsYWNlQWxsV2l0aFJlZmVyZW5jZShyZWZlcmVuY2VBdHRyaWJ1dGUpXG5cbiAgX3JlcGxhY2VTZWxlY3Rpb25XaXRoUmVmZXJlbmNlOiAocmVmZXJlbmNlQXR0cmlidXRlKSAtPlxuICAgIHthdHRyaWJ1dGV9ID0gQHByb3BzXG4gICAgcmVmZXJlbmNlcyA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzKClcbiAgICByZWZlcmVuY2VLZXkgPSBVdGlsLmdlbmVyYXRlSWQoKVxuICAgIHJlZmVyZW5jZXNbcmVmZXJlbmNlS2V5XSA9IHJlZmVyZW5jZUF0dHJpYnV0ZVxuICAgIGV4cHJTdHJpbmcgPSBhdHRyaWJ1dGUuZXhwclN0cmluZ1xuICAgIGF0dHJpYnV0ZS5zZXRFeHByZXNzaW9uKGV4cHJTdHJpbmcsIHJlZmVyZW5jZXMpXG4gICAgQG1pcnJvci5yZXBsYWNlU2VsZWN0aW9uKHJlZmVyZW5jZUtleSlcblxuICBfcmVwbGFjZUFsbFdpdGhSZWZlcmVuY2U6IChyZWZlcmVuY2VBdHRyaWJ1dGUpIC0+XG4gICAge2F0dHJpYnV0ZX0gPSBAcHJvcHNcbiAgICByZWZlcmVuY2VzID0ge31cbiAgICByZWZlcmVuY2VLZXkgPSBVdGlsLmdlbmVyYXRlSWQoKVxuICAgIHJlZmVyZW5jZXNbcmVmZXJlbmNlS2V5XSA9IHJlZmVyZW5jZUF0dHJpYnV0ZVxuICAgIGV4cHJTdHJpbmcgPSByZWZlcmVuY2VLZXlcbiAgICBhdHRyaWJ1dGUuc2V0RXhwcmVzc2lvbihleHByU3RyaW5nLCByZWZlcmVuY2VzKVxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBEaXNwbGF5aW5nIHJlZmVyZW5jZSB0b2tlbnNcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAjIFJlZmVyZW5jZXMgdG8gb3RoZXIgQXR0cmlidXRlcyB3aXRoaW4gYW4gZXhwcmVzc2lvbiBnZXQgZGlzcGxheWVkIGFzXG4gICMgdG9rZW5zLiBUaGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIENvZGVNaXJyb3IncyBtYXJrZXIgQVBJLlxuICAjXG4gICMgaHR0cDovL2NvZGVtaXJyb3IubmV0L2RvYy9tYW51YWwuaHRtbCNhcGlfbWFya2VyXG5cbiAgX21hcmtzOiAtPlxuICAgICMgVE9ETzogQWRkIG90aGVyIG1hcmtzIChjb2xvciBwaWNrZXIsIGJvb2xlYW4gY2hlY2tib3gsIGV0YylcbiAgICByZXR1cm4gQF9hdHRyaWJ1dGVUb2tlbk1hcmtzKClcblxuICBfYXR0cmlidXRlVG9rZW5NYXJrczogLT5cbiAgICBhdHRyaWJ1dGUgPSBAcHJvcHMuYXR0cmlidXRlXG4gICAgdmFsdWUgPSBAbWlycm9yLmdldFZhbHVlKClcbiAgICBtYXJrcyA9IFtdXG4gICAgZm9yIG93biByZWZlcmVuY2VLZXksIHJlZmVyZW5jZUF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGUucmVmZXJlbmNlcygpXG4gICAgICBzdGFydENoYXIgPSB2YWx1ZS5pbmRleE9mKHJlZmVyZW5jZUtleSlcbiAgICAgIGNvbnRpbnVlIGlmIHN0YXJ0Q2hhciA9PSAtMVxuICAgICAgZW5kQ2hhciA9IHN0YXJ0Q2hhciArIHJlZmVyZW5jZUtleS5sZW5ndGhcbiAgICAgIGRvIChyZWZlcmVuY2VBdHRyaWJ1dGUpIC0+XG4gICAgICAgIGZyb20gPSBVdGlsLmNoYXJUb0xpbmVDaCh2YWx1ZSwgc3RhcnRDaGFyKVxuICAgICAgICB0byA9IFV0aWwuY2hhclRvTGluZUNoKHZhbHVlLCBlbmRDaGFyKVxuICAgICAgICByZW5kZXIgPSAtPlxuICAgICAgICAgIFIuQXR0cmlidXRlVG9rZW4ge1xuICAgICAgICAgICAgYXR0cmlidXRlOiByZWZlcmVuY2VBdHRyaWJ1dGVcbiAgICAgICAgICAgIGNvbnRleHRFbGVtZW50OiBhdHRyaWJ1dGUucGFyZW50RWxlbWVudCgpXG4gICAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoIHtmcm9tLCB0bywgcmVuZGVyfVxuICAgIHJldHVybiBtYXJrc1xuXG4gIF91cGRhdGVNYXJrczogLT5cbiAgICBtYXJrcyA9IEBfbWFya3MoKVxuXG4gICAgQF9leGlzdGluZ01hcmtzID89IFtdXG4gICAgdXBkYXRlZE1hcmtzID0gW11cbiAgICBleGlzdGluZ01hcmtzVG9SZW1vdmUgPSBbXVxuXG4gICAgZm9yIGV4aXN0aW5nTWFyayBpbiBAX2V4aXN0aW5nTWFya3NcbiAgICAgIGtlZXBFeGlzdGluZ01hcmsgPSBmYWxzZVxuICAgICAgcmFuZ2UgPSBleGlzdGluZ01hcmsuZmluZCgpXG5cbiAgICAgIGlmIHJhbmdlXG4gICAgICAgIGZvciBtYXJrIGluIG1hcmtzXG4gICAgICAgICAgY29ycmVzcG9uZHMgPSAocmFuZ2UuZnJvbS5saW5lID09IG1hcmsuZnJvbS5saW5lIGFuZFxuICAgICAgICAgICAgcmFuZ2UuZnJvbS5jaCA9PSBtYXJrLmZyb20uY2ggYW5kXG4gICAgICAgICAgICByYW5nZS50by5saW5lID09IG1hcmsudG8ubGluZSBhbmRcbiAgICAgICAgICAgIHJhbmdlLnRvLmNoID09IG1hcmsudG8uY2gpXG4gICAgICAgICAgaWYgY29ycmVzcG9uZHNcbiAgICAgICAgICAgICMgVXBkYXRlIHRoZSBleGlzdGluZyBtYXJrLlxuICAgICAgICAgICAgQF9yZW5kZXJNYXJrKG1hcmssIGV4aXN0aW5nTWFyay5lbClcblxuICAgICAgICAgICAgIyBMZXQgQ29kZU1pcnJvciBrbm93IHRoYXQgdGhlIG1hcmsgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpemUuIE5vdGU6XG4gICAgICAgICAgICAjIEkgY29tbWVudGVkIHRoaXMgb3V0IHNpbmNlIGl0IGRvZXNuJ3Qgc2VlbSB0byBiZSBuZWNlc3NhcnkgYW5kXG4gICAgICAgICAgICAjIGl0IGFsc28gc2VlbXMgdG8gc2xvdyB0aGluZ3MgZG93biBjb25zaWRlcmFibHkuXG5cbiAgICAgICAgICAgICMgZXhpc3RpbmdNYXJrLmNoYW5nZWQoKVxuXG4gICAgICAgICAgICB1cGRhdGVkTWFya3MucHVzaChtYXJrKVxuICAgICAgICAgICAga2VlcEV4aXN0aW5nTWFyayA9IHRydWVcblxuICAgICAgdW5sZXNzIGtlZXBFeGlzdGluZ01hcmtcbiAgICAgICAgZXhpc3RpbmdNYXJrc1RvUmVtb3ZlLnB1c2goZXhpc3RpbmdNYXJrKVxuXG4gICAgZm9yIGV4aXN0aW5nTWFya1RvUmVtb3ZlIGluIGV4aXN0aW5nTWFya3NUb1JlbW92ZVxuICAgICAgZXhpc3RpbmdNYXJrVG9SZW1vdmUuY2xlYXIoKVxuICAgICAgQF9leGlzdGluZ01hcmtzID0gXy53aXRob3V0KEBfZXhpc3RpbmdNYXJrcywgZXhpc3RpbmdNYXJrVG9SZW1vdmUpXG5cbiAgICBmb3IgbWFyayBpbiBtYXJrc1xuICAgICAgdW5sZXNzIG1hcmsgaW4gdXBkYXRlZE1hcmtzXG4gICAgICAgICMgQWRkIGEgbmV3IG1hcmtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKVxuICAgICAgICBAX3JlbmRlck1hcmsobWFyaywgZWwpXG4gICAgICAgIG5ld01hcmsgPSBAbWlycm9yLm1hcmtUZXh0KG1hcmsuZnJvbSwgbWFyay50bywge1xuICAgICAgICAgIHJlcGxhY2VkV2l0aDogZWxcbiAgICAgICAgfSlcbiAgICAgICAgbmV3TWFyay5lbCA9IGVsXG4gICAgICAgIEBfZXhpc3RpbmdNYXJrcy5wdXNoKG5ld01hcmspXG5cbiAgX3JlbmRlck1hcms6IChtYXJrLCBlbCkgLT5cbiAgICB3cmFwcGVkUmVhY3RFbGVtZW50ID0gUi5Db250ZXh0V3JhcHBlciB7XG4gICAgICBjb250ZXh0OiBAY29udGV4dFxuICAgICAgY2hpbGRSZW5kZXI6IG1hcmsucmVuZGVyXG4gICAgfVxuICAgIFJlYWN0LnJlbmRlcih3cmFwcGVkUmVhY3RFbGVtZW50LCBlbClcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgQXV0b2NvbXBsZXRlXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3Nob3dBdXRvY29tcGxldGU6IC0+XG4gICAgQG1pcnJvci5zaG93SGludFxuICAgICAgaGludDogQF9oaW50XG4gICAgICBjb21wbGV0ZVNpbmdsZTogZmFsc2VcbiAgICAgICMgVW5jb21tZW50IGJlbG93IHRvIHBsYXkgd2l0aCBzdHlsaW5nIGluIGJyb3dzZXIgaW5zcGVjdG9yLlxuICAgICAgIyBjbG9zZU9uVW5mb2N1czogZmFsc2VcblxuICBfc2hvdWxkU2hvd0hpbnQ6ICh0b2tlbikgLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgdG9rZW4udHlwZSA9PSBcInZhcmlhYmxlXCJcbiAgICBsZXR0ZXJzID0gdG9rZW4uc3RyaW5nXG4gICAgcmVmZXJlbmNlcyA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzKClcbiAgICBmb3Igb3duIHJlZmVyZW5jZUtleSwgcmVmZXJlbmNlQXR0cmlidXRlIG9mIHJlZmVyZW5jZXNcbiAgICAgIGlmIGxldHRlcnMuaW5kZXhPZihyZWZlcmVuY2VLZXkpICE9IC0xXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB0cnVlXG5cbiAgX2hpbnQ6IChtaXJyb3IpIC0+XG4gICAgY3Vyc29yID0gbWlycm9yLmdldEN1cnNvcigpXG4gICAgdG9rZW4gPSBtaXJyb3IuZ2V0VG9rZW5BdChjdXJzb3IpXG4gICAgcmV0dXJuIHVubGVzcyBAX3Nob3VsZFNob3dIaW50KHRva2VuKVxuXG4gICAgZnJvbSA9IENvZGVNaXJyb3IuUG9zKGN1cnNvci5saW5lLCB0b2tlbi5zdGFydClcbiAgICB0byA9IENvZGVNaXJyb3IuUG9zKGN1cnNvci5saW5lLCBjdXJzb3IuY2gpXG4gICAgbGV0dGVycyA9IHRva2VuLnN0cmluZy50b0xvd2VyQ2FzZSgpXG5cbiAgICBjb21wbGV0aW9ucyA9IEBfY29tcGxldGlvbnMobGV0dGVycywgZnJvbSwgdG8pXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGlzdDogY29tcGxldGlvbnNcbiAgICAgIGZyb20sIHRvXG4gICAgfVxuXG4gICMgR2l2ZW4gd2hhdCB5b3UgaGF2ZSB0eXBlZCBzbyBmYXIgKGBsZXR0ZXJzYCkgYW5kIGEgZnJvbSBhbmQgdG9cbiAgIyBDb2RlTWlycm9yLlBvcywgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGxldGlvbnMuIEVhY2ggY29tcGxldGlvbiBpcyBhblxuICAjIG9iamVjdCB3aXRoIGEgYHJlbmRlcihlbClgIGZ1bmN0aW9uIGFuZCBhIGBoaW50KClgIGZ1bmN0aW9uLiBgcmVuZGVyKGVsKWBcbiAgIyBzaG91bGQgYXBwZW5kIHNvbWUgRE9NIHRvIGBlbGAuIGBoaW50KClgIHNob3VsZCByZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aFxuICAjIHRoZSBhcHByb3ByaWF0ZSBhdXRvY29tcGxldGVkIHZhbHVlLlxuICAjXG4gICMgU2VlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvZG9jL21hbnVhbC5odG1sI2FkZG9uX3Nob3ctaGludFxuICBfY29tcGxldGlvbnM6IChsZXR0ZXJzLCBmcm9tLCB0bykgLT5cbiAgICB7YXR0cmlidXRlfSA9IEBwcm9wc1xuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG5cbiAgICBtYXRjaGluZ0F0dHJpYnV0ZXMgPSBAX21hdGNoaW5nQXR0cmlidXRlcyhsZXR0ZXJzKVxuXG4gICAgY29tcGxldGlvbnMgPSBfLm1hcCBtYXRjaGluZ0F0dHJpYnV0ZXMsIChtYXRjaGluZ0F0dHJpYnV0ZSkgPT5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKGVsKSA9PlxuICAgICAgICAgIHdyYXBwZWRSZWFjdEVsZW1lbnQgPSBSLkNvbnRleHRXcmFwcGVyIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IEBjb250ZXh0XG4gICAgICAgICAgICBjaGlsZFJlbmRlcjogPT4gUi5BdHRyaWJ1dGVUb2tlbiB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZTogbWF0Y2hpbmdBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgY29udGV4dEVsZW1lbnQ6IGF0dHJpYnV0ZS5wYXJlbnRFbGVtZW50KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3QucmVuZGVyKHdyYXBwZWRSZWFjdEVsZW1lbnQsIGVsKVxuICAgICAgICBoaW50OiA9PlxuICAgICAgICAgIEBtaXJyb3Iuc2V0U2VsZWN0aW9uKGZyb20sIHRvKVxuICAgICAgICAgIEBfcmVwbGFjZVNlbGVjdGlvbldpdGhSZWZlcmVuY2UobWF0Y2hpbmdBdHRyaWJ1dGUpXG4gICAgICB9XG5cbiAgICBjb21wbGV0aW9ucy5wdXNoIHtcbiAgICAgIGRpc3BsYXlUZXh0OiBcIkNyZWF0ZSBWYXJpYWJsZTogI3tsZXR0ZXJzfVwiXG4gICAgICBoaW50OiA9PlxuICAgICAgICB2YXJpYWJsZSA9IHByb2plY3QuZWRpdGluZ0VsZW1lbnQuYWRkVmFyaWFibGUoKVxuICAgICAgICB2YXJpYWJsZS5sYWJlbCA9IGxldHRlcnNcbiAgICAgICAgQG1pcnJvci5zZXRTZWxlY3Rpb24oZnJvbSwgdG8pXG4gICAgICAgIEBfcmVwbGFjZVNlbGVjdGlvbldpdGhSZWZlcmVuY2UodmFyaWFibGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRpb25zXG5cbiAgX21hdGNoaW5nQXR0cmlidXRlczogKGxldHRlcnMpIC0+XG4gICAgYXR0cmlidXRlTGFiZWxFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLkF0dHJpYnV0ZUxhYmVsXCIpXG4gICAgbWF0Y2hpbmdBdHRyaWJ1dGVzID0gXy5tYXAgYXR0cmlidXRlTGFiZWxFbHMsIChhdHRyaWJ1dGVMYWJlbEVsKSA9PlxuICAgICAgYXR0cmlidXRlTGFiZWxFbC5hbm5vdGF0aW9uLmF0dHJpYnV0ZVxuXG4gICAgbWF0Y2hpbmdBdHRyaWJ1dGVzID0gXy5maWx0ZXIgbWF0Y2hpbmdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PlxuICAgICAgbGFiZWwgPSBhdHRyaWJ1dGUubGFiZWxcbiAgICAgIGNvbXBsZXRpb25MZXR0ZXJzID0gbGFiZWwudG9Mb3dlckNhc2UoKVxuICAgICAgaXNNYXRjaCA9IF8uZXZlcnkgbGV0dGVycywgKGxldHRlcikgLT5cbiAgICAgICAgY29tcGxldGlvbkxldHRlcnMuaW5kZXhPZihsZXR0ZXIpICE9IC0xXG4gICAgICByZXR1cm4gaXNNYXRjaFxuXG4gICAgbWF0Y2hpbmdBdHRyaWJ1dGVzID0gXy51bmlxdWUobWF0Y2hpbmdBdHRyaWJ1dGVzKVxuXG4gICAgcmV0dXJuIG1hdGNoaW5nQXR0cmlidXRlc1xuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBOdW1iZXIgU2NydWJiaW5nXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3N0YXJ0TnVtYmVyU2NydWI6IChtb3VzZURvd25FdmVudCkgLT5cbiAgICB7c3RhcnQsIGVuZH0gPSBAX2dldFRva2VuUG9zaXRpb25Gcm9tQ3Vyc29yKG1vdXNlRG93bkV2ZW50KVxuICAgIEBtaXJyb3IuZm9jdXMoKVxuICAgIEBtaXJyb3Iuc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQpXG4gICAgQF9zdGFydFNjcnViYmluZ1NlbGVjdGlvbihtb3VzZURvd25FdmVudClcblxuICBfZ2V0VG9rZW5Qb3NpdGlvbkZyb21DdXJzb3I6IChtb3VzZURvd25FdmVudCkgLT5cbiAgICBwb3NpdGlvbiA9IEBtaXJyb3IuY29vcmRzQ2hhcih7bGVmdDogbW91c2VEb3duRXZlbnQuY2xpZW50WCwgdG9wOiBtb3VzZURvd25FdmVudC5jbGllbnRZfSlcbiAgICAjIE1ha2Ugc3VyZSBpdCdzIHJlYWxseSBvbiB0aGUgcmlnaHQgY2hhcmFjdGVyLlxuICAgIGlmIEBtaXJyb3IuY3Vyc29yQ29vcmRzKHBvc2l0aW9uKS5sZWZ0IDwgbW91c2VEb3duRXZlbnQuY2xpZW50WFxuICAgICAgcG9zaXRpb24uY2grK1xuICAgIHRva2VuID0gQG1pcnJvci5nZXRUb2tlbkF0KHBvc2l0aW9uKVxuXG4gICAgIyBzdGFydCBhbmQgZW5kIGtlZXAgdHJhY2sgb2Ygd2hpY2ggc3BhbiBvZiB0ZXh0IHdlJ2xsIGJlIHJlcGxhY2luZy5cbiAgICBzdGFydCA9IHtsaW5lOiBwb3NpdGlvbi5saW5lLCBjaDogdG9rZW4uc3RhcnR9XG4gICAgZW5kICAgPSB7bGluZTogcG9zaXRpb24ubGluZSwgY2g6IHRva2VuLmVuZH1cblxuICAgICMgQnJpbmcgaW4gbmVnYXRpdmUgc2lnbiBpZiBuZWNlc3NhcnkuXG4gICAgaWYgc3RhcnQuY2ggPiAwXG4gICAgICBlYXJseVN0YXJ0ID0ge2xpbmU6IHN0YXJ0LmxpbmUsIGNoOiBzdGFydC5jaCAtIDF9XG4gICAgICBpZiBAbWlycm9yLmdldFJhbmdlKGVhcmx5U3RhcnQsIHN0YXJ0KSA9PSBcIi1cIlxuICAgICAgICAjIFRPRE86IE5lZWQgdG8gY2hlY2sgdGhhdCBpdCdzIG5vdCBzdWJ0cmFjdGlvbiAoZS5nLiAyMi0zMClcbiAgICAgICAgc3RhcnQgPSBlYXJseVN0YXJ0XG5cbiAgICByZXR1cm4ge3N0YXJ0LCBlbmR9XG5cbiAgX3N0YXJ0U2NydWJiaW5nU2VsZWN0aW9uOiAobW91c2VEb3duRXZlbnQpIC0+XG4gICAgZHJhZ01hbmFnZXIgPSBAY29udGV4dC5kcmFnTWFuYWdlclxuXG4gICAgb3JpZ2luYWxWYWx1ZSA9ICtAbWlycm9yLmdldFNlbGVjdGlvbigpXG4gICAgcHJlY2lzaW9uID0gVXRpbC5wcmVjaXNpb24oQG1pcnJvci5nZXRTZWxlY3Rpb24oKSlcblxuICAgIHN0YXJ0WCA9IG1vdXNlRG93bkV2ZW50LmNsaWVudFhcblxuICAgIGRyYWdNYW5hZ2VyLnN0YXJ0IG1vdXNlRG93bkV2ZW50LFxuICAgICAgY3Vyc29yOiBcImV3LXJlc2l6ZVwiXG4gICAgICBvbk1vdmU6IChtb3ZlRXZlbnQpID0+XG4gICAgICAgIGR4ID0gbW92ZUV2ZW50LmNsaWVudFggLSBzdGFydFhcbiAgICAgICAgZHggPSBkeCAvIDNcbiAgICAgICAgZGVsdGEgPSBkeCAqIE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKVxuICAgICAgICBuZXdWYWx1ZSA9IG9yaWdpbmFsVmFsdWUgKyBkZWx0YVxuICAgICAgICAjIGlmIGtleS5jb21tYW5kXG4gICAgICAgICMgICBuZXdWYWx1ZSA9IFV0aWwucm91bmRUb1ByZWNpc2lvbihuZXdWYWx1ZSwgcHJlY2lzaW9uIC0gMSlcbiAgICAgICAgbmV3VmFsdWUgPSBVdGlsLnRvUHJlY2lzaW9uKG5ld1ZhbHVlLCBwcmVjaXNpb24pXG4gICAgICAgIEBtaXJyb3IucmVwbGFjZVNlbGVjdGlvbihcIlwiK25ld1ZhbHVlLCBcImFyb3VuZFwiKVxuXG5cblxuXG5cblxuXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuUiA9IHJlcXVpcmUgXCIuLi9SXCJcblxuUi5jcmVhdGUgXCJFZGl0YWJsZVRleHRcIixcbiAgcHJvcFR5cGVzOlxuICAgIHZhbHVlOiBTdHJpbmdcbiAgICBzZXRWYWx1ZTogRnVuY3Rpb25cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IChuZXh0UHJvcHMpIC0+XG4gICAgcmV0dXJuIEBfaXNEaXJ0eSBvciBuZXh0UHJvcHMudmFsdWUgIT0gQHByb3BzLnZhbHVlXG5cbiAgcmVuZGVyOiAtPlxuICAgIHByb3BzID0ge1xuICAgICAgY29udGVudEVkaXRhYmxlOiB0cnVlXG4gICAgICBvbklucHV0OiBAX29uSW5wdXRcbiAgICAgIG9uS2V5RG93bjogQF9vbktleURvd25cbiAgICB9XG4gICAgXy5kZWZhdWx0cyhwcm9wcywgQHByb3BzKVxuICAgIFIuZGl2IHByb3BzXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgQF9yZWZyZXNoKClcbiAgICAjIEF1dG9mb2N1cyBpZiBlbXB0eSBzdHJpbmcgdmFsdWUuXG4gICAgaWYgQHByb3BzLnZhbHVlID09IFwiXCIgb3IgIUBwcm9wcy52YWx1ZVxuICAgICAgQGdldERPTU5vZGUoKS5mb2N1cygpXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiAtPlxuICAgIEBfcmVmcmVzaCgpXG5cbiAgX3JlZnJlc2g6IC0+XG4gICAgZWwgPSBAZ2V0RE9NTm9kZSgpXG4gICAgaWYgZWwudGV4dENvbnRlbnQgIT0gQHByb3BzLnZhbHVlXG4gICAgICBlbC50ZXh0Q29udGVudCA9IEBwcm9wcy52YWx1ZVxuICAgIEBfaXNEaXJ0eSA9IGZhbHNlXG5cbiAgX29uSW5wdXQ6IC0+XG4gICAgQF9pc0RpcnR5ID0gdHJ1ZVxuICAgIGVsID0gQGdldERPTU5vZGUoKVxuICAgIG5ld1ZhbHVlID0gZWwudGV4dENvbnRlbnRcbiAgICBAcHJvcHMuc2V0VmFsdWUobmV3VmFsdWUpXG5cbiAgX29uS2V5RG93bjogKGUpIC0+XG4gICAgaWYgZS5rZXlDb2RlID09IDEzICMgRW50ZXJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblIgPSByZXF1aXJlIFwiLi4vUlwiXG5cblxuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcblxuc2l6ZUNhbnZhcyA9IChjYW52YXMpIC0+XG4gIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIGRldmljZVBpeGVsUmF0aW9cbiAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb1xuXG5cblIuY3JlYXRlIFwiSFRNTENhbnZhc1wiLFxuICBwcm9wVHlwZXM6XG4gICAgZHJhdzogRnVuY3Rpb25cblxuICByZW5kZXI6IC0+XG4gICAgcHJvcHMgPSB7fVxuICAgIF8uZGVmYXVsdHMocHJvcHMsIEBwcm9wcylcbiAgICBSLmNhbnZhcyBwcm9wc1xuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPiBAX3JlZnJlc2goKVxuICBjb21wb25lbnREaWRVcGRhdGU6IC0+IEBfcmVmcmVzaCgpXG5cbiAgcmVzaXplOiAtPlxuICAgIEBfY2FudmFzSXNTaXplZCA9IGZhbHNlXG5cbiAgX3JlZnJlc2g6IC0+XG4gICAgY2FudmFzID0gQGdldERPTU5vZGUoKVxuXG4gICAgaWYgQF9jYW52YXNJc1NpemVkXG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGhcbiAgICBlbHNlXG4gICAgICBzaXplQ2FudmFzKGNhbnZhcylcbiAgICAgIEBfY2FudmFzSXNTaXplZCA9IHRydWVcblxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRldmljZVBpeGVsUmF0aW8sIDAsIDAsIGRldmljZVBpeGVsUmF0aW8sIDAsIDApXG5cbiAgICBAcHJvcHMuZHJhdyhjdHgpXG4iLCJSID0gcmVxdWlyZSBcIi4vUlwiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuLi9Nb2RlbC9Nb2RlbFwiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxuUi5jcmVhdGUgXCJJbnNwZWN0b3JcIixcbiAgY29udGV4dFR5cGVzOlxuICAgIHByb2plY3Q6IE1vZGVsLlByb2plY3RcblxuICByZW5kZXI6IC0+XG4gICAgcHJvamVjdCA9IEBjb250ZXh0LnByb2plY3RcbiAgICBlbGVtZW50ID0gcHJvamVjdC5zZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50Py5lbGVtZW50XG5cbiAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIkluc3BlY3RvclwifSxcbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiSGVhZGVyXCJ9LFxuICAgICAgICBlbGVtZW50Py5sYWJlbCA/IFwiXCJcbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiU2Nyb2xsZXJcIn0sXG4gICAgICAgIGlmIGVsZW1lbnRcbiAgICAgICAgICBSLkZ1bGxBdHRyaWJ1dGVzTGlzdCB7ZWxlbWVudH1cblxuXG5SLmNyZWF0ZSBcIkZ1bGxBdHRyaWJ1dGVzTGlzdFwiLFxuICBwcm9wVHlwZXM6XG4gICAgZWxlbWVudDogTW9kZWwuRWxlbWVudFxuXG4gIHJlbmRlcjogLT5cbiAgICBlbGVtZW50ID0gQHByb3BzLmVsZW1lbnRcblxuICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiSW5zcGVjdG9yTGlzdFwifSxcbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQ29tcG9uZW50U2VjdGlvblwifSxcbiAgICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJDb21wb25lbnRTZWN0aW9uVGl0bGVcIn0sXG4gICAgICAgICAgUi5zcGFuIHt9LFxuICAgICAgICAgICAgXCJWYXJpYWJsZXNcIlxuICAgICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIkNvbXBvbmVudFNlY3Rpb25Db250ZW50XCJ9LFxuICAgICAgICAgIGZvciBhdHRyaWJ1dGUgaW4gZWxlbWVudC52YXJpYWJsZXMoKVxuICAgICAgICAgICAgUi5BdHRyaWJ1dGVSb3cge2F0dHJpYnV0ZSwga2V5OiBVdGlsLmdldElkKGF0dHJpYnV0ZSl9XG4gICAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQWRkVmFyaWFibGVSb3dcIn0sXG4gICAgICAgICAgUi5idXR0b24ge2NsYXNzTmFtZTogXCJBZGRCdXR0b25cIiwgb25DbGljazogQF9hZGRWYXJpYWJsZX1cblxuICAgICAgZm9yIGNvbXBvbmVudCBpbiBlbGVtZW50LmNvbXBvbmVudHMoKVxuICAgICAgICBSLkNvbXBvbmVudFNlY3Rpb24ge2NvbXBvbmVudCwga2V5OiBVdGlsLmdldElkKGNvbXBvbmVudCl9XG5cbiAgX2FkZFZhcmlhYmxlOiAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIGVsZW1lbnQuYWRkVmFyaWFibGUoKVxuXG5cblIuY3JlYXRlIFwiQ29tcG9uZW50U2VjdGlvblwiLFxuICBwcm9wVHlwZXM6XG4gICAgY29tcG9uZW50OiBNb2RlbC5Db21wb25lbnRcblxuICByZW5kZXI6IC0+XG4gICAgY29tcG9uZW50ID0gQHByb3BzLmNvbXBvbmVudFxuXG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJDb21wb25lbnRTZWN0aW9uXCJ9LFxuICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJDb21wb25lbnRTZWN0aW9uVGl0bGVcIn0sXG4gICAgICAgIFIuc3BhbixcbiAgICAgICAgICBjb21wb25lbnQubGFiZWxcbiAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiQ29tcG9uZW50U2VjdGlvbkNvbnRlbnRcIn0sXG4gICAgICAgIGZvciBhdHRyaWJ1dGUgaW4gY29tcG9uZW50LmF0dHJpYnV0ZXMoKVxuICAgICAgICAgIFIuQXR0cmlidXRlUm93IHthdHRyaWJ1dGUsIGtleTogVXRpbC5nZXRJZChhdHRyaWJ1dGUpfVxuXG5cbiMgTm92ZWxBdHRyaWJ1dGVzTGlzdCBpcyB1c2VkIHRvIHNob3cgYXR0cmlidXRlcyBpbiB0aGUgT3V0bGluZS4gQSBkZXNpZ25cbiMgcXVlc3Rpb24gaXMgd2hhdCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBzaG93bj8gV2Ugd2FudCB0byBzaG93IGFueXRoaW5nIHRoYXRcbiMgeW91IG1pZ2h0IHdhbnQgdG8gcmVmZXJlbmNlIGluIGFub3RoZXIgZXhwcmVzc2lvbiwgYW5kIGFueXRoaW5nIHRoYXQgbWlnaHRcbiMgYmUgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgYSBkaWFncmFtIChzbyB0aGF0IHRoZSBvdXRsaW5lIGlzIGxpa2UgdGhlIHNvdXJjZVxuIyBjb2RlIG9mIHRoZSBkaWFncmFtKS4gQ3VycmVudGx5IHdlIHNob3cgYW55IGF0dHJpYnV0ZSBmcm9tIGEgY29tcG9uZW50IHRoYXRcbiMgaXMgbm92ZWwgYW5kIGFsbCB2YXJpYWJsZXMuXG5SLmNyZWF0ZSBcIk5vdmVsQXR0cmlidXRlc0xpc3RcIixcbiAgcHJvcFR5cGVzOlxuICAgIGVsZW1lbnQ6IE1vZGVsLkVsZW1lbnRcblxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuXG4gIHJlbmRlcjogLT5cbiAgICB7ZWxlbWVudH0gPSBAcHJvcHNcbiAgICB7cHJvamVjdH0gPSBAY29udGV4dFxuXG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJBdHRyaWJ1dGVzTGlzdFwifSxcbiAgICAgIGZvciBhdHRyaWJ1dGUgaW4gZWxlbWVudC5hdHRyaWJ1dGVzKClcbiAgICAgICAgc2hvdWxkU2hvdyA9IGF0dHJpYnV0ZS5pc05vdmVsKCkgb3IgYXR0cmlidXRlLmlzVmFyaWFudE9mKE1vZGVsLlZhcmlhYmxlKVxuICAgICAgICBpZiBzaG91bGRTaG93XG4gICAgICAgICAgUi5BdHRyaWJ1dGVSb3cge2F0dHJpYnV0ZX1cbiAgICAgIGlmIGVsZW1lbnQgPT0gcHJvamVjdC5lZGl0aW5nRWxlbWVudFxuICAgICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIkFkZFZhcmlhYmxlUm93XCJ9LFxuICAgICAgICAgIFIuYnV0dG9uIHtjbGFzc05hbWU6IFwiQWRkQnV0dG9uIEludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IEBfYWRkVmFyaWFibGV9XG5cbiAgX2FkZFZhcmlhYmxlOiAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIGVsZW1lbnQuYWRkVmFyaWFibGUoKVxuIiwiXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblxuIyMjXG5cblRoZXNlIGFyZSB0aGUgb3B0aW9ucyB5b3UgY2FuIHBhc3MgaW4gdG8gRHJhZ01hbmFnZXIuc3RhcnQ6XG5cbiAgICBjdXJzb3I6IChTdHJpbmcpIFNldHMgdGhlIGdsb2JhbCBjdXJzb3IgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZ1xuICAgIGdlc3R1cmUuXG5cbiAgICBvbkNvbnN1bW1hdGUobW91c2VNb3ZlRXZlbnQpOiBXaWxsIGJlIGNhbGxlZCBvbmNlIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGVcbiAgICBtb3VzZSAzIHBpeGVscyBmcm9tIHRoZSBpbml0aWFsIG1vdXNlIGRvd24gbG9jYXRpb24uXG5cbiAgICBvbk1vdmUobW91c2VNb3ZlRXZlbnQpOiBXaWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5LCBldmVyeSB0aW1lIHRoZSBtb3VzZVxuICAgIG1vdmVzIGFmdGVyIHRoZSBkcmFnIGhhcyBiZWVuIGNvbnN1bW1hdGVkLlxuXG4gICAgb25Ecm9wKG1vdXNlVXBFdmVudCk6IFdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG9iamVjdCBiZWluZ1xuICAgIGRyYWdnZWQuXG5cbiAgICBvbkNhbmNlbChtb3VzZVVwRXZlbnQpOiBXaWxsIGJlIGNhbGxlZCBpZiB0aGUgdXNlciByZWxlYXNlcyB0aGUgb2JqZWN0XG4gICAgd2l0aG91dCBldmVyIGNvbnN1bW1hdGluZyB0aGUgZHJhZy4gV2hlbiBzdGlja3kgaXMgZmFsc2UsIHRoaXMgaXMgZXF1aXZhbGVudFxuICAgIHRvIGEgY2xpY2suIFdoZW4gc3RpY2t5IGlzIHRydWUsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBhIGRvdWJsZSBjbGljay5cblxuIyMjXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJhZ01hbmFnZXJcbiAgY29uc3RydWN0b3I6IC0+XG4gICAgQGRyYWcgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgQF9vbk1vdXNlTW92ZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgQF9vbk1vdXNlVXApXG5cbiAgc3RhcnQ6IChtb3VzZURvd25FdmVudCwgc3BlYykgLT5cbiAgICBAZHJhZyA9IG5ldyBEcmFnKG1vdXNlRG93bkV2ZW50LCBzcGVjKVxuXG4gIF9vbk1vdXNlTW92ZTogKG1vdXNlTW92ZUV2ZW50KSA9PlxuICAgIHJldHVybiB1bmxlc3MgQGRyYWdcbiAgICBpZiAhQGRyYWcuY29uc3VtbWF0ZWRcbiAgICAgICMgQ2hlY2sgaWYgd2Ugc2hvdWxkIGNvbnN1bW1hdGUuXG4gICAgICBkeCA9IG1vdXNlTW92ZUV2ZW50LmNsaWVudFggLSBAZHJhZy5vcmlnaW5hbFhcbiAgICAgIGR5ID0gbW91c2VNb3ZlRXZlbnQuY2xpZW50WSAtIEBkcmFnLm9yaWdpbmFsWVxuICAgICAgZCAgPSBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSlcbiAgICAgIGlmIGQgPiAzXG4gICAgICAgIEBfY29uc3VtbWF0ZShtb3VzZU1vdmVFdmVudClcbiAgICBlbHNlXG4gICAgICBAZHJhZy5vbk1vdmU/KG1vdXNlTW92ZUV2ZW50KVxuXG4gIF9vbk1vdXNlVXA6IChtb3VzZVVwRXZlbnQpID0+XG4gICAgcmV0dXJuIHVubGVzcyBAZHJhZ1xuICAgIGlmIEBkcmFnLmNvbnN1bW1hdGVkXG4gICAgICBAZHJhZy5vbkRyb3A/KG1vdXNlVXBFdmVudClcbiAgICBlbHNlXG4gICAgICBAZHJhZy5vbkNhbmNlbD8obW91c2VVcEV2ZW50KVxuICAgIEBkcmFnLm9uVXA/KG1vdXNlVXBFdmVudClcbiAgICBAZHJhZyA9IG51bGxcblxuICBfY29uc3VtbWF0ZTogKG1vdXNlTW92ZUV2ZW50KSAtPlxuICAgIEBkcmFnLmNvbnN1bW1hdGVkID0gdHJ1ZVxuICAgIEBkcmFnLm9uQ29uc3VtbWF0ZT8obW91c2VNb3ZlRXZlbnQpXG5cblxuY2xhc3MgRHJhZ1xuICBjb25zdHJ1Y3RvcjogKG1vdXNlRG93bkV2ZW50LCBzcGVjKSAtPlxuICAgIF8uZXh0ZW5kKHRoaXMsIHNwZWMpXG4gICAgQG9yaWdpbmFsWCA9IG1vdXNlRG93bkV2ZW50LmNsaWVudFhcbiAgICBAb3JpZ2luYWxZID0gbW91c2VEb3duRXZlbnQuY2xpZW50WVxuICAgIEBjb25zdW1tYXRlZCA/PSBmYWxzZVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBIb3Zlck1hbmFnZXJcbiAgY29uc3RydWN0b3I6IC0+XG4gICAgQGhvdmVyZWRQYXJ0aWN1bGFyRWxlbWVudCA9IG51bGxcbiAgICBAY29udHJvbGxlclBhcnRpY3VsYXJFbGVtZW50ID0gbnVsbFxuICAgIEBhdHRyaWJ1dGVzVG9DaGFuZ2UgPSBbXVxuICAgIEBob3ZlcmVkQXR0cmlidXRlID0gbnVsbFxuIiwia2V5ID0gcmVxdWlyZSBcImtleW1hc3RlclwiXG5SID0gcmVxdWlyZSBcIi4vUlwiXG5Nb2RlbCA9IHJlcXVpcmUgXCIuLi9Nb2RlbC9Nb2RlbFwiXG5VdGlsID0gcmVxdWlyZSBcIi4uL1V0aWwvVXRpbFwiXG5cblxuUi5jcmVhdGUgXCJNZW51YmFyXCIsXG4gIGNvbnRleHRUeXBlczpcbiAgICBlZGl0b3I6IE1vZGVsLkVkaXRvclxuICAgIHByb2plY3Q6IE1vZGVsLlByb2plY3RcblxuICByZW5kZXI6IC0+XG4gICAge2VkaXRvciwgcHJvamVjdH0gPSBAY29udGV4dFxuICAgIGlzU2VsZWN0aW9uID0gcHJvamVjdC5zZWxlY3RlZFBhcnRpY3VsYXJFbGVtZW50P1xuXG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJNZW51YmFyXCJ9LFxuICAgICAgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiTmV3XCIsIGlzRGlzYWJsZWQ6IGZhbHNlLCBmbjogQF9uZXd9XG4gICAgICBSLk1lbnViYXJJdGVtIHt0aXRsZTogXCJMb2FkXCIsIGlzRGlzYWJsZWQ6IGZhbHNlLCBmbjogQF9sb2FkfVxuICAgICAgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiU2F2ZVwiLCBpc0Rpc2FibGVkOiBmYWxzZSwgZm46IEBfc2F2ZX1cblxuICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJNZW51YmFyU2VwYXJhdG9yXCJ9XG5cbiAgICAgIFIuTWVudWJhckl0ZW0ge3RpdGxlOiBcIlVuZG9cIiwgaXNEaXNhYmxlZDogIWVkaXRvci5pc1VuZG9hYmxlKCksIGZuOiBAX3VuZG99XG4gICAgICBSLk1lbnViYXJJdGVtIHt0aXRsZTogXCJSZWRvXCIsIGlzRGlzYWJsZWQ6ICFlZGl0b3IuaXNSZWRvYWJsZSgpLCBmbjogQF9yZWRvfVxuXG4gICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIk1lbnViYXJTZXBhcmF0b3JcIn1cblxuICAgICAgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiRGVsZXRlXCIsIGlzRGlzYWJsZWQ6ICFpc1NlbGVjdGlvbiwgZm46IEBfcmVtb3ZlU2VsZWN0ZWRFbGVtZW50fVxuICAgICAgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiR3JvdXBcIiwgaXNEaXNhYmxlZDogIWlzU2VsZWN0aW9uLCBmbjogQF9ncm91cFNlbGVjdGVkRWxlbWVudH1cbiAgICAgICMgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiRHVwbGljYXRlXCIsIGlzRGlzYWJsZWQ6ICFpc1NlbGVjdGlvbiwgZm46IEBfZHVwbGljYXRlU2VsZWN0ZWRFbGVtZW50fVxuICAgICAgUi5NZW51YmFySXRlbSB7dGl0bGU6IFwiQ3JlYXRlIFN5bWJvbFwiLCBpc0Rpc2FibGVkOiAhaXNTZWxlY3Rpb24sIGZuOiBAX2NyZWF0ZVN5bWJvbEZyb21TZWxlY3RlZEVsZW1lbnR9XG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAga2V5IFwiYmFja3NwYWNlXCIsIChlKSA9PlxuICAgICAgcmV0dXJuIGlmIFV0aWwudGV4dEZvY3VzKClcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgQF9yZW1vdmVTZWxlY3RlZEVsZW1lbnQoKVxuXG4gIF9uZXc6IC0+XG4gICAge2VkaXRvcn0gPSBAY29udGV4dFxuICAgIGVkaXRvci5jcmVhdGVOZXdQcm9qZWN0KClcblxuICBfbG9hZDogLT5cbiAgICB7ZWRpdG9yfSA9IEBjb250ZXh0XG4gICAgZWRpdG9yLmxvYWRGcm9tRmlsZSgpXG5cbiAgX3NhdmU6IC0+XG4gICAge2VkaXRvcn0gPSBAY29udGV4dFxuICAgIGVkaXRvci5zYXZlVG9GaWxlKClcblxuICBfdW5kbzogLT5cbiAgICB7ZWRpdG9yfSA9IEBjb250ZXh0XG4gICAgZWRpdG9yLnVuZG8oKVxuXG4gIF9yZWRvOiAtPlxuICAgIHtlZGl0b3J9ID0gQGNvbnRleHRcbiAgICBlZGl0b3IucmVkbygpXG5cbiAgX3RvZG86IC0+XG5cbiAgX3JlbW92ZVNlbGVjdGVkRWxlbWVudDogLT5cbiAgICB7cHJvamVjdH0gPSBAY29udGV4dFxuICAgIHByb2plY3QucmVtb3ZlU2VsZWN0ZWRFbGVtZW50KClcblxuICBfZ3JvdXBTZWxlY3RlZEVsZW1lbnQ6IC0+XG4gICAge3Byb2plY3R9ID0gQGNvbnRleHRcbiAgICBwcm9qZWN0Lmdyb3VwU2VsZWN0ZWRFbGVtZW50KClcblxuICBfZHVwbGljYXRlU2VsZWN0ZWRFbGVtZW50OiAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAgcHJvamVjdC5kdXBsaWNhdGVTZWxlY3RlZEVsZW1lbnQoKVxuXG4gIF9jcmVhdGVTeW1ib2xGcm9tU2VsZWN0ZWRFbGVtZW50OiAtPlxuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAgcHJvamVjdC5jcmVhdGVTeW1ib2xGcm9tU2VsZWN0ZWRFbGVtZW50KClcblxuXG5SLmNyZWF0ZSBcIk1lbnViYXJJdGVtXCIsXG4gIHByb3BUeXBlczpcbiAgICB0aXRsZTogU3RyaW5nXG4gICAgaXNEaXNhYmxlZDogQm9vbGVhblxuICAgIGZuOiBGdW5jdGlvblxuXG4gIHJlbmRlcjogLT5cbiAgICB7dGl0bGUsIGlzRGlzYWJsZWQsIGZufSA9IEBwcm9wc1xuICAgIFIuZGl2IHtcbiAgICAgIGNsYXNzTmFtZTogUi5jeCB7XG4gICAgICAgIE1lbnViYXJJdGVtOiB0cnVlXG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgICAgIH1cbiAgICAgIG9uQ2xpY2s6IEBfYWN0aXZhdGVcbiAgICB9LCB0aXRsZVxuXG4gIF9hY3RpdmF0ZTogLT5cbiAgICB7aXNEaXNhYmxlZCwgZm59ID0gQHByb3BzXG4gICAgcmV0dXJuIGlmIGlzRGlzYWJsZWRcbiAgICBmbigpXG4iLCJfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuUiA9IHJlcXVpcmUgXCIuL1JcIlxuTW9kZWwgPSByZXF1aXJlIFwiLi4vTW9kZWwvTW9kZWxcIlxuVXRpbCA9IHJlcXVpcmUgXCIuLi9VdGlsL1V0aWxcIlxuXG5cblIuY3JlYXRlIFwiT3V0bGluZVwiLFxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuXG4gIHJlbmRlcjogLT5cbiAgICB7cHJvamVjdH0gPSBAY29udGV4dFxuICAgIGVsZW1lbnQgPSBwcm9qZWN0LmVkaXRpbmdFbGVtZW50XG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJPdXRsaW5lXCJ9LFxuICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJIZWFkZXJcIn0sIFwiT3V0bGluZVwiXG4gICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIlNjcm9sbGVyXCJ9LFxuICAgICAgICBSLk91dGxpbmVUcmVlIHtlbGVtZW50fVxuXG5cblIuY3JlYXRlIFwiT3V0bGluZVRyZWVcIixcbiAgcHJvcFR5cGVzOlxuICAgIGVsZW1lbnQ6IE1vZGVsLkVsZW1lbnRcblxuICBjb250ZXh0VHlwZXM6XG4gICAgZHJhZ01hbmFnZXI6IFIuRHJhZ01hbmFnZXJcblxuICBtaXhpbnM6IFtSLkFubm90YXRlTWl4aW5dXG5cbiAgcmVuZGVyOiAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuXG4gICAgaXNFeHBhbmRlZCA9IGVsZW1lbnQuZXhwYW5kZWRcbiAgICBkcmFnID0gZHJhZ01hbmFnZXIuZHJhZ1xuICAgIGlzQmVpbmdEcmFnZ2VkID0gZHJhZz8udHlwZSA9PSBcIm91dGxpbmVSZW9yZGVyXCIgYW5kXG4gICAgICBkcmFnLmNvbnN1bW1hdGVkIGFuZFxuICAgICAgZHJhZy5lbGVtZW50ID09IGVsZW1lbnRcblxuICAgIG91dGxpbmVUcmVlID0gUi5kaXYge2NsYXNzTmFtZTogXCJPdXRsaW5lVHJlZVwifSxcbiAgICAgIFIuT3V0bGluZUl0ZW0ge2VsZW1lbnR9XG4gICAgICBpZiBpc0V4cGFuZGVkXG4gICAgICAgIFIuT3V0bGluZUNoaWxkcmVuIHtlbGVtZW50fVxuXG4gICAgaWYgaXNCZWluZ0RyYWdnZWRcbiAgICAgIFIuZGl2IHt9LFxuICAgICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIk91dGxpbmVEcmFnZ2luZ1wiLCBzdHlsZToge1xuICAgICAgICAgIGxlZnQ6IGRyYWcueFxuICAgICAgICAgIHRvcDogZHJhZy55XG4gICAgICAgICAgd2lkdGg6IGRyYWcud2lkdGhcbiAgICAgICAgfX0sXG4gICAgICAgICAgb3V0bGluZVRyZWVcbiAgICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJPdXRsaW5lUGxhY2Vob2xkZXJcIiwgc3R5bGU6IHtoZWlnaHQ6IGRyYWcuaGVpZ2h0fX1cbiAgICBlbHNlXG4gICAgICBvdXRsaW5lVHJlZVxuXG4gIGFubm90YXRpb246IC0+XG4gICAgIyBVc2VkIGZvciBkcmFnIHJlb3JkaW5nLlxuICAgIHtlbGVtZW50OiBAcHJvcHMuZWxlbWVudH1cblxuXG5SLmNyZWF0ZSBcIk91dGxpbmVDaGlsZHJlblwiLFxuICBwcm9wVHlwZXM6XG4gICAgZWxlbWVudDogTW9kZWwuRWxlbWVudFxuXG4gIG1peGluczogW1IuQW5ub3RhdGVNaXhpbl1cblxuICByZW5kZXI6IC0+XG4gICAge2VsZW1lbnR9ID0gQHByb3BzXG4gICAgUi5kaXYge2NsYXNzTmFtZTogXCJPdXRsaW5lQ2hpbGRyZW5cIn0sXG4gICAgICBmb3IgY2hpbGRFbGVtZW50IGluIGVsZW1lbnQuY2hpbGRFbGVtZW50cygpXG4gICAgICAgIFIuT3V0bGluZVRyZWUge2VsZW1lbnQ6IGNoaWxkRWxlbWVudCwga2V5OiBVdGlsLmdldElkKGNoaWxkRWxlbWVudCl9XG5cbiAgYW5ub3RhdGlvbjogLT5cbiAgICAjIFVzZWQgZm9yIGRyYWcgcmVvcmRpbmcuXG4gICAge2VsZW1lbnQ6IEBwcm9wcy5lbGVtZW50fVxuXG5cblIuY3JlYXRlIFwiT3V0bGluZUl0ZW1cIixcbiAgcHJvcFR5cGVzOlxuICAgIGVsZW1lbnQ6IE1vZGVsLkVsZW1lbnRcblxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuICAgIGhvdmVyTWFuYWdlcjogUi5Ib3Zlck1hbmFnZXJcbiAgICBkcmFnTWFuYWdlcjogUi5EcmFnTWFuYWdlclxuXG4gIHJlbmRlcjogLT5cbiAgICBwcm9qZWN0ID0gQGNvbnRleHQucHJvamVjdFxuICAgIGVsZW1lbnQgPSBAcHJvcHMuZWxlbWVudFxuICAgIGhvdmVyTWFuYWdlciA9IEBjb250ZXh0LmhvdmVyTWFuYWdlclxuXG4gICAgaXNTZWxlY3RlZCA9IHByb2plY3Quc2VsZWN0ZWRQYXJ0aWN1bGFyRWxlbWVudD8uZWxlbWVudCA9PSBlbGVtZW50XG4gICAgaXNIb3ZlcmVkID0gaG92ZXJNYW5hZ2VyLmhvdmVyZWRQYXJ0aWN1bGFyRWxlbWVudD8uZWxlbWVudCA9PSBlbGVtZW50XG4gICAgaXNBY3RpdmVDb250cm9sbGVyID0gaG92ZXJNYW5hZ2VyLmNvbnRyb2xsZXJQYXJ0aWN1bGFyRWxlbWVudD8uZWxlbWVudCA9PSBlbGVtZW50XG4gICAgaXNDb250cm9sbGVyID0gZWxlbWVudC5pc0NvbnRyb2xsZXIoKVxuICAgIGlzRXhwYW5kZWQgPSBlbGVtZW50LmV4cGFuZGVkXG5cbiAgICBSLmRpdiB7XG4gICAgICBjbGFzc05hbWU6IFIuY3gge1xuICAgICAgICBPdXRsaW5lSXRlbTogdHJ1ZVxuICAgICAgICBpc1NlbGVjdGVkLCBpc0hvdmVyZWQsIGlzQWN0aXZlQ29udHJvbGxlciwgaXNDb250cm9sbGVyXG4gICAgICB9XG4gICAgICBvbk1vdXNlRG93bjogQF9vbk1vdXNlRG93blxuICAgICAgb25Nb3VzZUVudGVyOiBAX29uTW91c2VFbnRlclxuICAgICAgb25Nb3VzZUxlYXZlOiBAX29uTW91c2VMZWF2ZVxuICAgIH0sXG4gICAgICBSLmRpdiB7Y2xhc3NOYW1lOiBcIkVsZW1lbnRSb3dcIn0sXG4gICAgICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiRWxlbWVudFJvd0Rpc2Nsb3N1cmVcIn0sXG4gICAgICAgICAgUi5kaXYge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBSLmN4IHtcbiAgICAgICAgICAgICAgRGlzY2xvc3VyZVRyaWFuZ2xlOiB0cnVlXG4gICAgICAgICAgICAgIEludGVyYWN0aXZlOiB0cnVlXG4gICAgICAgICAgICAgIGlzRXhwYW5kZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2xpY2s6IEBfb25DbGlja1RyaWFuZ2xlLFxuICAgICAgICAgIH1cbiAgICAgICAgUi5kaXYge2NsYXNzTmFtZTogXCJFbGVtZW50Um93TGFiZWxcIn0sXG4gICAgICAgICAgUi5FZGl0YWJsZVRleHQge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkVkaXRhYmxlVGV4dElubGluZSBJbnRlcmFjdGl2ZVwiXG4gICAgICAgICAgICB2YWx1ZTogZWxlbWVudC5sYWJlbFxuICAgICAgICAgICAgc2V0VmFsdWU6IEBfc2V0TGFiZWxWYWx1ZVxuICAgICAgICAgIH1cbiAgICAgIFIuTm92ZWxBdHRyaWJ1dGVzTGlzdCB7ZWxlbWVudH1cblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgRXZlbnQgTG9naWNcbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBfb25Nb3VzZURvd246IChtb3VzZURvd25FdmVudCkgLT5cbiAgICB0YXJnZXQgPSBtb3VzZURvd25FdmVudC50YXJnZXRcbiAgICByZXR1cm4gaWYgVXRpbC5jbG9zZXN0KHRhcmdldCwgXCIuSW50ZXJhY3RpdmVcIilcbiAgICBtb3VzZURvd25FdmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgVXRpbC5jbGVhclRleHRGb2N1cygpXG4gICAgQF9zZWxlY3QoKVxuICAgIEBfc3RhcnREcmFnVG9SZW9yZGVyKG1vdXNlRG93bkV2ZW50KVxuXG4gIF9vbk1vdXNlRW50ZXI6IC0+XG4gICAge2VsZW1lbnR9ID0gQHByb3BzXG4gICAge2RyYWdNYW5hZ2VyLCBob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcbiAgICByZXR1cm4gaWYgZHJhZ01hbmFnZXIuZHJhZz9cbiAgICBwYXJ0aWN1bGFyRWxlbWVudCA9IG5ldyBNb2RlbC5QYXJ0aWN1bGFyRWxlbWVudChlbGVtZW50KVxuICAgIGhvdmVyTWFuYWdlci5ob3ZlcmVkUGFydGljdWxhckVsZW1lbnQgPSBwYXJ0aWN1bGFyRWxlbWVudFxuXG4gIF9vbk1vdXNlTGVhdmU6IC0+XG4gICAge2RyYWdNYW5hZ2VyLCBob3Zlck1hbmFnZXJ9ID0gQGNvbnRleHRcbiAgICByZXR1cm4gaWYgZHJhZ01hbmFnZXIuZHJhZz9cbiAgICBob3Zlck1hbmFnZXIuaG92ZXJlZFBhcnRpY3VsYXJFbGVtZW50ID0gbnVsbFxuXG5cbiAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIyBBY3Rpb25zXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3NldExhYmVsVmFsdWU6IChuZXdWYWx1ZSkgLT5cbiAgICBAcHJvcHMuZWxlbWVudC5sYWJlbCA9IG5ld1ZhbHVlXG5cbiAgX29uQ2xpY2tUcmlhbmdsZTogLT5cbiAgICB7ZWxlbWVudH0gPSBAcHJvcHNcbiAgICBlbGVtZW50LmV4cGFuZGVkID0gIWVsZW1lbnQuZXhwYW5kZWRcbiAgICByZXR1cm5cblxuICBfc2VsZWN0OiAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIHtwcm9qZWN0fSA9IEBjb250ZXh0XG4gICAgcGFydGljdWxhckVsZW1lbnQgPSBuZXcgTW9kZWwuUGFydGljdWxhckVsZW1lbnQoZWxlbWVudClcbiAgICBwcm9qZWN0LnNlbGVjdChwYXJ0aWN1bGFyRWxlbWVudClcblxuXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICMgRHJhZyBSZW9yZGVyXG4gICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgX3N0YXJ0RHJhZ1RvUmVvcmRlcjogKG1vdXNlRG93bkV2ZW50KSAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIHtkcmFnTWFuYWdlcn0gPSBAY29udGV4dFxuXG4gICAgZWwgPSBAZ2V0RE9NTm9kZSgpXG4gICAgb3V0bGluZVRyZWVFbCA9IFV0aWwuY2xvc2VzdChlbCwgXCIuT3V0bGluZVRyZWVcIilcbiAgICBvdXRsaW5lRWwgPSBVdGlsLmNsb3Nlc3QoZWwsIFwiLk91dGxpbmVcIilcbiAgICByZWN0ID0gb3V0bGluZVRyZWVFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgb2Zmc2V0WCA9IG1vdXNlRG93bkV2ZW50LmNsaWVudFggLSByZWN0LmxlZnRcbiAgICBvZmZzZXRZID0gbW91c2VEb3duRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG5cbiAgICB3aWR0aCA9IHJlY3Qud2lkdGhcbiAgICBoZWlnaHQgPSByZWN0LmhlaWdodFxuXG4gICAgZHJhZ01hbmFnZXIuc3RhcnQgbW91c2VEb3duRXZlbnQsXG4gICAgICB0eXBlOiBcIm91dGxpbmVSZW9yZGVyXCJcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgIG91dGxpbmVFbDogb3V0bGluZUVsXG4gICAgICB3aWR0aDogd2lkdGhcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICBvbk1vdmU6IChtb3VzZU1vdmVFdmVudCkgPT5cbiAgICAgICAgZHJhZ01hbmFnZXIuZHJhZy54ID0gbW91c2VNb3ZlRXZlbnQuY2xpZW50WCAtIG9mZnNldFhcbiAgICAgICAgZHJhZ01hbmFnZXIuZHJhZy55ID0gbW91c2VNb3ZlRXZlbnQuY2xpZW50WSAtIG9mZnNldFlcbiAgICAgICAgZHJvcFNwb3QgPSBAX2ZpbmREcm9wU3BvdChkcmFnTWFuYWdlci5kcmFnKVxuICAgICAgICBpZiBkcm9wU3BvdFxuICAgICAgICAgIEBfcmVvcmRlckl0ZW0oZHJvcFNwb3QpXG5cbiAgIyBfZmluZERyb3BTcG90IHJldHVybnMgYSBkcm9wU3BvdCBvYmplY3QgY29uc2lzdGluZyBvZiBvdXRsaW5lQ2hpbGRyZW5FbFxuICAjICh3aGVyZSB0byBpbnNlcnQpIGFuZCBiZWZvcmVPdXRsaW5lVHJlZUVsICh3aGVyZSB0byBpbnNlcnQgYWZ0ZXIsIGlmIG51bGxcbiAgIyB0aGVuIGluc2VydCBhdCB0aGUgZW5kKS4gSWYgbm90aGluZyBpcyBjbG9zZSBlbm91Z2gsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gIF9maW5kRHJvcFNwb3Q6IChkcmFnKSAtPlxuICAgIHt4LCB5LCBvdXRsaW5lRWx9ID0gZHJhZ1xuICAgIGRyYWdQb3NpdGlvbiA9IFt4LCB5XVxuXG4gICAgIyBUZW1wb3JhcmlseSBoaWRlIE91dGxpbmVQbGFjZWhvbGRlciBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBjYWxjdWxhdGlvbi5cbiAgICBvdXRsaW5lUGxhY2Vob2xkZXJFbCA9IG91dGxpbmVFbC5xdWVyeVNlbGVjdG9yKFwiLk91dGxpbmVQbGFjZWhvbGRlclwiKVxuICAgIG91dGxpbmVQbGFjZWhvbGRlckVsPy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcblxuICAgICMgS2VlcCB0cmFjayBvZiB0aGUgYmVzdCBkcm9wIHNwb3QuXG4gICAgYmVzdERyb3BTcG90ID0ge1xuICAgICAgcXVhZHJhbmNlOiA0MCAqIDQwICMgVGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgY2xvc2UgZW5vdWdoIHRvIGRyb3AuXG4gICAgfVxuICAgIGNoZWNrRml0ID0gKGRyb3BwZWRQb3NpdGlvbiwgb3V0bGluZUNoaWxkcmVuRWwsIGJlZm9yZU91dGxpbmVUcmVlRWwpID0+XG4gICAgICBxdWFkcmFuY2UgPSBVdGlsLnF1YWRyYW5jZShkcmFnUG9zaXRpb24sIGRyb3BwZWRQb3NpdGlvbilcbiAgICAgIGlmIHF1YWRyYW5jZSA8IGJlc3REcm9wU3BvdC5xdWFkcmFuY2VcbiAgICAgICAgYmVzdERyb3BTcG90ID0ge3F1YWRyYW5jZSwgb3V0bGluZUNoaWxkcmVuRWwsIGJlZm9yZU91dGxpbmVUcmVlRWx9XG5cbiAgICAjIEFsbCB0aGUgcGxhY2VzIHdpdGhpbiB3aGljaCB3ZSBjb3VsZCBkcm9wLlxuICAgIG91dGxpbmVDaGlsZHJlbkVscyA9IG91dGxpbmVFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLk91dGxpbmVDaGlsZHJlblwiKVxuXG4gICAgZm9yIG91dGxpbmVDaGlsZHJlbkVsIGluIG91dGxpbmVDaGlsZHJlbkVsc1xuICAgICAgIyBEb24ndCB0cnkgdG8gaW5zZXJ0IGl0IGludG8gaXRzZWxmIVxuICAgICAgY29udGludWUgaWYgVXRpbC5jbG9zZXN0KG91dGxpbmVDaGlsZHJlbkVsLCBcIi5PdXRsaW5lRHJhZ2dpbmdcIilcblxuICAgICAgIyBDaGVjayBmaXQgYmVmb3JlIGVhY2ggZXhpc3RpbmcgY2hpbGQuXG4gICAgICBjaGlsZEVscyA9IF8uZmlsdGVyKG91dGxpbmVDaGlsZHJlbkVsLmNoaWxkTm9kZXMsIChlbCkgLT4gVXRpbC5tYXRjaGVzKGVsLCBcIi5PdXRsaW5lVHJlZVwiKSlcbiAgICAgIGZvciBjaGlsZEVsIGluIGNoaWxkRWxzXG4gICAgICAgIHJlY3QgPSBjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGRyb3BwZWRQb3NpdGlvbiA9IFtyZWN0LmxlZnQsIHJlY3QudG9wXVxuICAgICAgICBjaGVja0ZpdChkcm9wcGVkUG9zaXRpb24sIG91dGxpbmVDaGlsZHJlbkVsLCBjaGlsZEVsKVxuXG4gICAgICAjIENoZWNrIGZpdCBhZnRlciB0aGUgbGFzdCBjaGlsZC5cbiAgICAgIHJlY3QgPSBvdXRsaW5lQ2hpbGRyZW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgZHJvcHBlZFBvc2l0aW9uID0gW3JlY3QubGVmdCwgcmVjdC5ib3R0b21dXG4gICAgICBjaGVja0ZpdChkcm9wcGVkUG9zaXRpb24sIG91dGxpbmVDaGlsZHJlbkVsLCBudWxsKVxuXG4gICAgIyBDbGVhbiB1cCBieSB1bmhpZGluZyBPdXRsaW5lUGxhY2Vob2xkZXJcbiAgICBvdXRsaW5lUGxhY2Vob2xkZXJFbD8uc3R5bGUuZGlzcGxheSA9IFwiXCJcblxuICAgIGlmIGJlc3REcm9wU3BvdC5vdXRsaW5lQ2hpbGRyZW5FbFxuICAgICAgcmV0dXJuIGJlc3REcm9wU3BvdFxuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsXG5cbiAgIyBfcmVvcmRlckl0ZW0gd2lsbCBtb3ZlIG15IGVsZW1lbnQgdG8gYSBkcm9wU3BvdC4gZHJvcFNwb3Qgc2hvdWxkIGJlIGFuXG4gICMgb2JqZWN0IHdpdGggb3V0bGluZUNoaWxkcmVuRWwgKHdoZXJlIHRvIGluc2VydCkgYW5kIGJlZm9yZU91dGxpbmVUcmVlRWxcbiAgIyAod2hlcmUgdG8gaW5zZXJ0IGFmdGVyLCBpZiBudWxsIHRoZW4gaW5zZXJ0IGF0IHRoZSBlbmQpLlxuICBfcmVvcmRlckl0ZW06IChkcm9wU3BvdCkgLT5cbiAgICB7ZWxlbWVudH0gPSBAcHJvcHNcbiAgICB7b3V0bGluZUNoaWxkcmVuRWwsIGJlZm9yZU91dGxpbmVUcmVlRWx9ID0gZHJvcFNwb3RcblxuICAgIHBhcmVudEVsZW1lbnQgPSBvdXRsaW5lQ2hpbGRyZW5FbC5hbm5vdGF0aW9uLmVsZW1lbnRcbiAgICBpZiBiZWZvcmVPdXRsaW5lVHJlZUVsXG4gICAgICBiZWZvcmVFbGVtZW50ID0gYmVmb3JlT3V0bGluZVRyZWVFbC5hbm5vdGF0aW9uLmVsZW1lbnRcbiAgICAgIGlmIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4oKS5pbmRleE9mKGVsZW1lbnQpICE9IC0xXG4gICAgICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudClcbiAgICAgIGluZGV4ID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbigpLmluZGV4T2YoYmVmb3JlRWxlbWVudClcbiAgICAgIHBhcmVudEVsZW1lbnQuYWRkQ2hpbGQoZWxlbWVudCwgaW5kZXgpXG4gICAgZWxzZVxuICAgICAgcGFyZW50RWxlbWVudC5hZGRDaGlsZChlbGVtZW50KVxuIiwiUiA9IHJlcXVpcmUgXCIuL1JcIlxuTW9kZWwgPSByZXF1aXJlIFwiLi4vTW9kZWwvTW9kZWxcIlxuVXRpbCA9IHJlcXVpcmUgXCIuLi9VdGlsL1V0aWxcIlxuXG5cblIuY3JlYXRlIFwiVGh1bWJuYWlsXCIsXG4gIHByb3BUeXBlczpcbiAgICBlbGVtZW50OiBNb2RlbC5FbGVtZW50XG5cbiAgcmVuZGVyOiAtPlxuICAgIGVsZW1lbnQgPSBAcHJvcHMuZWxlbWVudFxuICAgIFIuZGl2IHtjbGFzc05hbWU6IFwiVGh1bWJuYWlsXCJ9LFxuICAgICAgUi5QaWN0dXJlIHtlbGVtZW50fVxuXG5cblxuXG5cblIuY3JlYXRlIFwiUGljdHVyZVwiLFxuICBjb250ZXh0VHlwZXM6XG4gICAgcHJvamVjdDogTW9kZWwuUHJvamVjdFxuICAgIGhvdmVyTWFuYWdlcjogUi5Ib3Zlck1hbmFnZXJcblxuICBwcm9wVHlwZXM6XG4gICAgZWxlbWVudDogTW9kZWwuRWxlbWVudFxuXG4gIHJlbmRlcjogLT5cbiAgICBSLkhUTUxDYW52YXMge1xuICAgICAgZHJhdzogQF9kcmF3XG4gICAgfVxuXG4gIF9kcmF3OiAoY3R4KSAtPlxuICAgIHByb2plY3QgPSBAY29udGV4dC5wcm9qZWN0XG4gICAgaG92ZXJNYW5hZ2VyID0gQGNvbnRleHQuaG92ZXJNYW5hZ2VyXG4gICAgZWxlbWVudCA9IEBwcm9wcy5lbGVtZW50XG4gICAgdmlld01hdHJpeCA9IEBfdmlld01hdHJpeCgpXG5cbiAgICBoaWdobGlnaHQgPSAoZ3JhcGhpYykgLT5cbiAgICAgIHBhcnRpY3VsYXJFbGVtZW50ID0gZ3JhcGhpYy5wYXJ0aWN1bGFyRWxlbWVudFxuICAgICAgaWYgaG92ZXJNYW5hZ2VyLmNvbnRyb2xsZXJQYXJ0aWN1bGFyRWxlbWVudD8uaXNBbmNlc3Rvck9mKHBhcnRpY3VsYXJFbGVtZW50KVxuICAgICAgICByZXR1cm4ge2NvbG9yOiBcIiNjMDBcIiwgbGluZVdpZHRoOiAyLjV9XG4gICAgICBpZiBwcm9qZWN0LnNlbGVjdGVkUGFydGljdWxhckVsZW1lbnQ/LmlzQW5jZXN0b3JPZihwYXJ0aWN1bGFyRWxlbWVudClcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogXCIjMDljXCIsIGxpbmVXaWR0aDogMi41fVxuICAgICAgaWYgaG92ZXJNYW5hZ2VyLmhvdmVyZWRQYXJ0aWN1bGFyRWxlbWVudD8uaXNBbmNlc3Rvck9mKHBhcnRpY3VsYXJFbGVtZW50KVxuICAgICAgICByZXR1cm4ge2NvbG9yOiBcIiMwYzlcIiwgbGluZVdpZHRoOiAyLjV9XG5cbiAgICByZW5kZXJPcHRzID0ge2N0eCwgdmlld01hdHJpeCwgaGlnaGxpZ2h0fVxuXG4gICAgZm9yIGdyYXBoaWMgaW4gZWxlbWVudC5hbGxHcmFwaGljcygpXG4gICAgICBncmFwaGljLnJlbmRlcihyZW5kZXJPcHRzKVxuXG4gIF92aWV3TWF0cml4OiAtPlxuICAgIHtlbGVtZW50fSA9IEBwcm9wc1xuICAgIHt3aWR0aCwgaGVpZ2h0fSA9IEBfc2l6ZSgpXG4gICAgc2NyZWVuTWF0cml4ID0gbmV3IFV0aWwuTWF0cml4KDAuMSwgMCwgMCwgLTAuMSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKVxuICAgIGVsZW1lbnRWaWV3TWF0cml4ID0gZWxlbWVudC52aWV3TWF0cml4XG4gICAgcmV0dXJuIHNjcmVlbk1hdHJpeC5jb21wb3NlKGVsZW1lbnRWaWV3TWF0cml4KVxuXG4gIF9zaXplOiAtPlxuICAgIHJldHVybiBAX2NhY2hlZFNpemUgaWYgQF9jYWNoZWRTaXplXG4gICAgZWwgPSBAZ2V0RE9NTm9kZSgpXG4gICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAge3dpZHRoLCBoZWlnaHR9ID0gcmVjdFxuICAgIHJldHVybiBAX2NhY2hlZFNpemUgPSB7d2lkdGgsIGhlaWdodH1cbiIsIiMgUmVhY3QgPSByZXF1aXJlIFwicmVhY3RcIlxuXyA9IHJlcXVpcmUgXCJ1bmRlcnNjb3JlXCJcblxuTW9kZWwgPSByZXF1aXJlIFwiLi4vTW9kZWwvTW9kZWxcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gUiA9IHt9XG5cblxuIyBQcm92aWRlIGVhc3kgYWNjZXNzIHRvIFJlYWN0LkRPTVxuZm9yIG93biBrZXksIHZhbHVlIG9mIFJlYWN0LkRPTVxuICBSW2tleV0gPSB2YWx1ZVxuXG4jIFV0aWxpdHkgKGZyb20gUmVhY3QuYWRkb25zLmNsYXNzU2V0KVxuUi5jeCA9IChjbGFzc05hbWVzKSAtPlxuICBPYmplY3Qua2V5cyhjbGFzc05hbWVzKS5maWx0ZXIoKGNsYXNzTmFtZSkgLT4gY2xhc3NOYW1lc1tjbGFzc05hbWVdKS5qb2luKFwiIFwiKVxuXG4jIEFubm90YXRlTWl4aW4gaXMgdXNlZCB0byBhbm5vdGF0ZSB0aGUgY3JlYXRlZCBET00gTm9kZSB3aXRoIHNvbWUgZXh0cmFcbiMgaW5mb3JtYXRpb24gaW4gYW4gXCJleHBhbmRvXCIgcHJvcGVydHkgY2FsbGVkIGFubm90YXRpb24uIFRoaXMgaXMgb2Z0ZW4gdXNlZnVsXG4jIHdoZW4gY29vcmRpbmF0aW5nIGludGVyYWN0aW9ucyB3aXRoIG90aGVyIENvbXBvbmVudHMuIFdoZW4gdXNpbmcgdGhpcyBNaXhpbixcbiMgbGVhdmUgYSBub3RlIHNheWluZyB3aHkgdGhlIGFubm90YXRpb24gaXMgbmVlZGVkLlxuUi5Bbm5vdGF0ZU1peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogLT4gQF9hbm5vdGF0ZURPTU5vZGUoKVxuICBjb21wb25lbnREaWRVcGRhdGU6IC0+IEBfYW5ub3RhdGVET01Ob2RlKClcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IC0+IEBfY2xlYXJBbm5vdGF0aW9uKClcbiAgX2Fubm90YXRlRE9NTm9kZTogLT5cbiAgICBlbCA9IEBnZXRET01Ob2RlKClcbiAgICBlbC5hbm5vdGF0aW9uID0gQGFubm90YXRpb24oKVxuICBfY2xlYXJBbm5vdGF0aW9uOiAtPlxuICAgIGVsID0gQGdldERPTU5vZGUoKVxuICAgIGRlbGV0ZSBlbC5hbm5vdGF0aW9uXG59XG5cblxuUi5jcmVhdGUgPSAobmFtZSwgc3BlYykgLT5cbiAgIyBDb21wb25lbnQuZGlzcGxheU5hbWUgaXMgdXNlZCBieSBSZWFjdCBpbiBpdHMgZGVidWdnaW5nIG1lc3NhZ2VzLlxuICBzcGVjLmRpc3BsYXlOYW1lID0gbmFtZVxuXG4gIGZvciB0eXBlc1Byb3BlcnR5IGluIFtcInByb3BUeXBlc1wiLCBcImNoaWxkQ29udGV4dFR5cGVzXCIsIFwiY29udGV4dFR5cGVzXCJdXG4gICAgaWYgc3BlY1t0eXBlc1Byb3BlcnR5XVxuICAgICAgc3BlY1t0eXBlc1Byb3BlcnR5XSA9IGRlc3VnYXJQcm9wVHlwZXMoc3BlY1t0eXBlc1Byb3BlcnR5XSlcblxuICBjb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyhzcGVjKVxuICBSW25hbWVdID0gUmVhY3QuY3JlYXRlRmFjdG9yeShjb21wb25lbnQpXG5cblxuUi5yZW5kZXIgPSBSZWFjdC5yZW5kZXJcblxuXG5kZXN1Z2FyUHJvcFR5cGVzID0gKHByb3BUeXBlcykgLT5cbiAgcmV0dXJuIF8ubWFwT2JqZWN0IHByb3BUeXBlcywgZGVzdWdhclByb3BUeXBlXG5cbmRlc3VnYXJQcm9wVHlwZSA9IChwcm9wVHlwZSkgLT5cbiAgaWYgcHJvcFR5cGUgPT0gTnVtYmVyXG4gICAgcmV0dXJuIFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICBlbHNlIGlmIHByb3BUeXBlID09IFN0cmluZ1xuICAgIHJldHVybiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgZWxzZSBpZiBwcm9wVHlwZSA9PSBCb29sZWFuXG4gICAgcmV0dXJuIFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbiAgZWxzZSBpZiBwcm9wVHlwZSA9PSBGdW5jdGlvblxuICAgIHJldHVybiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIGVsc2UgaWYgcHJvcFR5cGUgPT0gQXJyYXlcbiAgICByZXR1cm4gUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgZWxzZSBpZiBwcm9wVHlwZSA9PSBPYmplY3RcbiAgICByZXR1cm4gUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gIGVsc2UgaWYgcHJvcFR5cGUgPT0gXCJhbnlcIlxuICAgIHJldHVybiBSZWFjdC5Qcm9wVHlwZXMuYW55XG4gIGVsc2UgaWYgcHJvcFR5cGUuaXNWYXJpYW50T2Y/XG4gICAgIyBDdXN0b20gcHJvcFR5cGUgZm9yIGRlYWxpbmcgd2l0aCBOb2Rlc1xuICAgIHJldHVybiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSAtPlxuICAgICAgcHJvcCA9IHByb3BzW3Byb3BOYW1lXVxuICAgICAgdW5sZXNzIHByb3AuaXNWYXJpYW50T2YocHJvcFR5cGUpXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbiBgI3tjb21wb25lbnROYW1lfWAsIHByb3BlcnR5IGAje3Byb3BOYW1lfWAgaXMgdGhlIHdyb25nIHR5cGUuXCIpXG4gIGVsc2VcbiAgICByZXR1cm4gUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YocHJvcFR5cGUpLmlzUmVxdWlyZWRcblxuXG5cblxuXG5SLkRyYWdNYW5hZ2VyID0gcmVxdWlyZSBcIi4vTWFuYWdlci9EcmFnTWFuYWdlclwiXG5SLkhvdmVyTWFuYWdlciA9IHJlcXVpcmUgXCIuL01hbmFnZXIvSG92ZXJNYW5hZ2VyXCJcblxucmVxdWlyZSBcIi4vR2VuZXJpYy9FZGl0YWJsZVRleHRcIlxucmVxdWlyZSBcIi4vR2VuZXJpYy9IVE1MQ2FudmFzXCJcbnJlcXVpcmUgXCIuL1BpY3R1cmVcIlxucmVxdWlyZSBcIi4vRWRpdG9yXCJcbnJlcXVpcmUgXCIuL01lbnViYXJcIlxucmVxdWlyZSBcIi4vQ3JlYXRlUGFuZWxcIlxucmVxdWlyZSBcIi4vQ2FudmFzXCJcbnJlcXVpcmUgXCIuL091dGxpbmVcIlxucmVxdWlyZSBcIi4vSW5zcGVjdG9yXCJcbnJlcXVpcmUgXCIuL0F0dHJpYnV0ZVJvd1wiXG5yZXF1aXJlIFwiLi9FeHByZXNzaW9uXCJcbnJlcXVpcmUgXCIuL0V4cHJlc3Npb25Db2RlXCJcbiIsIl8gPSByZXF1aXJlIFwidW5kZXJzY29yZVwiXG5SID0gcmVxdWlyZSBcIi4vVmlldy9SXCJcbk1vZGVsID0gcmVxdWlyZSBcIi4vTW9kZWwvTW9kZWxcIlxuRGF0YWZsb3cgPSByZXF1aXJlIFwiLi9EYXRhZmxvdy9EYXRhZmxvd1wiXG5TdG9yYWdlID0gcmVxdWlyZSBcIi4vU3RvcmFnZS9TdG9yYWdlXCJcblV0aWwgPSByZXF1aXJlIFwiLi9VdGlsL1V0aWxcIlxuXG5cbiMgRm9yIGRlYnVnZ2luZ1xuQXBwYXJhdHVzID0gd2luZG93LkFwcGFyYXR1cyA9IHt9XG5BcHBhcmF0dXMuRGF0YWZsb3cgPSBEYXRhZmxvd1xuQXBwYXJhdHVzLk1vZGVsID0gTW9kZWxcbkFwcGFyYXR1cy5TdG9yYWdlID0gU3RvcmFnZVxuQXBwYXJhdHVzLlIgPSBSXG5BcHBhcmF0dXMuVXRpbCA9IFV0aWxcblxuXG5cblxuZWRpdG9yID0gbmV3IE1vZGVsLkVkaXRvcigpXG5cblxuXG5cbiMgRm9yIGRlYnVnZ2luZ1xuQXBwYXJhdHVzLmVkaXRvciA9IGVkaXRvclxuXG5cblxuXG5yZW5kZXIgPSAtPlxuICBEYXRhZmxvdy5ydW4gLT5cbiAgICBSLnJlbmRlcihSLkVkaXRvcih7ZWRpdG9yfSksIGRvY3VtZW50LmJvZHkpXG5cbnJlbmRlcigpXG5cblxuXG5zaG91bGRDaGVja3BvaW50ID0gZmFsc2VcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciBcIm1vdXNldXBcIiwgLT5cbiAgc2hvdWxkQ2hlY2twb2ludCA9IHRydWVcblxuZGVib3VuY2VkU2hvdWxkQ2hlY2twb2ludCA9IF8uZGVib3VuY2UoLT5cbiAgc2hvdWxkQ2hlY2twb2ludCA9IHRydWVcbiwgNTAwKVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciBcImtleWRvd25cIiwgLT5cbiAgZGVib3VuY2VkU2hvdWxkQ2hlY2twb2ludCgpXG5cblxuXG5cbndpbGxSZWZyZXNoTmV4dEZyYW1lID0gZmFsc2VcbnJlZnJlc2ggPSBBcHBhcmF0dXMucmVmcmVzaCA9IC0+XG4gIHJldHVybiBpZiB3aWxsUmVmcmVzaE5leHRGcmFtZVxuICB3aWxsUmVmcmVzaE5leHRGcmFtZSA9IHRydWVcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIC0+XG4gICAgcmVuZGVyKClcbiAgICBpZiBzaG91bGRDaGVja3BvaW50XG4gICAgICBlZGl0b3IuY2hlY2twb2ludCgpXG4gICAgICBzaG91bGRDaGVja3BvaW50ID0gZmFsc2VcbiAgICB3aWxsUmVmcmVzaE5leHRGcmFtZSA9IGZhbHNlXG5cbnJlZnJlc2hFdmVudE5hbWVzID0gW1xuICBcIm1vdXNlZG93blwiXG4gIFwibW91c2Vtb3ZlXCJcbiAgXCJtb3VzZXVwXCJcbiAgXCJrZXlkb3duXCJcbiAgXCJrZXl1cFwiXG4gIFwic2Nyb2xsXCJcbiAgXCJjaGFuZ2VcIlxuICBcIndoZWVsXCJcbiAgXCJtb3VzZXdoZWVsXCJcbl1cblxuZm9yIGV2ZW50TmFtZSBpbiByZWZyZXNoRXZlbnROYW1lc1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlZnJlc2gpXG5cbiJdfQ==
